{
  "files": [
    {
      "file_path": "context_bundle.json",
      "change_type": "Modified",
      "diff": "",
      "affected_symbols": [],
      "related_files": []
    },
    {
      "file_path": "internal/reviewer/astparser/context_manager.go",
      "change_type": "Modified",
      "diff": "@@ -2,7 +2,6 @@ package astparser\n \n import (\n \t\"context\"\n-\t\"fmt\"\n \t\"path/filepath\"\n \t\"strings\"\n \n@@ -22,48 +21,6 @@ type ContextManager struct {\n \tlog            logze.Logger\n }\n \n-// ChangeType represents the type of file change\n-type ChangeType string\n-\n-const (\n-\tChangeTypeModified ChangeType = \"Modified\"\n-\tChangeTypeAdded    ChangeType = \"Added\"\n-\tChangeTypeDeleted  ChangeType = \"Deleted\"\n-\tChangeTypeRenamed  ChangeType = \"Renamed\"\n-)\n-\n-// ContextBundle represents the final structured context for LLM\n-type ContextBundle struct {\n-\tFiles []FileContext `json:\"files\"`\n-}\n-\n-// FileContext represents context for a single changed file\n-type FileContext struct {\n-\tFilePath        string           `json:\"file_path\"`\n-\tChangeType      ChangeType       `json:\"change_type\"`\n-\tDiff            string           `json:\"diff_hunk\"`\n-\tAffectedSymbols []AffectedSymbol `json:\"affected_symbols\"`\n-\tRelatedFiles    []RelatedFile    `json:\"related_files\"`\n-\tConfigContext   *ConfigContext   `json:\"config_context,omitempty\"`\n-}\n-\n-// RelatedFile represents a file related to the changed file\n-type RelatedFile struct {\n-\tFilePath         string `json:\"file_path\"`\n-\tRelationship     string `json:\"relationship\"` // \"caller\", \"dependency\", \"test\", \"same_package\"\n-\tCodeSnippet      string `json:\"code_snippet\"`\n-\tLine             int    `json:\"line,omitempty\"`\n-\tRelevantFunction string `json:\"relevant_function,omitempty\"`\n-}\n-\n-// ConfigContext represents context for configuration file changes\n-type ConfigContext struct {\n-\tConfigType       string        `json:\"config_type\"` // \"yaml\", \"json\", \"env\", etc.\n-\tChangedKeys      []string      `json:\"changed_keys\"`\n-\tConsumingCode    []RelatedFile `json:\"consuming_code\"`\n-\tImpactAssessment string        `json:\"impact_assessment\"`\n-}\n-\n // newContextFinder creates a new context finder\n func NewContextFinder(provider interfaces.CodeProvider) *ContextManager {\n \treturn \u0026ContextManager{\n@@ -84,11 +41,9 @@ type ContextRequest struct {\n }\n \n // GatherContext gathers comprehensive context for a merge request\n-func (cf *ContextManager) GatherContext(ctx context.Context, request ContextRequest) (*ContextBundle, error) {\n-\tbundle := \u0026ContextBundle{\n-\t\tFiles: make([]FileContext, 0, len(request.FileDiffs)),\n-\t}\n+func (cf *ContextManager) GatherFilesContext(ctx context.Context, request ContextRequest) ([]*FileContext, error) {\n \n+\tfiles := make([]*FileContext, 0, len(request.FileDiffs))\n \t// Process each changed file\n \tfor _, fileDiff := range request.FileDiffs {\n \t\tfileContext, err := cf.processFileDiff(ctx, request, fileDiff)\n@@ -98,11 +53,11 @@ func (cf *ContextManager) GatherContext(ctx context.Context, request ContextRequ\n \t\t}\n \n \t\tif fileContext != nil {\n-\t\t\tbundle.Files = append(bundle.Files, *fileContext)\n+\t\t\tfiles = append(files, fileContext)\n \t\t}\n \t}\n \n-\treturn bundle, nil\n+\treturn files, nil\n }\n \n // processFileDiff processes a single file diff to extract context\n@@ -117,7 +72,9 @@ func (cf *ContextManager) processFileDiff(ctx context.Context, request ContextRe\n \t}\n \n \tif cf.isConfigFile(fileDiff.NewPath) {\n-\t\treturn cf.processConfigFile(ctx, request, fileDiff, fileContext)\n+\t\t// TODO: add config file processing\n+\t\tcf.log.Warn(\"config file detected, skipping\", \"file\", fileDiff.NewPath)\n+\t\treturn fileContext, nil\n \t}\n \n \t// Handle different change types\n@@ -136,20 +93,6 @@ func (cf *ContextManager) processFileDiff(ctx context.Context, request ContextRe\n \treturn fileContext, nil\n }\n \n-// determineChangeType determines the type of change for a file\n-func (cf *ContextManager) determineChangeType(fileDiff *model.FileDiff) ChangeType {\n-\tif fileDiff.IsNew {\n-\t\treturn ChangeTypeAdded\n-\t}\n-\tif fileDiff.IsDeleted {\n-\t\treturn ChangeTypeDeleted\n-\t}\n-\tif fileDiff.IsRenamed {\n-\t\treturn ChangeTypeRenamed\n-\t}\n-\treturn ChangeTypeModified\n-}\n-\n // processAddedFile processes a newly added file\n func (cf *ContextManager) processAddedFile(ctx context.Context, request ContextRequest, fileDiff *model.FileDiff, fileContext *FileContext) (*FileContext, error) {\n \t// For new files, the entire file is \"affected\"\n@@ -167,13 +110,13 @@ func (cf *ContextManager) processAddedFile(ctx context.Context, request ContextR\n \t}\n \n \t// Find all symbols in the new file\n-\tallSymbols, err := cf.astParser.findAllSymbolsInFile(fileDiff.NewPath, content)\n+\tallSymbols, err := cf.astParser.FindAllSymbolsInFile(ctx, fileDiff.NewPath, content)\n \tif err != nil {\n \t\tcf.log.Warn(\"failed to find symbols in new file\", \"error\", err, \"file\", fileDiff.NewPath)\n \t\treturn fileContext, nil\n \t}\n \n-\t// For each symbol, find if it's already being used (cross-references within the same PR)\n+\t// For each symbol, find if it's already being used\n \tfor _, symbol := range allSymbols {\n \t\t// Analyze usage context\n \t\tusageContext, err := cf.symbolAnalyzer.AnalyzeSymbolUsage(ctx, request.RepoDataHead, symbol)\n@@ -184,14 +127,31 @@ func (cf *ContextManager) processAddedFile(ctx context.Context, request ContextR\n \n \t\t// Add caller information to related files\n \t\tfor _, caller := range usageContext.Callers {\n-\t\t\trelatedFile := RelatedFile{\n+\t\t\tsymbol.Callers = append(symbol.Callers, Dependency{\n+\t\t\t\tName: caller.FunctionName,\n+\t\t\t\tLine: caller.LineNumber,\n+\t\t\t\tType: SymbolTypeFunction,\n+\t\t\t\tCode: lang.Check(caller.CodeSnippet, caller.Code),\n+\t\t\t})\n+\t\t\tfileContext.RelatedFiles = append(fileContext.RelatedFiles, RelatedFile{\n \t\t\t\tFilePath:         caller.FilePath,\n \t\t\t\tRelationship:     \"caller\",\n \t\t\t\tCodeSnippet:      caller.CodeSnippet,\n \t\t\t\tLine:             caller.LineNumber,\n \t\t\t\tRelevantFunction: caller.FunctionName,\n+\t\t\t})\n+\t\t}\n+\n+\t\tdepMap := make(map[string]Dependency)\n+\t\tfor _, dep := range usageContext.Dependencies {\n+\t\t\tdepMap[dep.SymbolName] = Dependency{\n+\t\t\t\tName: dep.SymbolName,\n+\t\t\t\tCode: dep.Code,\n \t\t\t}\n-\t\t\tfileContext.RelatedFiles = append(fileContext.RelatedFiles, relatedFile)\n+\t\t}\n+\n+\t\tfor i := range symbol.Dependencies {\n+\t\t\tsymbol.Dependencies[i].Code = depMap[symbol.Dependencies[i].Name].Code\n \t\t}\n \n \t\t// Set usage context for the symbol\n@@ -220,7 +180,7 @@ func (cf *ContextManager) processDeletedFile(ctx context.Context, request Contex\n \t}\n \n \t// Find all symbols that were in the deleted file\n-\tallSymbols, err := cf.astParser.findAllSymbolsInFile(fileDiff.OldPath, content)\n+\tallSymbols, err := cf.astParser.FindAllSymbolsInFile(ctx, fileDiff.OldPath, content)\n \tif err != nil {\n \t\tcf.log.Warn(\"failed to find symbols in deleted file\", \"error\", err, \"file\", fileDiff.OldPath)\n \t\treturn fileContext, nil\n@@ -234,18 +194,37 @@ func (cf *ContextManager) processDeletedFile(ctx context.Context, request Contex\n \t\t\tcontinue\n \t\t}\n \n-\t\t// Any callers found indicate potential issues\n+\t\t// Add caller information to related files\n \t\tfor _, caller := range usageContext.Callers {\n-\t\t\trelatedFile := RelatedFile{\n+\t\t\tsymbol.Callers = append(symbol.Callers, Dependency{\n+\t\t\t\tName: caller.FunctionName,\n+\t\t\t\tLine: caller.LineNumber,\n+\t\t\t\tType: SymbolTypeFunction,\n+\t\t\t\tCode: lang.Check(caller.CodeSnippet, caller.Code),\n+\t\t\t})\n+\t\t\tfileContext.RelatedFiles = append(fileContext.RelatedFiles, RelatedFile{\n \t\t\t\tFilePath:         caller.FilePath,\n-\t\t\t\tRelationship:     \"broken_caller\",\n+\t\t\t\tRelationship:     \"caller\",\n \t\t\t\tCodeSnippet:      caller.CodeSnippet,\n \t\t\t\tLine:             caller.LineNumber,\n \t\t\t\tRelevantFunction: caller.FunctionName,\n+\t\t\t})\n+\t\t}\n+\n+\t\tdepMap := make(map[string]Dependency)\n+\t\tfor _, dep := range usageContext.Dependencies {\n+\t\t\tdepMap[dep.SymbolName] = Dependency{\n+\t\t\t\tName: dep.SymbolName,\n+\t\t\t\tCode: dep.Code,\n \t\t\t}\n-\t\t\tfileContext.RelatedFiles = append(fileContext.RelatedFiles, relatedFile)\n \t\t}\n \n+\t\tfor i := range symbol.Dependencies {\n+\t\t\tsymbol.Dependencies[i].Code = depMap[symbol.Dependencies[i].Name].Code\n+\t\t}\n+\n+\t\t// Set usage context for the symbol\n+\t\tsymbol.Context.Package = cf.extractPackageFromPath(fileDiff.NewPath)\n \t\tfileContext.AffectedSymbols = append(fileContext.AffectedSymbols, symbol)\n \t}\n \n@@ -296,27 +275,46 @@ func (cf *ContextManager) processModifiedFile(ctx context.Context, request Conte\n \t\t\tcontinue\n \t\t}\n \n-\t\t// Add caller information\n+\t\t// Add caller information to related files\n \t\tfor _, caller := range usageContext.Callers {\n-\t\t\trelatedFile := RelatedFile{\n+\t\t\tsymbol.Callers = append(symbol.Callers, Dependency{\n+\t\t\t\tName: caller.FunctionName,\n+\t\t\t\tLine: caller.LineNumber,\n+\t\t\t\tType: SymbolTypeFunction,\n+\t\t\t\tCode: lang.Check(caller.CodeSnippet, caller.Code),\n+\t\t\t})\n+\t\t\tfileContext.RelatedFiles = append(fileContext.RelatedFiles, RelatedFile{\n \t\t\t\tFilePath:         caller.FilePath,\n \t\t\t\tRelationship:     \"caller\",\n \t\t\t\tCodeSnippet:      caller.CodeSnippet,\n \t\t\t\tLine:             caller.LineNumber,\n \t\t\t\tRelevantFunction: caller.FunctionName,\n+\t\t\t})\n+\t\t}\n+\n+\t\tdepMap := make(map[string]Dependency)\n+\t\tfor _, dep := range usageContext.Dependencies {\n+\t\t\tdepMap[dep.SymbolName] = Dependency{\n+\t\t\t\tName: dep.SymbolName,\n+\t\t\t\tCode: dep.Code,\n \t\t\t}\n-\t\t\tfileContext.RelatedFiles = append(fileContext.RelatedFiles, relatedFile)\n \t\t}\n \n+\t\tfor i := range symbol.Dependencies {\n+\t\t\tsymbol.Dependencies[i].Code = depMap[symbol.Dependencies[i].Name].Code\n+\t\t}\n+\n+\t\t// Set usage context for the symbol\n+\t\tsymbol.Context.Package = cf.extractPackageFromPath(fileDiff.NewPath)\n+\n \t\t// Add dependency information\n \t\tfor _, dep := range usageContext.Dependencies {\n \t\t\tif dep.SourceFile == \"internal\" \u0026\u0026 dep.SymbolName != \"\" {\n-\t\t\t\trelatedFile := RelatedFile{\n+\t\t\t\tfileContext.RelatedFiles = append(fileContext.RelatedFiles, RelatedFile{\n \t\t\t\t\tFilePath:         dep.SourceFile,\n \t\t\t\t\tRelationship:     \"dependency\",\n \t\t\t\t\tRelevantFunction: dep.SymbolName,\n-\t\t\t\t}\n-\t\t\t\tfileContext.RelatedFiles = append(fileContext.RelatedFiles, relatedFile)\n+\t\t\t\t})\n \t\t\t}\n \t\t}\n \n@@ -326,40 +324,6 @@ func (cf *ContextManager) processModifiedFile(ctx context.Context, request Conte\n \treturn fileContext, nil\n }\n \n-// processConfigFile processes changes in configuration files\n-func (cf *ContextManager) processConfigFile(ctx context.Context, request ContextRequest, fileDiff *model.FileDiff, fileContext *FileContext) (*FileContext, error) {\n-\t// Extract changed configuration keys\n-\tchangedKeys := cf.extractChangedConfigKeys(fileDiff.Diff)\n-\n-\t// Find code that consumes this configuration\n-\tconsumers, err := cf.symbolAnalyzer.findConfigFileConsumers(ctx, request.ProjectID, request.MergeRequest.SHA, fileDiff.NewPath)\n-\tif err != nil {\n-\t\tcf.log.Warn(\"failed to find config file consumers\", \"error\", err, \"file\", fileDiff.NewPath)\n-\t}\n-\n-\t// Create config context\n-\tconfigContext := \u0026ConfigContext{\n-\t\tConfigType:       cf.detectConfigType(fileDiff.NewPath),\n-\t\tChangedKeys:      changedKeys,\n-\t\tConsumingCode:    make([]RelatedFile, 0),\n-\t\tImpactAssessment: cf.assessConfigImpact(changedKeys),\n-\t}\n-\n-\t// Add consuming code as related files\n-\tfor _, consumer := range consumers {\n-\t\trelatedFile := RelatedFile{\n-\t\t\tFilePath:     consumer,\n-\t\t\tRelationship: \"config_consumer\",\n-\t\t}\n-\t\tconfigContext.ConsumingCode = append(configContext.ConsumingCode, relatedFile)\n-\t\tfileContext.RelatedFiles = append(fileContext.RelatedFiles, relatedFile)\n-\t}\n-\n-\tfileContext.ConfigContext = configContext\n-\n-\treturn fileContext, nil\n-}\n-\n // Helper methods\n \n // extractContentFromDiff extracts file content from diff (for new files)\n@@ -376,13 +340,6 @@ func (cf *ContextManager) extractContentFromDiff(diff string) string {\n \treturn strings.Join(content, \"\\n\")\n }\n \n-// getBaseFileContent gets the file content from the base branch\n-func (cf *ContextManager) getBaseFileContent(ctx context.Context, request model.ReviewRequest, filePath string) (string, error) {\n-\t// This would ideally get the content from the base branch\n-\t// For now, we'll try to get it from the current SHA as a fallback\n-\treturn cf.provider.GetFileContent(ctx, request.ProjectID, filePath, request.MergeRequest.SHA)\n-}\n-\n // isConfigFile checks if a file is a configuration file\n func (cf *ContextManager) isConfigFile(filePath string) bool {\n \tconfigExtensions := []string{\".yaml\", \".yml\", \".json\", \".toml\", \".ini\", \".conf\", \".config\", \".env\"}\n@@ -408,121 +365,6 @@ func (cf *ContextManager) isConfigFile(filePath string) bool {\n \treturn false\n }\n \n-// extractChangedConfigKeys extracts configuration keys that were changed\n-func (cf *ContextManager) extractChangedConfigKeys(diff string) []string {\n-\tvar keys []string\n-\tlines := strings.Split(diff, \"\\n\")\n-\n-\tfor _, line := range lines {\n-\t\tif strings.HasPrefix(line, \"+\") || strings.HasPrefix(line, \"-\") {\n-\t\t\t// Simple key extraction (this could be enhanced with proper YAML/JSON parsing)\n-\t\t\tkey := cf.extractKeyFromConfigLine(line[1:]) // Remove +/- prefix\n-\t\t\tif key != \"\" {\n-\t\t\t\tkeys = append(keys, key)\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\treturn keys\n-}\n-\n-// extractKeyFromConfigLine extracts a configuration key from a config file line\n-func (cf *ContextManager) extractKeyFromConfigLine(line string) string {\n-\tline = strings.TrimSpace(line)\n-\n-\t// YAML style: key: value\n-\tif colonIndex := strings.Index(line, \":\"); colonIndex != -1 {\n-\t\tkey := strings.TrimSpace(line[:colonIndex])\n-\t\t// Remove any leading dashes (YAML list items)\n-\t\tkey = strings.TrimLeft(key, \"- \")\n-\t\treturn key\n-\t}\n-\n-\t// JSON style: \"key\": value\n-\tif strings.Contains(line, \"\\\":\") {\n-\t\tparts := strings.Split(line, \"\\\":\")\n-\t\tif len(parts) \u003e 0 {\n-\t\t\tkey := strings.Trim(parts[0], \"\\\"\")\n-\t\t\tkey = strings.TrimSpace(key)\n-\t\t\treturn key\n-\t\t}\n-\t}\n-\n-\treturn \"\"\n-}\n-\n-// detectConfigType detects the type of configuration file\n-func (cf *ContextManager) detectConfigType(filePath string) string {\n-\text := strings.ToLower(filepath.Ext(filePath))\n-\tfilename := strings.ToLower(filepath.Base(filePath))\n-\n-\tswitch ext {\n-\tcase \".yaml\", \".yml\":\n-\t\treturn \"yaml\"\n-\tcase \".json\":\n-\t\treturn \"json\"\n-\tcase \".toml\":\n-\t\treturn \"toml\"\n-\tcase \".ini\":\n-\t\treturn \"ini\"\n-\tcase \".env\":\n-\t\treturn \"env\"\n-\tdefault:\n-\t\t// Check specific filenames\n-\t\tif filename == \"makefile\" {\n-\t\t\treturn \"makefile\"\n-\t\t}\n-\t\tif filename == \"dockerfile\" {\n-\t\t\treturn \"dockerfile\"\n-\t\t}\n-\t\treturn \"unknown\"\n-\t}\n-}\n-\n-// assessConfigImpact provides an impact assessment for configuration changes\n-func (cf *ContextManager) assessConfigImpact(changedKeys []string) string {\n-\tif len(changedKeys) == 0 {\n-\t\treturn \"No configuration keys changed\"\n-\t}\n-\n-\t// Simple impact assessment based on key names\n-\thighImpactKeys := []string{\"database\", \"db\", \"password\", \"secret\", \"api_key\", \"token\", \"host\", \"port\", \"url\"}\n-\tmediumImpactKeys := []string{\"timeout\", \"retry\", \"cache\", \"log\", \"debug\", \"feature\", \"flag\"}\n-\n-\thighImpactCount := 0\n-\tmediumImpactCount := 0\n-\n-\tfor _, key := range changedKeys {\n-\t\tlowerKey := strings.ToLower(key)\n-\n-\t\tisHighImpact := false\n-\t\tfor _, highKey := range highImpactKeys {\n-\t\t\tif strings.Contains(lowerKey, highKey) {\n-\t\t\t\thighImpactCount++\n-\t\t\t\tisHighImpact = true\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t}\n-\n-\t\tif !isHighImpact {\n-\t\t\tfor _, mediumKey := range mediumImpactKeys {\n-\t\t\t\tif strings.Contains(lowerKey, mediumKey) {\n-\t\t\t\t\tmediumImpactCount++\n-\t\t\t\t\tbreak\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tif highImpactCount \u003e 0 {\n-\t\treturn fmt.Sprintf(\"High impact: %d critical configuration keys changed\", highImpactCount)\n-\t} else if mediumImpactCount \u003e 0 {\n-\t\treturn fmt.Sprintf(\"Medium impact: %d configuration keys changed\", mediumImpactCount)\n-\t} else {\n-\t\treturn fmt.Sprintf(\"Low impact: %d configuration keys changed\", len(changedKeys))\n-\t}\n-}\n-\n // extractPackageFromPath extracts package/module name from file path\n func (cf *ContextManager) extractPackageFromPath(filePath string) string {\n \tdir := filepath.Dir(filePath)",
      "affected_symbols": [
        {
          "symbol_name": "GatherFilesContext",
          "symbol_type": "method",
          "full_code": "func (cf *ContextManager) GatherFilesContext(ctx context.Context, request ContextRequest) ([]*FileContext, error) {\n\n\tfiles := make([]*FileContext, 0, len(request.FileDiffs))\n\t// Process each changed file\n\tfor _, fileDiff := range request.FileDiffs {\n\t\tfileContext, err := cf.processFileDiff(ctx, request, fileDiff)\n\t\tif err != nil {\n\t\t\tcf.log.Warn(\"failed to process file diff\", \"error\", err, \"file\", fileDiff.NewPath)\n\t\t\tcontinue\n\t\t}\n\n\t\tif fileContext != nil {\n\t\t\tfiles = append(files, fileContext)\n\t\t}\n\t}\n\n\treturn files, nil\n}",
          "doc_comment": "// GatherContext gathers comprehensive context for a merge request",
          "context": {
            "package": "astparser",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "cf.processFileDiff",
              "snippet": "cf.processFileDiff(ctx, request, fileDiff)",
              "line": 49,
              "type": "function",
              "source_file": "external",
              "source_code": "// cf.processFileDiff() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "cf.log.Warn",
              "snippet": "cf.log.Warn(\"failed to process file diff\", \"error\", err, \"file\", fileDiff.NewPath)",
              "line": 51,
              "type": "function",
              "source_file": "external",
              "source_code": "// cf.log.Warn() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/astparser/context_manager.go",
          "start_line": 44,
          "end_line": 61
        },
        {
          "symbol_name": "processFileDiff",
          "symbol_type": "method",
          "full_code": "func (cf *ContextManager) processFileDiff(ctx context.Context, request ContextRequest, fileDiff *model.FileDiff) (*FileContext, error) {\n\t// Create base file context\n\tfileContext := \u0026FileContext{\n\t\tFilePath:        fileDiff.NewPath,\n\t\tChangeType:      cf.determineChangeType(fileDiff),\n\t\tDiff:            fileDiff.Diff,\n\t\tAffectedSymbols: make([]AffectedSymbol, 0),\n\t\tRelatedFiles:    make([]RelatedFile, 0),\n\t}\n\n\tif cf.isConfigFile(fileDiff.NewPath) {\n\t\t// TODO: add config file processing\n\t\tcf.log.Warn(\"config file detected, skipping\", \"file\", fileDiff.NewPath)\n\t\treturn fileContext, nil\n\t}\n\n\t// Handle different change types\n\tswitch fileContext.ChangeType {\n\tcase ChangeTypeAdded:\n\t\treturn cf.processAddedFile(ctx, request, fileDiff, fileContext)\n\n\tcase ChangeTypeDeleted:\n\t\treturn cf.processDeletedFile(ctx, request, fileDiff, fileContext)\n\n\tcase ChangeTypeModified, ChangeTypeRenamed:\n\t\treturn cf.processModifiedFile(ctx, request, fileDiff, fileContext)\n\n\t}\n\n\treturn fileContext, nil\n}",
          "doc_comment": "// processFileDiff processes a single file diff to extract context",
          "context": {
            "package": "astparser",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "cf.determineChangeType",
              "snippet": "cf.determineChangeType(fileDiff)",
              "line": 68,
              "type": "function",
              "source_file": "external",
              "source_code": "// cf.determineChangeType() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "cf.isConfigFile",
              "snippet": "cf.isConfigFile(fileDiff.NewPath)",
              "line": 74,
              "type": "function",
              "source_file": "external",
              "source_code": "// cf.isConfigFile() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "cf.log.Warn",
              "snippet": "cf.log.Warn(\"config file detected, skipping\", \"file\", fileDiff.NewPath)",
              "line": 76,
              "type": "function",
              "source_file": "external",
              "source_code": "// cf.log.Warn() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "cf.processAddedFile",
              "snippet": "cf.processAddedFile(ctx, request, fileDiff, fileContext)",
              "line": 83,
              "type": "function",
              "source_file": "external",
              "source_code": "// cf.processAddedFile() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "cf.processDeletedFile",
              "snippet": "cf.processDeletedFile(ctx, request, fileDiff, fileContext)",
              "line": 86,
              "type": "function",
              "source_file": "external",
              "source_code": "// cf.processDeletedFile() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "cf.processModifiedFile",
              "snippet": "cf.processModifiedFile(ctx, request, fileDiff, fileContext)",
              "line": 89,
              "type": "function",
              "source_file": "external",
              "source_code": "// cf.processModifiedFile() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/astparser/context_manager.go",
          "start_line": 64,
          "end_line": 94
        },
        {
          "symbol_name": "processAddedFile",
          "symbol_type": "method",
          "full_code": "func (cf *ContextManager) processAddedFile(ctx context.Context, request ContextRequest, fileDiff *model.FileDiff, fileContext *FileContext) (*FileContext, error) {\n\t// For new files, the entire file is \"affected\"\n\t// Get the full file content\n\tvar content string\n\tfor _, file := range request.RepoDataHead.Files {\n\t\tif file.Path == fileDiff.NewPath {\n\t\t\tcontent = file.Content\n\t\t\tbreak\n\t\t}\n\t}\n\tif content == \"\" {\n\t\t// If we can't get the content, extract it from the diff\n\t\tcontent = cf.extractContentFromDiff(fileDiff.Diff)\n\t}\n\n\t// Find all symbols in the new file\n\tallSymbols, err := cf.astParser.FindAllSymbolsInFile(ctx, fileDiff.NewPath, content)\n\tif err != nil {\n\t\tcf.log.Warn(\"failed to find symbols in new file\", \"error\", err, \"file\", fileDiff.NewPath)\n\t\treturn fileContext, nil\n\t}\n\n\t// For each symbol, find if it's already being used\n\tfor _, symbol := range allSymbols {\n\t\t// Analyze usage context\n\t\tusageContext, err := cf.symbolAnalyzer.AnalyzeSymbolUsage(ctx, request.RepoDataHead, symbol)\n\t\tif err != nil {\n\t\t\tcf.log.Warn(\"failed to analyze symbol usage\", \"error\", err, \"symbol\", symbol.Name)\n\t\t\tcontinue\n\t\t}\n\n\t\t// Add caller information to related files\n\t\tfor _, caller := range usageContext.Callers {\n\t\t\tsymbol.Callers = append(symbol.Callers, Dependency{\n\t\t\t\tName: caller.FunctionName,\n\t\t\t\tLine: caller.LineNumber,\n\t\t\t\tType: SymbolTypeFunction,\n\t\t\t\tCode: lang.Check(caller.CodeSnippet, caller.Code),\n\t\t\t})\n\t\t\tfileContext.RelatedFiles = append(fileContext.RelatedFiles, RelatedFile{\n\t\t\t\tFilePath:         caller.FilePath,\n\t\t\t\tRelationship:     \"caller\",\n\t\t\t\tCodeSnippet:      caller.CodeSnippet,\n\t\t\t\tLine:             caller.LineNumber,\n\t\t\t\tRelevantFunction: caller.FunctionName,\n\t\t\t})\n\t\t}\n\n\t\tdepMap := make(map[string]Dependency)\n\t\tfor _, dep := range usageContext.Dependencies {\n\t\t\tdepMap[dep.SymbolName] = Dependency{\n\t\t\t\tName: dep.SymbolName,\n\t\t\t\tCode: dep.Code,\n\t\t\t}\n\t\t}\n\n\t\tfor i := range symbol.Dependencies {\n\t\t\tsymbol.Dependencies[i].Code = depMap[symbol.Dependencies[i].Name].Code\n\t\t}\n\n\t\t// Set usage context for the symbol\n\t\tsymbol.Context.Package = cf.extractPackageFromPath(fileDiff.NewPath)\n\t\tfileContext.AffectedSymbols = append(fileContext.AffectedSymbols, symbol)\n\t}\n\n\treturn fileContext, nil\n}",
          "doc_comment": "// processAddedFile processes a newly added file",
          "context": {
            "package": "astparser",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "cf.extractContentFromDiff",
              "snippet": "cf.extractContentFromDiff(fileDiff.Diff)",
              "line": 109,
              "type": "function",
              "source_file": "external",
              "source_code": "// cf.extractContentFromDiff() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "cf.astParser.FindAllSymbolsInFile",
              "snippet": "cf.astParser.FindAllSymbolsInFile(ctx, fileDiff.NewPath, content)",
              "line": 113,
              "type": "function",
              "source_file": "external",
              "source_code": "// cf.astParser.FindAllSymbolsInFile() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "cf.log.Warn",
              "snippet": "cf.log.Warn(\"failed to find symbols in new file\", \"error\", err, \"file\", fileDiff.NewPath)",
              "line": 115,
              "type": "function",
              "source_file": "external",
              "source_code": "// cf.log.Warn() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "cf.symbolAnalyzer.AnalyzeSymbolUsage",
              "snippet": "cf.symbolAnalyzer.AnalyzeSymbolUsage(ctx, request.RepoDataHead, symbol)",
              "line": 122,
              "type": "function",
              "source_file": "external",
              "source_code": "// cf.symbolAnalyzer.AnalyzeSymbolUsage() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "cf.log.Warn",
              "snippet": "cf.log.Warn(\"failed to analyze symbol usage\", \"error\", err, \"symbol\", symbol.Name)",
              "line": 124,
              "type": "function",
              "source_file": "external",
              "source_code": "// cf.log.Warn() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "lang.Check",
              "snippet": "lang.Check(caller.CodeSnippet, caller.Code)",
              "line": 134,
              "type": "function",
              "source_file": "external",
              "source_code": "// lang.Check() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "cf.extractPackageFromPath",
              "snippet": "cf.extractPackageFromPath(fileDiff.NewPath)",
              "line": 158,
              "type": "function",
              "source_file": "external",
              "source_code": "// cf.extractPackageFromPath() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/astparser/context_manager.go",
          "start_line": 97,
          "end_line": 163
        },
        {
          "symbol_name": "processDeletedFile",
          "symbol_type": "method",
          "full_code": "func (cf *ContextManager) processDeletedFile(ctx context.Context, request ContextRequest, fileDiff *model.FileDiff, fileContext *FileContext) (*FileContext, error) {\n\tfileDiff.OldPath = lang.Check(fileDiff.OldPath, fileDiff.NewPath)\n\n\t// For deleted files, we need to get the content from the base branch\n\tcontent := \"\"\n\tfor _, file := range request.RepoDataBase.Files {\n\t\tif file.Path == fileDiff.OldPath {\n\t\t\tcontent = file.Content\n\t\t\tbreak\n\t\t}\n\t}\n\tif content == \"\" {\n\t\tcf.log.Warn(\"failed to get base file content for deleted file\", \"file\", fileDiff.OldPath)\n\t\treturn fileContext, nil\n\t}\n\n\t// Find all symbols that were in the deleted file\n\tallSymbols, err := cf.astParser.FindAllSymbolsInFile(ctx, fileDiff.OldPath, content)\n\tif err != nil {\n\t\tcf.log.Warn(\"failed to find symbols in deleted file\", \"error\", err, \"file\", fileDiff.OldPath)\n\t\treturn fileContext, nil\n\t}\n\n\t// For each symbol, find where it's still being used (this indicates broken code)\n\tfor _, symbol := range allSymbols {\n\t\tusageContext, err := cf.symbolAnalyzer.AnalyzeSymbolUsage(ctx, request.RepoDataBase, symbol)\n\t\tif err != nil {\n\t\t\tcf.log.Warn(\"failed to analyze symbol usage for deleted symbol\", \"error\", err, \"symbol\", symbol.Name)\n\t\t\tcontinue\n\t\t}\n\n\t\t// Add caller information to related files\n\t\tfor _, caller := range usageContext.Callers {\n\t\t\tsymbol.Callers = append(symbol.Callers, Dependency{\n\t\t\t\tName: caller.FunctionName,\n\t\t\t\tLine: caller.LineNumber,\n\t\t\t\tType: SymbolTypeFunction,\n\t\t\t\tCode: lang.Check(caller.CodeSnippet, caller.Code),\n\t\t\t})\n\t\t\tfileContext.RelatedFiles = append(fileContext.RelatedFiles, RelatedFile{\n\t\t\t\tFilePath:         caller.FilePath,\n\t\t\t\tRelationship:     \"caller\",\n\t\t\t\tCodeSnippet:      caller.CodeSnippet,\n\t\t\t\tLine:             caller.LineNumber,\n\t\t\t\tRelevantFunction: caller.FunctionName,\n\t\t\t})\n\t\t}\n\n\t\tdepMap := make(map[string]Dependency)\n\t\tfor _, dep := range usageContext.Dependencies {\n\t\t\tdepMap[dep.SymbolName] = Dependency{\n\t\t\t\tName: dep.SymbolName,\n\t\t\t\tCode: dep.Code,\n\t\t\t}\n\t\t}\n\n\t\tfor i := range symbol.Dependencies {\n\t\t\tsymbol.Dependencies[i].Code = depMap[symbol.Dependencies[i].Name].Code\n\t\t}\n\n\t\t// Set usage context for the symbol\n\t\tsymbol.Context.Package = cf.extractPackageFromPath(fileDiff.NewPath)\n\t\tfileContext.AffectedSymbols = append(fileContext.AffectedSymbols, symbol)\n\t}\n\n\treturn fileContext, nil\n}",
          "doc_comment": "// processDeletedFile processes a deleted file",
          "context": {
            "package": "astparser",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "lang.Check",
              "snippet": "lang.Check(fileDiff.OldPath, fileDiff.NewPath)",
              "line": 167,
              "type": "function",
              "source_file": "external",
              "source_code": "// lang.Check() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "cf.log.Warn",
              "snippet": "cf.log.Warn(\"failed to get base file content for deleted file\", \"file\", fileDiff.OldPath)",
              "line": 178,
              "type": "function",
              "source_file": "external",
              "source_code": "// cf.log.Warn() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "cf.astParser.FindAllSymbolsInFile",
              "snippet": "cf.astParser.FindAllSymbolsInFile(ctx, fileDiff.OldPath, content)",
              "line": 183,
              "type": "function",
              "source_file": "external",
              "source_code": "// cf.astParser.FindAllSymbolsInFile() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "cf.log.Warn",
              "snippet": "cf.log.Warn(\"failed to find symbols in deleted file\", \"error\", err, \"file\", fileDiff.OldPath)",
              "line": 185,
              "type": "function",
              "source_file": "external",
              "source_code": "// cf.log.Warn() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "cf.symbolAnalyzer.AnalyzeSymbolUsage",
              "snippet": "cf.symbolAnalyzer.AnalyzeSymbolUsage(ctx, request.RepoDataBase, symbol)",
              "line": 191,
              "type": "function",
              "source_file": "external",
              "source_code": "// cf.symbolAnalyzer.AnalyzeSymbolUsage() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "cf.log.Warn",
              "snippet": "cf.log.Warn(\"failed to analyze symbol usage for deleted symbol\", \"error\", err, \"symbol\", symbol.Name)",
              "line": 193,
              "type": "function",
              "source_file": "external",
              "source_code": "// cf.log.Warn() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "lang.Check",
              "snippet": "lang.Check(caller.CodeSnippet, caller.Code)",
              "line": 203,
              "type": "function",
              "source_file": "external",
              "source_code": "// lang.Check() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "cf.extractPackageFromPath",
              "snippet": "cf.extractPackageFromPath(fileDiff.NewPath)",
              "line": 227,
              "type": "function",
              "source_file": "external",
              "source_code": "// cf.extractPackageFromPath() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/astparser/context_manager.go",
          "start_line": 166,
          "end_line": 232
        },
        {
          "symbol_name": "processModifiedFile",
          "symbol_type": "method",
          "full_code": "func (cf *ContextManager) processModifiedFile(ctx context.Context, request ContextRequest, fileDiff *model.FileDiff, fileContext *FileContext) (*FileContext, error) {\n\n\t// Parse the diff to get changed lines\n\tdiffLines, err := cf.diffParser.ParseDiffToLines(fileDiff.Diff)\n\tif err != nil {\n\t\treturn nil, errm.Wrap(err, \"failed to parse diff lines\")\n\t}\n\n\t// Extract line numbers for added and modified lines\n\tvar changedLines []int\n\tfor _, line := range diffLines {\n\t\tif line.Type == DiffAddedLine \u0026\u0026 line.NewLine \u003e 0 {\n\t\t\tchangedLines = append(changedLines, line.NewLine)\n\t\t}\n\t}\n\n\tif len(changedLines) == 0 {\n\t\treturn fileContext, nil\n\t}\n\n\t// Get the current file content (head version)\n\tcontent, err := cf.provider.GetFileContent(ctx, request.ProjectID, fileDiff.NewPath, request.MergeRequest.SHA)\n\tif err != nil {\n\t\treturn nil, errm.Wrap(err, \"failed to get current file content\")\n\t}\n\n\t// Find affected symbols\n\taffectedSymbols, err := cf.astParser.FindAffectedSymbols(ctx, fileDiff.NewPath, content, changedLines)\n\tif err != nil {\n\t\tcf.log.Warn(\"failed to find affected symbols, using fallback\", \"error\", err, \"file\", fileDiff.NewPath)\n\t\t// Continue without symbol analysis\n\t\treturn fileContext, nil\n\t}\n\n\t// For each affected symbol, gather comprehensive context\n\tfor _, symbol := range affectedSymbols {\n\t\t// Analyze symbol usage\n\t\tusageContext, err := cf.symbolAnalyzer.AnalyzeSymbolUsage(ctx, request.RepoDataHead, symbol)\n\t\tif err != nil {\n\t\t\tcf.log.Warn(\"failed to analyze symbol usage\", \"error\", err, \"symbol\", symbol.Name)\n\t\t\tcontinue\n\t\t}\n\n\t\t// Add caller information to related files\n\t\tfor _, caller := range usageContext.Callers {\n\t\t\tsymbol.Callers = append(symbol.Callers, Dependency{\n\t\t\t\tName: caller.FunctionName,\n\t\t\t\tLine: caller.LineNumber,\n\t\t\t\tType: SymbolTypeFunction,\n\t\t\t\tCode: lang.Check(caller.CodeSnippet, caller.Code),\n\t\t\t})\n\t\t\tfileContext.RelatedFiles = append(fileContext.RelatedFiles, RelatedFile{\n\t\t\t\tFilePath:         caller.FilePath,\n\t\t\t\tRelationship:     \"caller\",\n\t\t\t\tCodeSnippet:      caller.CodeSnippet,\n\t\t\t\tLine:             caller.LineNumber,\n\t\t\t\tRelevantFunction: caller.FunctionName,\n\t\t\t})\n\t\t}\n\n\t\tdepMap := make(map[string]Dependency)\n\t\tfor _, dep := range usageContext.Dependencies {\n\t\t\tdepMap[dep.SymbolName] = Dependency{\n\t\t\t\tName: dep.SymbolName,\n\t\t\t\tCode: dep.Code,\n\t\t\t}\n\t\t}\n\n\t\tfor i := range symbol.Dependencies {\n\t\t\tsymbol.Dependencies[i].Code = depMap[symbol.Dependencies[i].Name].Code\n\t\t}\n\n\t\t// Set usage context for the symbol\n\t\tsymbol.Context.Package = cf.extractPackageFromPath(fileDiff.NewPath)\n\n\t\t// Add dependency information\n\t\tfor _, dep := range usageContext.Dependencies {\n\t\t\tif dep.SourceFile == \"internal\" \u0026\u0026 dep.SymbolName != \"\" {\n\t\t\t\tfileContext.RelatedFiles = append(fileContext.RelatedFiles, RelatedFile{\n\t\t\t\t\tFilePath:         dep.SourceFile,\n\t\t\t\t\tRelationship:     \"dependency\",\n\t\t\t\t\tRelevantFunction: dep.SymbolName,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\tfileContext.AffectedSymbols = append(fileContext.AffectedSymbols, symbol)\n\t}\n\n\treturn fileContext, nil\n}",
          "doc_comment": "// processModifiedFile processes a modified file",
          "context": {
            "package": "astparser",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "cf.diffParser.ParseDiffToLines",
              "snippet": "cf.diffParser.ParseDiffToLines(fileDiff.Diff)",
              "line": 238,
              "type": "function",
              "source_file": "external",
              "source_code": "// cf.diffParser.ParseDiffToLines() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "errm.Wrap",
              "snippet": "errm.Wrap(err, \"failed to parse diff lines\")",
              "line": 240,
              "type": "function",
              "source_file": "external",
              "source_code": "// errm.Wrap() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "cf.provider.GetFileContent",
              "snippet": "cf.provider.GetFileContent(ctx, request.ProjectID, fileDiff.NewPath, request.MergeRequest.SHA)",
              "line": 256,
              "type": "function",
              "source_file": "external",
              "source_code": "// cf.provider.GetFileContent() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "errm.Wrap",
              "snippet": "errm.Wrap(err, \"failed to get current file content\")",
              "line": 258,
              "type": "function",
              "source_file": "external",
              "source_code": "// errm.Wrap() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "cf.astParser.FindAffectedSymbols",
              "snippet": "cf.astParser.FindAffectedSymbols(ctx, fileDiff.NewPath, content, changedLines)",
              "line": 262,
              "type": "function",
              "source_file": "external",
              "source_code": "// cf.astParser.FindAffectedSymbols() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "cf.log.Warn",
              "snippet": "cf.log.Warn(\"failed to find affected symbols, using fallback\", \"error\", err, \"file\", fileDiff.NewPath)",
              "line": 264,
              "type": "function",
              "source_file": "external",
              "source_code": "// cf.log.Warn() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "cf.symbolAnalyzer.AnalyzeSymbolUsage",
              "snippet": "cf.symbolAnalyzer.AnalyzeSymbolUsage(ctx, request.RepoDataHead, symbol)",
              "line": 272,
              "type": "function",
              "source_file": "external",
              "source_code": "// cf.symbolAnalyzer.AnalyzeSymbolUsage() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "cf.log.Warn",
              "snippet": "cf.log.Warn(\"failed to analyze symbol usage\", \"error\", err, \"symbol\", symbol.Name)",
              "line": 274,
              "type": "function",
              "source_file": "external",
              "source_code": "// cf.log.Warn() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "lang.Check",
              "snippet": "lang.Check(caller.CodeSnippet, caller.Code)",
              "line": 284,
              "type": "function",
              "source_file": "external",
              "source_code": "// lang.Check() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "cf.extractPackageFromPath",
              "snippet": "cf.extractPackageFromPath(fileDiff.NewPath)",
              "line": 308,
              "type": "function",
              "source_file": "external",
              "source_code": "// cf.extractPackageFromPath() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/astparser/context_manager.go",
          "start_line": 235,
          "end_line": 325
        }
      ],
      "related_files": []
    },
    {
      "file_path": "internal/reviewer/astparser/diff_parser.go",
      "change_type": "Modified",
      "diff": "@@ -988,7 +988,7 @@ func (dp *DiffParser) CreateLineToSymbolMap(filePath, content string, astParser\n \tlineToSymbols := make(map[int][]AffectedSymbol)\n \n \t// Parse file to get all symbols\n-\trootNode, err := astParser.ParseFileToAST(context.Background(), filePath, content)\n+\trootNode, err := astParser.GetFileAST(context.Background(), filePath, content)\n \tif err != nil {\n \t\treturn nil, err\n \t}",
      "affected_symbols": [
        {
          "symbol_name": "CreateLineToSymbolMap",
          "symbol_type": "method",
          "full_code": "func (dp *DiffParser) CreateLineToSymbolMap(filePath, content string, astParser *Parser) (map[int][]AffectedSymbol, error) {\n\tif astParser == nil {\n\t\treturn nil, fmt.Errorf(\"AST parser required\")\n\t}\n\n\tlineToSymbols := make(map[int][]AffectedSymbol)\n\n\t// Parse file to get all symbols\n\trootNode, err := astParser.GetFileAST(context.Background(), filePath, content)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Walk the AST to find all symbols and their line ranges\n\tdp.walkASTToMapLines(rootNode, filePath, content, astParser, lineToSymbols)\n\n\treturn lineToSymbols, nil\n}",
          "doc_comment": "// Line-to-Symbol mapping utilities\n// CreateLineToSymbolMap creates a mapping from line numbers to symbols in a file",
          "context": {
            "package": "astparser",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "astParser.GetFileAST",
              "snippet": "astParser.GetFileAST(context.Background(), filePath, content)",
              "line": 991,
              "type": "function",
              "source_file": "external",
              "source_code": "// astParser.GetFileAST() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "context.Background",
              "snippet": "context.Background()",
              "line": 991,
              "type": "function",
              "source_file": "external",
              "source_code": "// context.Background() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "dp.walkASTToMapLines",
              "snippet": "dp.walkASTToMapLines(rootNode, filePath, content, astParser, lineToSymbols)",
              "line": 997,
              "type": "function",
              "source_file": "external",
              "source_code": "// dp.walkASTToMapLines() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/astparser/diff_parser.go",
          "start_line": 983,
          "end_line": 1000
        }
      ],
      "related_files": []
    },
    {
      "file_path": "internal/reviewer/astparser/languages.go",
      "change_type": "Modified",
      "diff": "@@ -318,36 +318,97 @@ var symbolNodes = map[string]bool{\n \t\"struct_type\":          true,\n \t\"func_literal\":         true,\n \t\"method_spec\":          true,\n+\t\"function_spec\":        true,\n \n \t// JavaScript/TypeScript\n \t\"function_expression\":    true,\n \t\"arrow_function\":         true,\n \t\"method_definition\":      true,\n-\t\"class_declaration\":      true,\n \t\"variable_declaration\":   true,\n \t\"variable_declarator\":    true,\n-\t\"interface_declaration\":  true,\n \t\"type_alias_declaration\": true,\n-\t\"enum_declaration\":       true,\n \t\"namespace_declaration\":  true,\n \t\"module_declaration\":     true,\n \t\"export_statement\":       true,\n \t\"import_statement\":       true,\n \t\"lexical_declaration\":    true,\n \n \t// Python\n-\t\"function_def\":     true, // function_definition\n-\t\"class_definition\": true,\n+\t\"function_definition\":  true,\n+\t\"async_function_def\":   true,\n+\t\"decorated_definition\": true,\n \n \t// Java\n \t\"constructor_declaration\":    true,\n \t\"local_variable_declaration\": true,\n+\t\"field_declaration\":          true,\n \n \t// C/C++\n-\t\"function_definition\":                   true,\n \t\"constructor_or_destructor_declaration\": true,\n \t\"struct_specifier\":                      true,\n \t\"union_specifier\":                       true,\n \t\"enum_specifier\":                        true,\n-\t\"class_specifier\":                       true,\n+\t\"function_declarator\":                   true,\n+\t\"declaration\":                           true,\n+\n+\t// C#\n+\t\"property_declaration\": true,\n+\t\"struct_declaration\":   true,\n+\n+\t// Ruby\n+\t\"method\":            true,\n+\t\"module\":            true,\n+\t\"def\":               true,\n+\t\"class_definition\":  true,\n+\t\"module_definition\": true,\n+\n+\t// Rust\n+\t\"function_item\": true,\n+\t\"struct_item\":   true,\n+\t\"enum_item\":     true,\n+\t\"trait_item\":    true,\n+\t\"impl_item\":     true,\n+\t\"mod_item\":      true,\n+\t\"const_item\":    true,\n+\t\"static_item\":   true,\n+\n+\t// Swift\n+\t\"enum_declaration\":     true,\n+\t\"protocol_declaration\": true,\n+\t\"constant_declaration\": true,\n+\n+\t// Kotlin\n+\t\"object_declaration\": true,\n+\n+\t// Scala\n+\t\"object_definition\": true,\n+\t\"trait_definition\":  true,\n+\t\"val_definition\":    true,\n+\t\"var_definition\":    true,\n+\n+\t// Elixir\n+\t\"function\":    true,\n+\t\"defp\":        true,\n+\t\"defmodule\":   true,\n+\t\"defstruct\":   true,\n+\t\"defprotocol\": true,\n+\n+\t// Lua\n+\t\"function_statement\":       true,\n+\t\"local_function_statement\": true,\n+\t\"local_statement\":          true,\n+\n+\t// OCaml\n+\t\"value_definition\":     true,\n+\t\"type_definition\":      true,\n+\t\"exception_definition\": true,\n+\n+\t// Svelte\n+\t\"script\":    true,\n+\t\"component\": true,\n+\n+\t// Generic patterns that might be missed\n+\t\"definition\":    true,\n+\t\"specification\": true,\n+\t\"declarator\":    true,\n }",
      "affected_symbols": [
        {
          "symbol_name": "symbolNodes",
          "symbol_type": "variable",
          "full_code": "var symbolNodes = map[string]bool{\n\t// Go\n\t\"function_declaration\": true,\n\t\"method_declaration\":   true,\n\t\"type_declaration\":     true,\n\t\"type_spec\":            true,\n\t\"var_declaration\":      true,\n\t\"var_spec\":             true,\n\t\"const_declaration\":    true,\n\t\"const_spec\":           true,\n\t\"interface_type\":       true,\n\t\"struct_type\":          true,\n\t\"func_literal\":         true,\n\t\"method_spec\":          true,\n\t\"function_spec\":        true,\n\n\t// JavaScript/TypeScript\n\t\"function_expression\":    true,\n\t\"arrow_function\":         true,\n\t\"method_definition\":      true,\n\t\"variable_declaration\":   true,\n\t\"variable_declarator\":    true,\n\t\"type_alias_declaration\": true,\n\t\"namespace_declaration\":  true,\n\t\"module_declaration\":     true,\n\t\"export_statement\":       true,\n\t\"import_statement\":       true,\n\t\"lexical_declaration\":    true,\n\n\t// Python\n\t\"function_definition\":  true,\n\t\"async_function_def\":   true,\n\t\"decorated_definition\": true,\n\n\t// Java\n\t\"constructor_declaration\":    true,\n\t\"local_variable_declaration\": true,\n\t\"field_declaration\":          true,\n\n\t// C/C++\n\t\"constructor_or_destructor_declaration\": true,\n\t\"struct_specifier\":                      true,\n\t\"union_specifier\":                       true,\n\t\"enum_specifier\":                        true,\n\t\"function_declarator\":                   true,\n\t\"declaration\":                           true,\n\n\t// C#\n\t\"property_declaration\": true,\n\t\"struct_declaration\":   true,\n\n\t// Ruby\n\t\"method\":            true,\n\t\"module\":            true,\n\t\"def\":               true,\n\t\"class_definition\":  true,\n\t\"module_definition\": true,\n\n\t// Rust\n\t\"function_item\": true,\n\t\"struct_item\":   true,\n\t\"enum_item\":     true,\n\t\"trait_item\":    true,\n\t\"impl_item\":     true,\n\t\"mod_item\":      true,\n\t\"const_item\":    true,\n\t\"static_item\":   true,\n\n\t// Swift\n\t\"enum_declaration\":     true,\n\t\"protocol_declaration\": true,\n\t\"constant_declaration\": true,\n\n\t// Kotlin\n\t\"object_declaration\": true,\n\n\t// Scala\n\t\"object_definition\": true,\n\t\"trait_definition\":  true,\n\t\"val_definition\":    true,\n\t\"var_definition\":    true,\n\n\t// Elixir\n\t\"function\":    true,\n\t\"defp\":        true,\n\t\"defmodule\":   true,\n\t\"defstruct\":   true,\n\t\"defprotocol\": true,\n\n\t// Lua\n\t\"function_statement\":       true,\n\t\"local_function_statement\": true,\n\t\"local_statement\":          true,\n\n\t// OCaml\n\t\"value_definition\":     true,\n\t\"type_definition\":      true,\n\t\"exception_definition\": true,\n\n\t// Svelte\n\t\"script\":    true,\n\t\"component\": true,\n\n\t// Generic patterns that might be missed\n\t\"definition\":    true,\n\t\"specification\": true,\n\t\"declarator\":    true,\n}",
          "doc_comment": "",
          "context": {
            "package": "astparser",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": null,
          "file_path": "internal/reviewer/astparser/languages.go",
          "start_line": 307,
          "end_line": 414
        }
      ],
      "related_files": []
    },
    {
      "file_path": "internal/reviewer/astparser/parser.go",
      "change_type": "Modified",
      "diff": "@@ -5,15 +5,11 @@ import (\n \t\"maps\"\n \t\"strings\"\n \n+\t\"github.com/maxbolgarin/abstract\"\n \t\"github.com/maxbolgarin/errm\"\n \tsitter \"github.com/smacker/go-tree-sitter\"\n )\n \n-// Parser handles parsing code using Tree-sitter to map lines to syntax nodes\n-type Parser struct {\n-\tlanguages map[ProgrammingLanguage]*sitter.Language\n-}\n-\n // SymbolType represents the type of a code symbol\n type SymbolType string\n \n@@ -62,6 +58,7 @@ type Dependency struct {\n \tSnippet string     `json:\"snippet\"`\n \tLine    int        `json:\"line\"`\n \tType    SymbolType `json:\"type\"`\n+\tCode    string     `json:\"code\"`\n }\n \n // NodePosition represents a position in the source code\n@@ -72,17 +69,29 @@ type NodePosition struct {\n \tEndColumn   int\n }\n \n+// Parser handles parsing code using Tree-sitter to map lines to syntax nodes\n+type Parser struct {\n+\tlanguages map[ProgrammingLanguage]*sitter.Language\n+\n+\tastCache *abstract.SafeMap[string, *sitter.Node]\n+}\n+\n // NewParser creates a new AST parser with supported languages\n func NewParser() *Parser {\n \tlanguages := make(map[ProgrammingLanguage]*sitter.Language, len(languagesParsers))\n \tmaps.Copy(languages, languagesParsers)\n \treturn \u0026Parser{\n \t\tlanguages: languages,\n+\t\tastCache:  abstract.NewSafeMap[string, *sitter.Node](),\n \t}\n }\n \n // ParseFileToAST parses a file's content to AST using Tree-sitter\n-func (p *Parser) ParseFileToAST(ctx context.Context, filePath, content string) (*sitter.Node, error) {\n+func (p *Parser) GetFileAST(ctx context.Context, filePath, content string) (*sitter.Node, error) {\n+\tif node, ok := p.astCache.Lookup(filePath); ok {\n+\t\treturn node, nil\n+\t}\n+\n \tlanguage := DetectProgrammingLanguage(filePath)\n \tlanguageParser, ok := p.languages[language]\n \tif !ok {\n@@ -97,6 +106,8 @@ func (p *Parser) ParseFileToAST(ctx context.Context, filePath, content string) (\n \t\treturn nil, errm.Wrap(err, \"failed to parse AST\", \"file\", filePath)\n \t}\n \n+\tp.astCache.Set(filePath, tree.RootNode())\n+\n \treturn tree.RootNode(), nil\n }\n \n@@ -138,7 +149,7 @@ func (p *Parser) findSmallestEnclosingNodeRecursive(node *sitter.Node, lineNumbe\n \n // FindAffectedSymbols finds all symbols affected by changes in the given lines\n func (p *Parser) FindAffectedSymbols(ctx context.Context, filePath, fileContent string, changedLines []int) ([]AffectedSymbol, error) {\n-\trootNode, err := p.ParseFileToAST(ctx, filePath, fileContent)\n+\trootNode, err := p.GetFileAST(ctx, filePath, fileContent)\n \tif err != nil {\n \t\treturn nil, errm.Wrap(err, \"failed to parse file to AST\", \"file\", filePath)\n \t}\n@@ -204,7 +215,7 @@ func (p *Parser) ExtractSymbolFromNode(node *sitter.Node, filePath, fileContent\n \t\tFilePath:  filePath,\n \t\tStartLine: int(node.StartPoint().Row) + 1, // Convert to 1-based\n \t\tEndLine:   int(node.EndPoint().Row) + 1,   // Convert to 1-based\n-\t\tName:      p.extractSymbolName(node, fileContent),\n+\t\tName:      p.extractSymbolName(node, fileContent, filePath),\n \t\tType:      getSymbolType(node.Type()),\n \t}\n \tsymbol.DocComment = p.extractDocComment(node, fileContent, symbol.StartLine)\n@@ -221,19 +232,215 @@ func (p *Parser) ExtractSymbolFromNode(node *sitter.Node, filePath, fileContent\n }\n \n // extractSymbolName extracts the symbol name from a symbol declaration node\n-func (p *Parser) extractSymbolName(node *sitter.Node, content string) string {\n+func (p *Parser) extractSymbolName(node *sitter.Node, content string, filePath string) string {\n \tchildCount := int(node.ChildCount())\n+\n+\t// First, try to find a direct identifier child\n \tfor i := 0; i \u003c childCount; i++ {\n \t\tchild := node.Child(i)\n \t\tif child == nil {\n \t\t\tcontinue\n \t\t}\n \n \t\tchildType := child.Type()\n-\t\tif strings.Contains(childType, \"identifier\") {\n-\t\t\treturn p.getNodeText(child, content)\n+\t\tif strings.Contains(childType, \"identifier\") ||\n+\t\t\tstrings.Contains(childType, \"name\") ||\n+\t\t\tstrings.Contains(childType, \"variable_name\") ||\n+\t\t\tstrings.Contains(childType, \"function_name\") ||\n+\t\t\tstrings.Contains(childType, \"class_name\") ||\n+\t\t\tstrings.Contains(childType, \"method_name\") {\n+\t\t\tname := p.getNodeText(child, content)\n+\t\t\tif name != \"\" {\n+\t\t\t\treturn name\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// For languages with different patterns, try alternative approaches\n+\tlanguage := DetectProgrammingLanguage(filePath)\n+\tswitch language {\n+\tcase LanguageGo:\n+\t\treturn p.extractGoSymbolName(node, content)\n+\tcase LanguageJavaScript, LanguageTypeScript, LanguageTSX:\n+\t\treturn p.extractJSSymbolName(node, content)\n+\tcase LanguagePython:\n+\t\treturn p.extractPythonSymbolName(node, content)\n+\tcase LanguageJava:\n+\t\treturn p.extractJavaSymbolName(node, content)\n+\tcase LanguageCpp:\n+\t\treturn p.extractCppSymbolName(node, content)\n+\t}\n+\n+\t// Fallback: look for any identifier in the node\n+\treturn p.findFirstIdentifier(node, content)\n+}\n+\n+// extractGoSymbolName extracts symbol names from Go AST nodes\n+func (p *Parser) extractGoSymbolName(node *sitter.Node, content string) string {\n+\tnodeType := node.Type()\n+\n+\tswitch nodeType {\n+\tcase \"function_declaration\", \"method_declaration\":\n+\t\t// Look for the function name in the function spec\n+\t\tfor i := 0; i \u003c int(node.ChildCount()); i++ {\n+\t\t\tchild := node.Child(i)\n+\t\t\tif child != nil \u0026\u0026 child.Type() == \"function_spec\" {\n+\t\t\t\treturn p.extractGoSymbolName(child, content)\n+\t\t\t}\n+\t\t}\n+\tcase \"function_spec\":\n+\t\t// Function name is usually the first identifier\n+\t\tfor i := 0; i \u003c int(node.ChildCount()); i++ {\n+\t\t\tchild := node.Child(i)\n+\t\t\tif child != nil \u0026\u0026 strings.Contains(child.Type(), \"identifier\") {\n+\t\t\t\treturn p.getNodeText(child, content)\n+\t\t\t}\n+\t\t}\n+\tcase \"type_declaration\", \"var_declaration\", \"const_declaration\":\n+\t\t// Look for the type/var/const spec\n+\t\tfor i := 0; i \u003c int(node.ChildCount()); i++ {\n+\t\t\tchild := node.Child(i)\n+\t\t\tif child != nil \u0026\u0026 (strings.Contains(child.Type(), \"spec\") || strings.Contains(child.Type(), \"declaration\")) {\n+\t\t\t\treturn p.extractGoSymbolName(child, content)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn p.findFirstIdentifier(node, content)\n+}\n+\n+// extractJSSymbolName extracts symbol names from JavaScript/TypeScript AST nodes\n+func (p *Parser) extractJSSymbolName(node *sitter.Node, content string) string {\n+\tnodeType := node.Type()\n+\n+\tswitch nodeType {\n+\tcase \"function_declaration\", \"function_expression\", \"arrow_function\":\n+\t\t// Look for the function name\n+\t\tfor i := 0; i \u003c int(node.ChildCount()); i++ {\n+\t\t\tchild := node.Child(i)\n+\t\t\tif child != nil \u0026\u0026 child.Type() == \"identifier\" {\n+\t\t\t\treturn p.getNodeText(child, content)\n+\t\t\t}\n+\t\t}\n+\tcase \"class_declaration\":\n+\t\t// Look for the class name\n+\t\tfor i := 0; i \u003c int(node.ChildCount()); i++ {\n+\t\t\tchild := node.Child(i)\n+\t\t\tif child != nil \u0026\u0026 child.Type() == \"identifier\" {\n+\t\t\t\treturn p.getNodeText(child, content)\n+\t\t\t}\n+\t\t}\n+\tcase \"variable_declarator\":\n+\t\t// Look for the variable name\n+\t\tfor i := 0; i \u003c int(node.ChildCount()); i++ {\n+\t\t\tchild := node.Child(i)\n+\t\t\tif child != nil \u0026\u0026 child.Type() == \"identifier\" {\n+\t\t\t\treturn p.getNodeText(child, content)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn p.findFirstIdentifier(node, content)\n+}\n+\n+// extractPythonSymbolName extracts symbol names from Python AST nodes\n+func (p *Parser) extractPythonSymbolName(node *sitter.Node, content string) string {\n+\tnodeType := node.Type()\n+\n+\tswitch nodeType {\n+\tcase \"function_definition\":\n+\t\t// Look for the function name\n+\t\tfor i := 0; i \u003c int(node.ChildCount()); i++ {\n+\t\t\tchild := node.Child(i)\n+\t\t\tif child != nil \u0026\u0026 child.Type() == \"identifier\" {\n+\t\t\t\treturn p.getNodeText(child, content)\n+\t\t\t}\n+\t\t}\n+\tcase \"class_definition\":\n+\t\t// Look for the class name\n+\t\tfor i := 0; i \u003c int(node.ChildCount()); i++ {\n+\t\t\tchild := node.Child(i)\n+\t\t\tif child != nil \u0026\u0026 child.Type() == \"identifier\" {\n+\t\t\t\treturn p.getNodeText(child, content)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn p.findFirstIdentifier(node, content)\n+}\n+\n+// extractJavaSymbolName extracts symbol names from Java AST nodes\n+func (p *Parser) extractJavaSymbolName(node *sitter.Node, content string) string {\n+\tnodeType := node.Type()\n+\n+\tswitch nodeType {\n+\tcase \"method_declaration\", \"constructor_declaration\":\n+\t\t// Look for the method/constructor name\n+\t\tfor i := 0; i \u003c int(node.ChildCount()); i++ {\n+\t\t\tchild := node.Child(i)\n+\t\t\tif child != nil \u0026\u0026 child.Type() == \"identifier\" {\n+\t\t\t\treturn p.getNodeText(child, content)\n+\t\t\t}\n+\t\t}\n+\tcase \"class_declaration\", \"interface_declaration\":\n+\t\t// Look for the class/interface name\n+\t\tfor i := 0; i \u003c int(node.ChildCount()); i++ {\n+\t\t\tchild := node.Child(i)\n+\t\t\tif child != nil \u0026\u0026 child.Type() == \"identifier\" {\n+\t\t\t\treturn p.getNodeText(child, content)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn p.findFirstIdentifier(node, content)\n+}\n+\n+// extractCppSymbolName extracts symbol names from C++ AST nodes\n+func (p *Parser) extractCppSymbolName(node *sitter.Node, content string) string {\n+\tnodeType := node.Type()\n+\n+\tswitch nodeType {\n+\tcase \"function_definition\", \"function_declarator\":\n+\t\t// Look for the function name\n+\t\tfor i := 0; i \u003c int(node.ChildCount()); i++ {\n+\t\t\tchild := node.Child(i)\n+\t\t\tif child != nil \u0026\u0026 child.Type() == \"identifier\" {\n+\t\t\t\treturn p.getNodeText(child, content)\n+\t\t\t}\n+\t\t}\n+\tcase \"class_specifier\", \"struct_specifier\":\n+\t\t// Look for the class/struct name\n+\t\tfor i := 0; i \u003c int(node.ChildCount()); i++ {\n+\t\t\tchild := node.Child(i)\n+\t\t\tif child != nil \u0026\u0026 child.Type() == \"identifier\" {\n+\t\t\t\treturn p.getNodeText(child, content)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn p.findFirstIdentifier(node, content)\n+}\n+\n+// findFirstIdentifier finds the first identifier in a node tree\n+func (p *Parser) findFirstIdentifier(node *sitter.Node, content string) string {\n+\tif node == nil {\n+\t\treturn \"\"\n+\t}\n+\n+\tif strings.Contains(node.Type(), \"identifier\") {\n+\t\treturn p.getNodeText(node, content)\n+\t}\n+\n+\tchildCount := int(node.ChildCount())\n+\tfor i := 0; i \u003c childCount; i++ {\n+\t\tchild := node.Child(i)\n+\t\tif child != nil {\n+\t\t\tif result := p.findFirstIdentifier(child, content); result != \"\" {\n+\t\t\t\treturn result\n+\t\t\t}\n \t\t}\n \t}\n+\n \treturn \"\"\n }\n \n@@ -271,7 +478,107 @@ func (p *Parser) extractDependencies(node *sitter.Node, content string, isRootFu\n \n \tp.walkNodeForDependencies(node, content, \u0026dependencies, isRootFunction, true)\n \n-\treturn dependencies\n+\t// Filter out standard library calls and basic operations\n+\treturn p.filterDependencies(dependencies)\n+}\n+\n+// filterDependencies filters out standard library calls and basic operations\n+func (p *Parser) filterDependencies(dependencies []Dependency) []Dependency {\n+\tvar filtered []Dependency\n+\n+\tfor _, dep := range dependencies {\n+\t\tif p.shouldIncludeDependency(dep) {\n+\t\t\tfiltered = append(filtered, dep)\n+\t\t}\n+\t}\n+\n+\treturn filtered\n+}\n+\n+// shouldIncludeDependency determines if a dependency should be included\n+func (p *Parser) shouldIncludeDependency(dep Dependency) bool {\n+\t// Skip empty names\n+\tif dep.Name == \"\" {\n+\t\treturn false\n+\t}\n+\n+\t// Skip standard library calls\n+\tif p.isStandardLibraryCall(dep.Name) {\n+\t\treturn false\n+\t}\n+\n+\t// Skip basic operations and common patterns\n+\tif p.isBasicOperation(dep.Name) {\n+\t\treturn false\n+\t}\n+\n+\t// Skip self-references and common patterns\n+\tif p.isSelfReference(dep.Name) {\n+\t\treturn false\n+\t}\n+\n+\treturn true\n+}\n+\n+// isStandardLibraryCall checks if a call is to a standard library function\n+func (p *Parser) isStandardLibraryCall(name string) bool {\n+\t// Common standard library patterns\n+\tstdLibPatterns := []string{\n+\t\t\"std::\", \"java.\", \"System.\", \"String.\", \"Integer.\", \"List.\", \"Map.\", \"Set.\",\n+\t\t\"os.\", \"sys.\", \"json.\", \"time.\", \"datetime.\", \"re.\", \"collections.\",\n+\t\t\"fmt.\", \"strings.\", \"strconv.\", \"io.\", \"net.\", \"http.\", \"encoding.\",\n+\t\t\"console.\", \"Math.\", \"Array.\", \"Object.\", \"JSON.\", \"Date.\",\n+\t\t\"print\", \"println\", \"printf\", \"sprintf\", \"fprintf\",\n+\t\t\"len\", \"cap\", \"make\", \"new\", \"append\", \"copy\",\n+\t\t\"len\", \"str\", \"int\", \"float\", \"bool\", \"list\", \"dict\", \"set\",\n+\t\t\"toString\", \"equals\", \"hashCode\", \"compareTo\",\n+\t\t\"substring\", \"indexOf\", \"contains\", \"startsWith\", \"endsWith\",\n+\t\t\"toLowerCase\", \"toUpperCase\", \"trim\", \"split\", \"join\",\n+\t\t\"push\", \"pop\", \"shift\", \"unshift\", \"slice\", \"splice\",\n+\t\t\"add\", \"remove\", \"get\", \"set\", \"put\", \"getOrDefault\",\n+\t}\n+\n+\tfor _, pattern := range stdLibPatterns {\n+\t\tif strings.Contains(name, pattern) {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\n+\treturn false\n+}\n+\n+// isBasicOperation checks if a call is a basic operation\n+func (p *Parser) isBasicOperation(name string) bool {\n+\tbasicOps := []string{\n+\t\t\"+\", \"-\", \"*\", \"/\", \"%\", \"=\", \"==\", \"!=\", \"\u003c\", \"\u003e\", \"\u003c=\", \"\u003e=\",\n+\t\t\"\u0026\u0026\", \"||\", \"!\", \"\u0026\", \"|\", \"^\", \"\u003c\u003c\", \"\u003e\u003e\",\n+\t\t\"++\", \"--\", \"+=\", \"-=\", \"*=\", \"/=\", \"%=\",\n+\t\t\"-\u003e\", \".\", \"::\", \"[]\", \"()\", \"{}\",\n+\t}\n+\n+\tfor _, op := range basicOps {\n+\t\tif name == op {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\n+\treturn false\n+}\n+\n+// isSelfReference checks if a call is a self-reference\n+func (p *Parser) isSelfReference(name string) bool {\n+\tselfRefs := []string{\n+\t\t\"this\", \"self\", \"super\", \"base\", \"me\", \"current\",\n+\t\t\"this.\", \"self.\", \"super.\", \"base.\", \"me.\", \"current.\",\n+\t}\n+\n+\tfor _, ref := range selfRefs {\n+\t\tif strings.Contains(name, ref) {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\n+\treturn false\n }\n \n // walkNodeForDependencies recursively walks the AST to find function calls\n@@ -281,14 +588,15 @@ func (p *Parser) walkNodeForDependencies(node *sitter.Node, content string, depe\n \t// Check if this node represents a function call\n \tif strings.Contains(nodeType, \"call\") {\n \t\tcall := p.extractDependency(node, content)\n-\t\tif call.Name != \"\" {\n+\t\tif call.Name != \"\" \u0026\u0026 p.isSignificantCall(call.Name) {\n \t\t\t*dependencies = append(*dependencies, call)\n \t\t}\n \t}\n \n+\t// Only include declarations/definitions if they're not the root function\n \tif !isRootFunction \u0026\u0026 !isFirstNode \u0026\u0026 (strings.Contains(nodeType, \"declaration\") || strings.Contains(nodeType, \"definition\")) {\n \t\tdeclaration := p.extractDependency(node, content)\n-\t\tif declaration.Name != \"\" {\n+\t\tif declaration.Name != \"\" \u0026\u0026 p.isSignificantDeclaration(declaration.Name) {\n \t\t\t*dependencies = append(*dependencies, declaration)\n \t\t}\n \t}\n@@ -303,6 +611,53 @@ func (p *Parser) walkNodeForDependencies(node *sitter.Node, content string, depe\n \t}\n }\n \n+// isSignificantCall determines if a function call is significant enough to include\n+func (p *Parser) isSignificantCall(name string) bool {\n+\t// Skip very short names (likely operators or basic operations)\n+\tif len(name) \u003c= 2 {\n+\t\treturn false\n+\t}\n+\n+\t// Skip common patterns that are not meaningful dependencies\n+\tskipPatterns := []string{\n+\t\t\"get\", \"set\", \"add\", \"remove\", \"find\", \"create\", \"update\", \"delete\",\n+\t\t\"toString\", \"equals\", \"hashCode\", \"clone\", \"copy\", \"clear\",\n+\t\t\"size\", \"length\", \"count\", \"empty\", \"isEmpty\", \"hasNext\",\n+\t\t\"next\", \"previous\", \"first\", \"last\", \"begin\", \"end\",\n+\t}\n+\n+\tfor _, pattern := range skipPatterns {\n+\t\tif strings.EqualFold(name, pattern) {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\n+\treturn true\n+}\n+\n+// isSignificantDeclaration determines if a declaration is significant enough to include\n+func (p *Parser) isSignificantDeclaration(name string) bool {\n+\t// Skip very short names\n+\tif len(name) \u003c= 2 {\n+\t\treturn false\n+\t}\n+\n+\t// Skip common variable names that are not meaningful\n+\tskipNames := []string{\n+\t\t\"i\", \"j\", \"k\", \"x\", \"y\", \"z\", \"a\", \"b\", \"c\", \"n\", \"m\",\n+\t\t\"temp\", \"tmp\", \"var\", \"val\", \"item\", \"obj\", \"data\",\n+\t\t\"result\", \"res\", \"ret\", \"value\", \"val\", \"item\", \"element\",\n+\t}\n+\n+\tfor _, skipName := range skipNames {\n+\t\tif strings.EqualFold(name, skipName) {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\n+\treturn true\n+}\n+\n // extractFunctionCall extracts a function call from a call expression node\n func (p *Parser) extractDependency(node *sitter.Node, content string) Dependency {\n \tcall := Dependency{\n@@ -311,21 +666,125 @@ func (p *Parser) extractDependency(node *sitter.Node, content string) Dependency\n \t\tType:    getSymbolType(node.Type()),\n \t}\n \n+\t// Try to extract the function name based on the node type\n+\tcall.Name = p.extractFunctionName(node, content)\n+\n+\treturn call\n+}\n+\n+// extractFunctionName extracts the function name from a call expression\n+func (p *Parser) extractFunctionName(node *sitter.Node, content string) string {\n+\tnodeType := node.Type()\n+\n+\t// Handle different types of call expressions\n+\tswitch {\n+\tcase strings.Contains(nodeType, \"call\"):\n+\t\treturn p.extractCallExpressionName(node, content)\n+\tcase strings.Contains(nodeType, \"declaration\"):\n+\t\treturn p.extractDeclarationName(node, content)\n+\tcase strings.Contains(nodeType, \"definition\"):\n+\t\treturn p.extractDefinitionName(node, content)\n+\tdefault:\n+\t\treturn p.findFirstIdentifier(node, content)\n+\t}\n+}\n+\n+// extractCallExpressionName extracts the function name from a call expression\n+func (p *Parser) extractCallExpressionName(node *sitter.Node, content string) string {\n \tchildCount := int(node.ChildCount())\n+\n+\t// Look for the function name in the call expression\n \tfor i := 0; i \u003c childCount; i++ {\n \t\tchild := node.Child(i)\n \t\tif child == nil {\n \t\t\tcontinue\n \t\t}\n \n \t\tchildType := child.Type()\n-\t\tif strings.Contains(childType, \"identifier\") || strings.Contains(childType, \"expression\") {\n-\t\t\tcall.Name = p.getNodeText(child, content)\n-\t\t\tbreak\n+\n+\t\t// Function name is usually in the first child or in a specific pattern\n+\t\tif strings.Contains(childType, \"identifier\") ||\n+\t\t\tstrings.Contains(childType, \"name\") ||\n+\t\t\tstrings.Contains(childType, \"function\") ||\n+\t\t\tstrings.Contains(childType, \"expression\") {\n+\t\t\tname := p.getNodeText(child, content)\n+\t\t\tif name != \"\" {\n+\t\t\t\treturn name\n+\t\t\t}\n+\t\t}\n+\n+\t\t// For method calls, look for the method name\n+\t\tif strings.Contains(childType, \"member\") || strings.Contains(childType, \"field\") {\n+\t\t\tname := p.extractMethodName(child, content)\n+\t\t\tif name != \"\" {\n+\t\t\t\treturn name\n+\t\t\t}\n \t\t}\n \t}\n \n-\treturn call\n+\treturn \"\"\n+}\n+\n+// extractMethodName extracts the method name from a member expression\n+func (p *Parser) extractMethodName(node *sitter.Node, content string) string {\n+\tchildCount := int(node.ChildCount())\n+\n+\tfor i := 0; i \u003c childCount; i++ {\n+\t\tchild := node.Child(i)\n+\t\tif child == nil {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tchildType := child.Type()\n+\t\tif strings.Contains(childType, \"identifier\") || strings.Contains(childType, \"name\") {\n+\t\t\treturn p.getNodeText(child, content)\n+\t\t}\n+\t}\n+\n+\treturn \"\"\n+}\n+\n+// extractDeclarationName extracts the name from a declaration\n+func (p *Parser) extractDeclarationName(node *sitter.Node, content string) string {\n+\tchildCount := int(node.ChildCount())\n+\n+\tfor i := 0; i \u003c childCount; i++ {\n+\t\tchild := node.Child(i)\n+\t\tif child == nil {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tchildType := child.Type()\n+\t\tif strings.Contains(childType, \"identifier\") ||\n+\t\t\tstrings.Contains(childType, \"name\") ||\n+\t\t\tstrings.Contains(childType, \"variable\") {\n+\t\t\treturn p.getNodeText(child, content)\n+\t\t}\n+\t}\n+\n+\treturn \"\"\n+}\n+\n+// extractDefinitionName extracts the name from a definition\n+func (p *Parser) extractDefinitionName(node *sitter.Node, content string) string {\n+\tchildCount := int(node.ChildCount())\n+\n+\tfor i := 0; i \u003c childCount; i++ {\n+\t\tchild := node.Child(i)\n+\t\tif child == nil {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tchildType := child.Type()\n+\t\tif strings.Contains(childType, \"identifier\") ||\n+\t\t\tstrings.Contains(childType, \"name\") ||\n+\t\t\tstrings.Contains(childType, \"function\") ||\n+\t\t\tstrings.Contains(childType, \"class\") {\n+\t\t\treturn p.getNodeText(child, content)\n+\t\t}\n+\t}\n+\n+\treturn \"\"\n }\n \n // getNodeText extracts the text content of a node\n@@ -342,8 +801,8 @@ func (p *Parser) getNodeText(node *sitter.Node, content string) string {\n }\n \n // findAllSymbolsInFile finds all symbols in a file\n-func (p *Parser) findAllSymbolsInFile(filePath, content string) ([]AffectedSymbol, error) {\n-\trootNode, err := p.ParseFileToAST(context.Background(), filePath, content)\n+func (p *Parser) FindAllSymbolsInFile(ctx context.Context, filePath, content string) ([]AffectedSymbol, error) {\n+\trootNode, err := p.GetFileAST(ctx, filePath, content)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -374,37 +833,57 @@ func (p *Parser) walkASTForSymbols(node *sitter.Node, filePath, content string,\n }\n \n func getSymbolType(nodeType string) SymbolType {\n+\t// First, check for exact matches\n+\tswitch nodeType {\n+\tcase \"function_declaration\", \"function_definition\", \"function_expression\", \"arrow_function\":\n+\t\treturn SymbolTypeFunction\n+\tcase \"method_declaration\", \"method_definition\":\n+\t\treturn SymbolTypeMethod\n+\tcase \"class_declaration\", \"class_definition\", \"class_specifier\":\n+\t\treturn SymbolTypeClass\n+\tcase \"interface_declaration\", \"interface_type\":\n+\t\treturn SymbolTypeInterface\n+\tcase \"struct_declaration\", \"struct_specifier\", \"struct_type\":\n+\t\treturn SymbolTypeStruct\n+\tcase \"enum_declaration\", \"enum_specifier\":\n+\t\treturn SymbolTypeEnum\n+\tcase \"variable_declaration\", \"var_declaration\", \"const_declaration\":\n+\t\treturn SymbolTypeVariable\n+\tcase \"import_statement\", \"import_declaration\":\n+\t\treturn SymbolTypeImport\n+\tcase \"package_declaration\":\n+\t\treturn SymbolTypePackage\n+\t}\n+\n+\t// Check for patterns\n \tswitch {\n \tcase strings.Contains(nodeType, \"function\"):\n \t\treturn SymbolTypeFunction\n-\n \tcase strings.Contains(nodeType, \"method\"):\n \t\treturn SymbolTypeMethod\n-\n \tcase strings.Contains(nodeType, \"class\"):\n \t\treturn SymbolTypeClass\n-\n \tcase strings.Contains(nodeType, \"interface\"):\n \t\treturn SymbolTypeInterface\n-\n-\tcase strings.Contains(nodeType, \"type_\"):\n-\t\treturn SymbolTypeType\n-\n \tcase strings.Contains(nodeType, \"struct\"):\n \t\treturn SymbolTypeStruct\n-\n \tcase strings.Contains(nodeType, \"enum\"):\n \t\treturn SymbolTypeEnum\n-\n-\tcase strings.Contains(nodeType, \"var\"):\n+\tcase strings.Contains(nodeType, \"var\") || strings.Contains(nodeType, \"variable\"):\n \t\treturn SymbolTypeVariable\n-\n \tcase strings.Contains(nodeType, \"const\"):\n \t\treturn SymbolTypeConstant\n-\n+\tcase strings.Contains(nodeType, \"type\"):\n+\t\treturn SymbolTypeType\n \tcase strings.Contains(nodeType, \"import\"):\n \t\treturn SymbolTypeImport\n-\n+\tcase strings.Contains(nodeType, \"package\"):\n+\t\treturn SymbolTypePackage\n+\tcase strings.Contains(nodeType, \"call\"):\n+\t\treturn SymbolTypeFunction // Function calls\n+\tcase strings.Contains(nodeType, \"declaration\"):\n+\t\t// Default to variable for generic declarations\n+\t\treturn SymbolTypeVariable\n \tdefault:\n \t\treturn SymbolType(nodeType)\n \t}",
      "affected_symbols": [
        {
          "symbol_name": "Name",
          "symbol_type": "struct",
          "full_code": "type Dependency struct {\n\tName    string     `json:\"name\"`\n\tSnippet string     `json:\"snippet\"`\n\tLine    int        `json:\"line\"`\n\tType    SymbolType `json:\"type\"`\n\tCode    string     `json:\"code\"`\n}",
          "doc_comment": "// Dependency represents a function call dependency",
          "context": {
            "package": "astparser",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "Snippet",
              "snippet": "Snippet string     `json:\"snippet\"`",
              "line": 58,
              "type": "variable",
              "source_file": "external",
              "source_code": "// Snippet() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "Line",
              "snippet": "Line    int        `json:\"line\"`",
              "line": 59,
              "type": "variable",
              "source_file": "external",
              "source_code": "// Line() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "Type",
              "snippet": "Type    SymbolType `json:\"type\"`",
              "line": 60,
              "type": "variable",
              "source_file": "external",
              "source_code": "// Type() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "Code",
              "snippet": "Code    string     `json:\"code\"`",
              "line": 61,
              "type": "variable",
              "source_file": "external",
              "source_code": "// Code() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/astparser/parser.go",
          "start_line": 56,
          "end_line": 62
        },
        {
          "symbol_name": "Parser",
          "symbol_type": "type",
          "full_code": "type Parser struct {\n\tlanguages map[ProgrammingLanguage]*sitter.Language\n\n\tastCache *abstract.SafeMap[string, *sitter.Node]\n}",
          "doc_comment": "// Parser handles parsing code using Tree-sitter to map lines to syntax nodes",
          "context": {
            "package": "astparser",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "languages",
              "snippet": "languages map[ProgrammingLanguage]*sitter.Language",
              "line": 74,
              "type": "variable",
              "source_file": "external",
              "source_code": "// languages() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "astCache",
              "snippet": "astCache *abstract.SafeMap[string, *sitter.Node]",
              "line": 76,
              "type": "variable",
              "source_file": "external",
              "source_code": "// astCache() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/astparser/parser.go",
          "start_line": 73,
          "end_line": 77
        },
        {
          "symbol_name": "languages",
          "symbol_type": "variable",
          "full_code": "\tlanguages map[ProgrammingLanguage]*sitter.Language",
          "doc_comment": "",
          "context": {
            "package": "astparser",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": null,
          "file_path": "internal/reviewer/astparser/parser.go",
          "start_line": 74,
          "end_line": 74
        },
        {
          "symbol_name": "languages",
          "symbol_type": "struct",
          "full_code": "type Parser struct {\n\tlanguages map[ProgrammingLanguage]*sitter.Language\n\n\tastCache *abstract.SafeMap[string, *sitter.Node]\n}",
          "doc_comment": "// Parser handles parsing code using Tree-sitter to map lines to syntax nodes",
          "context": {
            "package": "astparser",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "languages",
              "snippet": "languages map[ProgrammingLanguage]*sitter.Language",
              "line": 74,
              "type": "variable",
              "source_file": "external",
              "source_code": "// languages() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "astCache",
              "snippet": "astCache *abstract.SafeMap[string, *sitter.Node]",
              "line": 76,
              "type": "variable",
              "source_file": "external",
              "source_code": "// astCache() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/astparser/parser.go",
          "start_line": 73,
          "end_line": 77
        },
        {
          "symbol_name": "NewParser",
          "symbol_type": "function",
          "full_code": "func NewParser() *Parser {\n\tlanguages := make(map[ProgrammingLanguage]*sitter.Language, len(languagesParsers))\n\tmaps.Copy(languages, languagesParsers)\n\treturn \u0026Parser{\n\t\tlanguages: languages,\n\t\tastCache:  abstract.NewSafeMap[string, *sitter.Node](),\n\t}\n}",
          "doc_comment": "// NewParser creates a new AST parser with supported languages",
          "context": {
            "package": "astparser",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "maps.Copy",
              "snippet": "maps.Copy(languages, languagesParsers)",
              "line": 82,
              "type": "function",
              "source_file": "external",
              "source_code": "// maps.Copy() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/astparser/parser.go",
          "start_line": 80,
          "end_line": 87
        },
        {
          "symbol_name": "GetFileAST",
          "symbol_type": "method",
          "full_code": "func (p *Parser) GetFileAST(ctx context.Context, filePath, content string) (*sitter.Node, error) {\n\tif node, ok := p.astCache.Lookup(filePath); ok {\n\t\treturn node, nil\n\t}\n\n\tlanguage := DetectProgrammingLanguage(filePath)\n\tlanguageParser, ok := p.languages[language]\n\tif !ok {\n\t\treturn nil, errm.Errorf(\"unsupported file type for AST parsing: %s\", language)\n\t}\n\n\tparser := sitter.NewParser()\n\tparser.SetLanguage(languageParser)\n\n\ttree, err := parser.ParseCtx(ctx, nil, []byte(content))\n\tif err != nil {\n\t\treturn nil, errm.Wrap(err, \"failed to parse AST\", \"file\", filePath)\n\t}\n\n\tp.astCache.Set(filePath, tree.RootNode())\n\n\treturn tree.RootNode(), nil\n}",
          "doc_comment": "// ParseFileToAST parses a file's content to AST using Tree-sitter",
          "context": {
            "package": "astparser",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "p.astCache.Lookup",
              "snippet": "p.astCache.Lookup(filePath)",
              "line": 91,
              "type": "function",
              "source_file": "external",
              "source_code": "// p.astCache.Lookup() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "DetectProgrammingLanguage",
              "snippet": "DetectProgrammingLanguage(filePath)",
              "line": 95,
              "type": "function",
              "source_file": "external",
              "source_code": "// DetectProgrammingLanguage() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "errm.Errorf",
              "snippet": "errm.Errorf(\"unsupported file type for AST parsing: %s\", language)",
              "line": 98,
              "type": "function",
              "source_file": "external",
              "source_code": "// errm.Errorf() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "sitter.NewParser",
              "snippet": "sitter.NewParser()",
              "line": 101,
              "type": "function",
              "source_file": "external",
              "source_code": "// sitter.NewParser() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "parser.SetLanguage",
              "snippet": "parser.SetLanguage(languageParser)",
              "line": 102,
              "type": "function",
              "source_file": "external",
              "source_code": "// parser.SetLanguage() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "parser.ParseCtx",
              "snippet": "parser.ParseCtx(ctx, nil, []byte(content))",
              "line": 104,
              "type": "function",
              "source_file": "external",
              "source_code": "// parser.ParseCtx() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "errm.Wrap",
              "snippet": "errm.Wrap(err, \"failed to parse AST\", \"file\", filePath)",
              "line": 106,
              "type": "function",
              "source_file": "external",
              "source_code": "// errm.Wrap() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "p.astCache.Set",
              "snippet": "p.astCache.Set(filePath, tree.RootNode())",
              "line": 109,
              "type": "function",
              "source_file": "external",
              "source_code": "// p.astCache.Set() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "tree.RootNode",
              "snippet": "tree.RootNode()",
              "line": 109,
              "type": "function",
              "source_file": "external",
              "source_code": "// tree.RootNode() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "tree.RootNode",
              "snippet": "tree.RootNode()",
              "line": 111,
              "type": "function",
              "source_file": "external",
              "source_code": "// tree.RootNode() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/astparser/parser.go",
          "start_line": 90,
          "end_line": 112
        },
        {
          "symbol_name": "FindAffectedSymbols",
          "symbol_type": "method",
          "full_code": "func (p *Parser) FindAffectedSymbols(ctx context.Context, filePath, fileContent string, changedLines []int) ([]AffectedSymbol, error) {\n\trootNode, err := p.GetFileAST(ctx, filePath, fileContent)\n\tif err != nil {\n\t\treturn nil, errm.Wrap(err, \"failed to parse file to AST\", \"file\", filePath)\n\t}\n\n\tvar symbols []AffectedSymbol\n\tsymbolsFound := make(map[string]bool) // To avoid duplicates\n\n\t// Find symbols for each changed line\n\tfor _, lineNumber := range changedLines {\n\t\tenclosingNode := p.FindSmallestEnclosingNode(rootNode, lineNumber)\n\t\tif enclosingNode == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Find the parent symbol (function, class, etc.)\n\t\tsymbolNode := p.findParentSymbolNode(enclosingNode)\n\t\tif symbolNode == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tsymbol := p.ExtractSymbolFromNode(symbolNode, filePath, fileContent)\n\t\tif symbol.Name == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Use a unique key to avoid duplicates\n\t\tsymbolKey := symbol.FilePath + \":\" + string(symbol.Type) + \":\" + symbol.Name\n\t\tif !symbolsFound[symbolKey] {\n\t\t\tsymbols = append(symbols, symbol)\n\t\t\tsymbolsFound[symbolKey] = true\n\t\t}\n\t}\n\n\treturn symbols, nil\n}",
          "doc_comment": "// FindAffectedSymbols finds all symbols affected by changes in the given lines",
          "context": {
            "package": "astparser",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "p.GetFileAST",
              "snippet": "p.GetFileAST(ctx, filePath, fileContent)",
              "line": 152,
              "type": "function",
              "source_file": "external",
              "source_code": "// p.GetFileAST() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "errm.Wrap",
              "snippet": "errm.Wrap(err, \"failed to parse file to AST\", \"file\", filePath)",
              "line": 154,
              "type": "function",
              "source_file": "external",
              "source_code": "// errm.Wrap() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "p.FindSmallestEnclosingNode",
              "snippet": "p.FindSmallestEnclosingNode(rootNode, lineNumber)",
              "line": 162,
              "type": "function",
              "source_file": "external",
              "source_code": "// p.FindSmallestEnclosingNode() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "p.findParentSymbolNode",
              "snippet": "p.findParentSymbolNode(enclosingNode)",
              "line": 168,
              "type": "function",
              "source_file": "external",
              "source_code": "// p.findParentSymbolNode() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "p.ExtractSymbolFromNode",
              "snippet": "p.ExtractSymbolFromNode(symbolNode, filePath, fileContent)",
              "line": 173,
              "type": "function",
              "source_file": "external",
              "source_code": "// p.ExtractSymbolFromNode() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/astparser/parser.go",
          "start_line": 151,
          "end_line": 187
        },
        {
          "symbol_name": "ExtractSymbolFromNode",
          "symbol_type": "method",
          "full_code": "func (p *Parser) ExtractSymbolFromNode(node *sitter.Node, filePath, fileContent string) AffectedSymbol {\n\tsymbol := AffectedSymbol{\n\t\tFilePath:  filePath,\n\t\tStartLine: int(node.StartPoint().Row) + 1, // Convert to 1-based\n\t\tEndLine:   int(node.EndPoint().Row) + 1,   // Convert to 1-based\n\t\tName:      p.extractSymbolName(node, fileContent, filePath),\n\t\tType:      getSymbolType(node.Type()),\n\t}\n\tsymbol.DocComment = p.extractDocComment(node, fileContent, symbol.StartLine)\n\tsymbol.Dependencies = p.extractDependencies(node, fileContent, symbol.Type == SymbolTypeFunction || symbol.Type == SymbolTypeMethod)\n\n\tlines := strings.Split(fileContent, \"\\n\")\n\n\tif symbol.StartLine \u003e 0 \u0026\u0026 symbol.EndLine \u003e 0 \u0026\u0026 symbol.EndLine \u003c= len(lines) {\n\t\tsymbolLines := lines[symbol.StartLine-1 : symbol.EndLine]\n\t\tsymbol.FullCode = strings.Join(symbolLines, \"\\n\")\n\t}\n\n\treturn symbol\n}",
          "doc_comment": "// ExtractSymbolFromNode extracts symbol information from an AST node",
          "context": {
            "package": "astparser",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "node.Type",
              "snippet": "node.Type()",
              "line": 219,
              "type": "function",
              "source_file": "external",
              "source_code": "// node.Type() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "p.extractDependencies",
              "snippet": "p.extractDependencies(node, fileContent, symbol.Type == SymbolTypeFunction || symbol.Type == SymbolTypeMethod)",
              "line": 222,
              "type": "function",
              "source_file": "external",
              "source_code": "// p.extractDependencies() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/astparser/parser.go",
          "start_line": 213,
          "end_line": 232
        },
        {
          "symbol_name": "extractSymbolName",
          "symbol_type": "method",
          "full_code": "func (p *Parser) extractSymbolName(node *sitter.Node, content string, filePath string) string {\n\tchildCount := int(node.ChildCount())\n\n\t// First, try to find a direct identifier child\n\tfor i := 0; i \u003c childCount; i++ {\n\t\tchild := node.Child(i)\n\t\tif child == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tchildType := child.Type()\n\t\tif strings.Contains(childType, \"identifier\") ||\n\t\t\tstrings.Contains(childType, \"name\") ||\n\t\t\tstrings.Contains(childType, \"variable_name\") ||\n\t\t\tstrings.Contains(childType, \"function_name\") ||\n\t\t\tstrings.Contains(childType, \"class_name\") ||\n\t\t\tstrings.Contains(childType, \"method_name\") {\n\t\t\tname := p.getNodeText(child, content)\n\t\t\tif name != \"\" {\n\t\t\t\treturn name\n\t\t\t}\n\t\t}\n\t}\n\n\t// For languages with different patterns, try alternative approaches\n\tlanguage := DetectProgrammingLanguage(filePath)\n\tswitch language {\n\tcase LanguageGo:\n\t\treturn p.extractGoSymbolName(node, content)\n\tcase LanguageJavaScript, LanguageTypeScript, LanguageTSX:\n\t\treturn p.extractJSSymbolName(node, content)\n\tcase LanguagePython:\n\t\treturn p.extractPythonSymbolName(node, content)\n\tcase LanguageJava:\n\t\treturn p.extractJavaSymbolName(node, content)\n\tcase LanguageCpp:\n\t\treturn p.extractCppSymbolName(node, content)\n\t}\n\n\t// Fallback: look for any identifier in the node\n\treturn p.findFirstIdentifier(node, content)\n}",
          "doc_comment": "// extractSymbolName extracts the symbol name from a symbol declaration node",
          "context": {
            "package": "astparser",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "node.ChildCount",
              "snippet": "node.ChildCount()",
              "line": 236,
              "type": "function",
              "source_file": "external",
              "source_code": "// node.ChildCount() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "node.Child",
              "snippet": "node.Child(i)",
              "line": 240,
              "type": "function",
              "source_file": "external",
              "source_code": "// node.Child() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "child.Type",
              "snippet": "child.Type()",
              "line": 245,
              "type": "function",
              "source_file": "external",
              "source_code": "// child.Type() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "DetectProgrammingLanguage",
              "snippet": "DetectProgrammingLanguage(filePath)",
              "line": 260,
              "type": "function",
              "source_file": "external",
              "source_code": "// DetectProgrammingLanguage() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "p.findFirstIdentifier",
              "snippet": "p.findFirstIdentifier(node, content)",
              "line": 275,
              "type": "function",
              "source_file": "external",
              "source_code": "// p.findFirstIdentifier() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/astparser/parser.go",
          "start_line": 235,
          "end_line": 276
        },
        {
          "symbol_name": "extractGoSymbolName",
          "symbol_type": "method",
          "full_code": "func (p *Parser) extractGoSymbolName(node *sitter.Node, content string) string {\n\tnodeType := node.Type()\n\n\tswitch nodeType {\n\tcase \"function_declaration\", \"method_declaration\":\n\t\t// Look for the function name in the function spec\n\t\tfor i := 0; i \u003c int(node.ChildCount()); i++ {\n\t\t\tchild := node.Child(i)\n\t\t\tif child != nil \u0026\u0026 child.Type() == \"function_spec\" {\n\t\t\t\treturn p.extractGoSymbolName(child, content)\n\t\t\t}\n\t\t}\n\tcase \"function_spec\":\n\t\t// Function name is usually the first identifier\n\t\tfor i := 0; i \u003c int(node.ChildCount()); i++ {\n\t\t\tchild := node.Child(i)\n\t\t\tif child != nil \u0026\u0026 strings.Contains(child.Type(), \"identifier\") {\n\t\t\t\treturn p.getNodeText(child, content)\n\t\t\t}\n\t\t}\n\tcase \"type_declaration\", \"var_declaration\", \"const_declaration\":\n\t\t// Look for the type/var/const spec\n\t\tfor i := 0; i \u003c int(node.ChildCount()); i++ {\n\t\t\tchild := node.Child(i)\n\t\t\tif child != nil \u0026\u0026 (strings.Contains(child.Type(), \"spec\") || strings.Contains(child.Type(), \"declaration\")) {\n\t\t\t\treturn p.extractGoSymbolName(child, content)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn p.findFirstIdentifier(node, content)\n}",
          "doc_comment": "// extractGoSymbolName extracts symbol names from Go AST nodes",
          "context": {
            "package": "astparser",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "node.Type",
              "snippet": "node.Type()",
              "line": 280,
              "type": "function",
              "source_file": "external",
              "source_code": "// node.Type() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "node.ChildCount",
              "snippet": "node.ChildCount()",
              "line": 285,
              "type": "function",
              "source_file": "external",
              "source_code": "// node.ChildCount() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "node.Child",
              "snippet": "node.Child(i)",
              "line": 286,
              "type": "function",
              "source_file": "external",
              "source_code": "// node.Child() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "child.Type",
              "snippet": "child.Type()",
              "line": 287,
              "type": "function",
              "source_file": "external",
              "source_code": "// child.Type() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "node.ChildCount",
              "snippet": "node.ChildCount()",
              "line": 293,
              "type": "function",
              "source_file": "external",
              "source_code": "// node.ChildCount() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "node.Child",
              "snippet": "node.Child(i)",
              "line": 294,
              "type": "function",
              "source_file": "external",
              "source_code": "// node.Child() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "child.Type",
              "snippet": "child.Type()",
              "line": 295,
              "type": "function",
              "source_file": "external",
              "source_code": "// child.Type() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "node.ChildCount",
              "snippet": "node.ChildCount()",
              "line": 301,
              "type": "function",
              "source_file": "external",
              "source_code": "// node.ChildCount() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "node.Child",
              "snippet": "node.Child(i)",
              "line": 302,
              "type": "function",
              "source_file": "external",
              "source_code": "// node.Child() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "child.Type",
              "snippet": "child.Type()",
              "line": 303,
              "type": "function",
              "source_file": "external",
              "source_code": "// child.Type() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "child.Type",
              "snippet": "child.Type()",
              "line": 303,
              "type": "function",
              "source_file": "external",
              "source_code": "// child.Type() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "p.findFirstIdentifier",
              "snippet": "p.findFirstIdentifier(node, content)",
              "line": 309,
              "type": "function",
              "source_file": "external",
              "source_code": "// p.findFirstIdentifier() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/astparser/parser.go",
          "start_line": 279,
          "end_line": 310
        },
        {
          "symbol_name": "extractJSSymbolName",
          "symbol_type": "method",
          "full_code": "func (p *Parser) extractJSSymbolName(node *sitter.Node, content string) string {\n\tnodeType := node.Type()\n\n\tswitch nodeType {\n\tcase \"function_declaration\", \"function_expression\", \"arrow_function\":\n\t\t// Look for the function name\n\t\tfor i := 0; i \u003c int(node.ChildCount()); i++ {\n\t\t\tchild := node.Child(i)\n\t\t\tif child != nil \u0026\u0026 child.Type() == \"identifier\" {\n\t\t\t\treturn p.getNodeText(child, content)\n\t\t\t}\n\t\t}\n\tcase \"class_declaration\":\n\t\t// Look for the class name\n\t\tfor i := 0; i \u003c int(node.ChildCount()); i++ {\n\t\t\tchild := node.Child(i)\n\t\t\tif child != nil \u0026\u0026 child.Type() == \"identifier\" {\n\t\t\t\treturn p.getNodeText(child, content)\n\t\t\t}\n\t\t}\n\tcase \"variable_declarator\":\n\t\t// Look for the variable name\n\t\tfor i := 0; i \u003c int(node.ChildCount()); i++ {\n\t\t\tchild := node.Child(i)\n\t\t\tif child != nil \u0026\u0026 child.Type() == \"identifier\" {\n\t\t\t\treturn p.getNodeText(child, content)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn p.findFirstIdentifier(node, content)\n}",
          "doc_comment": "// extractJSSymbolName extracts symbol names from JavaScript/TypeScript AST nodes",
          "context": {
            "package": "astparser",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "node.Type",
              "snippet": "node.Type()",
              "line": 314,
              "type": "function",
              "source_file": "external",
              "source_code": "// node.Type() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "node.ChildCount",
              "snippet": "node.ChildCount()",
              "line": 319,
              "type": "function",
              "source_file": "external",
              "source_code": "// node.ChildCount() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "node.Child",
              "snippet": "node.Child(i)",
              "line": 320,
              "type": "function",
              "source_file": "external",
              "source_code": "// node.Child() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "child.Type",
              "snippet": "child.Type()",
              "line": 321,
              "type": "function",
              "source_file": "external",
              "source_code": "// child.Type() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "node.ChildCount",
              "snippet": "node.ChildCount()",
              "line": 327,
              "type": "function",
              "source_file": "external",
              "source_code": "// node.ChildCount() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "node.Child",
              "snippet": "node.Child(i)",
              "line": 328,
              "type": "function",
              "source_file": "external",
              "source_code": "// node.Child() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "child.Type",
              "snippet": "child.Type()",
              "line": 329,
              "type": "function",
              "source_file": "external",
              "source_code": "// child.Type() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "node.ChildCount",
              "snippet": "node.ChildCount()",
              "line": 335,
              "type": "function",
              "source_file": "external",
              "source_code": "// node.ChildCount() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "node.Child",
              "snippet": "node.Child(i)",
              "line": 336,
              "type": "function",
              "source_file": "external",
              "source_code": "// node.Child() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "child.Type",
              "snippet": "child.Type()",
              "line": 337,
              "type": "function",
              "source_file": "external",
              "source_code": "// child.Type() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "p.findFirstIdentifier",
              "snippet": "p.findFirstIdentifier(node, content)",
              "line": 343,
              "type": "function",
              "source_file": "external",
              "source_code": "// p.findFirstIdentifier() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/astparser/parser.go",
          "start_line": 313,
          "end_line": 344
        },
        {
          "symbol_name": "extractPythonSymbolName",
          "symbol_type": "method",
          "full_code": "func (p *Parser) extractPythonSymbolName(node *sitter.Node, content string) string {\n\tnodeType := node.Type()\n\n\tswitch nodeType {\n\tcase \"function_definition\":\n\t\t// Look for the function name\n\t\tfor i := 0; i \u003c int(node.ChildCount()); i++ {\n\t\t\tchild := node.Child(i)\n\t\t\tif child != nil \u0026\u0026 child.Type() == \"identifier\" {\n\t\t\t\treturn p.getNodeText(child, content)\n\t\t\t}\n\t\t}\n\tcase \"class_definition\":\n\t\t// Look for the class name\n\t\tfor i := 0; i \u003c int(node.ChildCount()); i++ {\n\t\t\tchild := node.Child(i)\n\t\t\tif child != nil \u0026\u0026 child.Type() == \"identifier\" {\n\t\t\t\treturn p.getNodeText(child, content)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn p.findFirstIdentifier(node, content)\n}",
          "doc_comment": "// extractPythonSymbolName extracts symbol names from Python AST nodes",
          "context": {
            "package": "astparser",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "node.Type",
              "snippet": "node.Type()",
              "line": 348,
              "type": "function",
              "source_file": "external",
              "source_code": "// node.Type() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "node.ChildCount",
              "snippet": "node.ChildCount()",
              "line": 353,
              "type": "function",
              "source_file": "external",
              "source_code": "// node.ChildCount() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "node.Child",
              "snippet": "node.Child(i)",
              "line": 354,
              "type": "function",
              "source_file": "external",
              "source_code": "// node.Child() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "child.Type",
              "snippet": "child.Type()",
              "line": 355,
              "type": "function",
              "source_file": "external",
              "source_code": "// child.Type() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "node.ChildCount",
              "snippet": "node.ChildCount()",
              "line": 361,
              "type": "function",
              "source_file": "external",
              "source_code": "// node.ChildCount() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "node.Child",
              "snippet": "node.Child(i)",
              "line": 362,
              "type": "function",
              "source_file": "external",
              "source_code": "// node.Child() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "child.Type",
              "snippet": "child.Type()",
              "line": 363,
              "type": "function",
              "source_file": "external",
              "source_code": "// child.Type() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "p.findFirstIdentifier",
              "snippet": "p.findFirstIdentifier(node, content)",
              "line": 369,
              "type": "function",
              "source_file": "external",
              "source_code": "// p.findFirstIdentifier() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/astparser/parser.go",
          "start_line": 347,
          "end_line": 370
        },
        {
          "symbol_name": "extractJavaSymbolName",
          "symbol_type": "method",
          "full_code": "func (p *Parser) extractJavaSymbolName(node *sitter.Node, content string) string {\n\tnodeType := node.Type()\n\n\tswitch nodeType {\n\tcase \"method_declaration\", \"constructor_declaration\":\n\t\t// Look for the method/constructor name\n\t\tfor i := 0; i \u003c int(node.ChildCount()); i++ {\n\t\t\tchild := node.Child(i)\n\t\t\tif child != nil \u0026\u0026 child.Type() == \"identifier\" {\n\t\t\t\treturn p.getNodeText(child, content)\n\t\t\t}\n\t\t}\n\tcase \"class_declaration\", \"interface_declaration\":\n\t\t// Look for the class/interface name\n\t\tfor i := 0; i \u003c int(node.ChildCount()); i++ {\n\t\t\tchild := node.Child(i)\n\t\t\tif child != nil \u0026\u0026 child.Type() == \"identifier\" {\n\t\t\t\treturn p.getNodeText(child, content)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn p.findFirstIdentifier(node, content)\n}",
          "doc_comment": "// extractJavaSymbolName extracts symbol names from Java AST nodes",
          "context": {
            "package": "astparser",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "node.Type",
              "snippet": "node.Type()",
              "line": 374,
              "type": "function",
              "source_file": "external",
              "source_code": "// node.Type() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "node.ChildCount",
              "snippet": "node.ChildCount()",
              "line": 379,
              "type": "function",
              "source_file": "external",
              "source_code": "// node.ChildCount() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "node.Child",
              "snippet": "node.Child(i)",
              "line": 380,
              "type": "function",
              "source_file": "external",
              "source_code": "// node.Child() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "child.Type",
              "snippet": "child.Type()",
              "line": 381,
              "type": "function",
              "source_file": "external",
              "source_code": "// child.Type() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "node.ChildCount",
              "snippet": "node.ChildCount()",
              "line": 387,
              "type": "function",
              "source_file": "external",
              "source_code": "// node.ChildCount() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "node.Child",
              "snippet": "node.Child(i)",
              "line": 388,
              "type": "function",
              "source_file": "external",
              "source_code": "// node.Child() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "child.Type",
              "snippet": "child.Type()",
              "line": 389,
              "type": "function",
              "source_file": "external",
              "source_code": "// child.Type() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "p.findFirstIdentifier",
              "snippet": "p.findFirstIdentifier(node, content)",
              "line": 395,
              "type": "function",
              "source_file": "external",
              "source_code": "// p.findFirstIdentifier() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/astparser/parser.go",
          "start_line": 373,
          "end_line": 396
        },
        {
          "symbol_name": "extractCppSymbolName",
          "symbol_type": "method",
          "full_code": "func (p *Parser) extractCppSymbolName(node *sitter.Node, content string) string {\n\tnodeType := node.Type()\n\n\tswitch nodeType {\n\tcase \"function_definition\", \"function_declarator\":\n\t\t// Look for the function name\n\t\tfor i := 0; i \u003c int(node.ChildCount()); i++ {\n\t\t\tchild := node.Child(i)\n\t\t\tif child != nil \u0026\u0026 child.Type() == \"identifier\" {\n\t\t\t\treturn p.getNodeText(child, content)\n\t\t\t}\n\t\t}\n\tcase \"class_specifier\", \"struct_specifier\":\n\t\t// Look for the class/struct name\n\t\tfor i := 0; i \u003c int(node.ChildCount()); i++ {\n\t\t\tchild := node.Child(i)\n\t\t\tif child != nil \u0026\u0026 child.Type() == \"identifier\" {\n\t\t\t\treturn p.getNodeText(child, content)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn p.findFirstIdentifier(node, content)\n}",
          "doc_comment": "// extractCppSymbolName extracts symbol names from C++ AST nodes",
          "context": {
            "package": "astparser",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "node.Type",
              "snippet": "node.Type()",
              "line": 400,
              "type": "function",
              "source_file": "external",
              "source_code": "// node.Type() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "node.ChildCount",
              "snippet": "node.ChildCount()",
              "line": 405,
              "type": "function",
              "source_file": "external",
              "source_code": "// node.ChildCount() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "node.Child",
              "snippet": "node.Child(i)",
              "line": 406,
              "type": "function",
              "source_file": "external",
              "source_code": "// node.Child() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "child.Type",
              "snippet": "child.Type()",
              "line": 407,
              "type": "function",
              "source_file": "external",
              "source_code": "// child.Type() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "node.ChildCount",
              "snippet": "node.ChildCount()",
              "line": 413,
              "type": "function",
              "source_file": "external",
              "source_code": "// node.ChildCount() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "node.Child",
              "snippet": "node.Child(i)",
              "line": 414,
              "type": "function",
              "source_file": "external",
              "source_code": "// node.Child() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "child.Type",
              "snippet": "child.Type()",
              "line": 415,
              "type": "function",
              "source_file": "external",
              "source_code": "// child.Type() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "p.findFirstIdentifier",
              "snippet": "p.findFirstIdentifier(node, content)",
              "line": 421,
              "type": "function",
              "source_file": "external",
              "source_code": "// p.findFirstIdentifier() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/astparser/parser.go",
          "start_line": 399,
          "end_line": 422
        },
        {
          "symbol_name": "findFirstIdentifier",
          "symbol_type": "method",
          "full_code": "func (p *Parser) findFirstIdentifier(node *sitter.Node, content string) string {\n\tif node == nil {\n\t\treturn \"\"\n\t}\n\n\tif strings.Contains(node.Type(), \"identifier\") {\n\t\treturn p.getNodeText(node, content)\n\t}\n\n\tchildCount := int(node.ChildCount())\n\tfor i := 0; i \u003c childCount; i++ {\n\t\tchild := node.Child(i)\n\t\tif child != nil {\n\t\t\tif result := p.findFirstIdentifier(child, content); result != \"\" {\n\t\t\t\treturn result\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\"\n}",
          "doc_comment": "// findFirstIdentifier finds the first identifier in a node tree",
          "context": {
            "package": "astparser",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "node.Type",
              "snippet": "node.Type()",
              "line": 430,
              "type": "function",
              "source_file": "external",
              "source_code": "// node.Type() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "node.ChildCount",
              "snippet": "node.ChildCount()",
              "line": 434,
              "type": "function",
              "source_file": "external",
              "source_code": "// node.ChildCount() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "node.Child",
              "snippet": "node.Child(i)",
              "line": 436,
              "type": "function",
              "source_file": "external",
              "source_code": "// node.Child() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "p.findFirstIdentifier",
              "snippet": "p.findFirstIdentifier(child, content)",
              "line": 438,
              "type": "function",
              "source_file": "external",
              "source_code": "// p.findFirstIdentifier() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/astparser/parser.go",
          "start_line": 425,
          "end_line": 445
        },
        {
          "symbol_name": "extractDependencies",
          "symbol_type": "method",
          "full_code": "func (p *Parser) extractDependencies(node *sitter.Node, content string, isRootFunction bool) []Dependency {\n\tvar dependencies []Dependency\n\n\tp.walkNodeForDependencies(node, content, \u0026dependencies, isRootFunction, true)\n\n\t// Filter out standard library calls and basic operations\n\treturn p.filterDependencies(dependencies)\n}",
          "doc_comment": "// extractDependencies extracts function calls and dependencies from within a symbol",
          "context": {
            "package": "astparser",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "p.walkNodeForDependencies",
              "snippet": "p.walkNodeForDependencies(node, content, \u0026dependencies, isRootFunction, true)",
              "line": 479,
              "type": "function",
              "source_file": "external",
              "source_code": "// p.walkNodeForDependencies() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "p.filterDependencies",
              "snippet": "p.filterDependencies(dependencies)",
              "line": 482,
              "type": "function",
              "source_file": "external",
              "source_code": "// p.filterDependencies() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/astparser/parser.go",
          "start_line": 476,
          "end_line": 483
        },
        {
          "symbol_name": "filterDependencies",
          "symbol_type": "method",
          "full_code": "func (p *Parser) filterDependencies(dependencies []Dependency) []Dependency {\n\tvar filtered []Dependency\n\n\tfor _, dep := range dependencies {\n\t\tif p.shouldIncludeDependency(dep) {\n\t\t\tfiltered = append(filtered, dep)\n\t\t}\n\t}\n\n\treturn filtered\n}",
          "doc_comment": "// filterDependencies filters out standard library calls and basic operations",
          "context": {
            "package": "astparser",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "p.shouldIncludeDependency",
              "snippet": "p.shouldIncludeDependency(dep)",
              "line": 490,
              "type": "function",
              "source_file": "external",
              "source_code": "// p.shouldIncludeDependency() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/astparser/parser.go",
          "start_line": 486,
          "end_line": 496
        },
        {
          "symbol_name": "filtered",
          "symbol_type": "variable",
          "full_code": "\tvar filtered []Dependency",
          "doc_comment": "",
          "context": {
            "package": "astparser",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": null,
          "file_path": "internal/reviewer/astparser/parser.go",
          "start_line": 487,
          "end_line": 487
        },
        {
          "symbol_name": "shouldIncludeDependency",
          "symbol_type": "method",
          "full_code": "func (p *Parser) shouldIncludeDependency(dep Dependency) bool {\n\t// Skip empty names\n\tif dep.Name == \"\" {\n\t\treturn false\n\t}\n\n\t// Skip standard library calls\n\tif p.isStandardLibraryCall(dep.Name) {\n\t\treturn false\n\t}\n\n\t// Skip basic operations and common patterns\n\tif p.isBasicOperation(dep.Name) {\n\t\treturn false\n\t}\n\n\t// Skip self-references and common patterns\n\tif p.isSelfReference(dep.Name) {\n\t\treturn false\n\t}\n\n\treturn true\n}",
          "doc_comment": "// shouldIncludeDependency determines if a dependency should be included",
          "context": {
            "package": "astparser",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "p.isStandardLibraryCall",
              "snippet": "p.isStandardLibraryCall(dep.Name)",
              "line": 506,
              "type": "function",
              "source_file": "external",
              "source_code": "// p.isStandardLibraryCall() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "p.isBasicOperation",
              "snippet": "p.isBasicOperation(dep.Name)",
              "line": 511,
              "type": "function",
              "source_file": "external",
              "source_code": "// p.isBasicOperation() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "p.isSelfReference",
              "snippet": "p.isSelfReference(dep.Name)",
              "line": 516,
              "type": "function",
              "source_file": "external",
              "source_code": "// p.isSelfReference() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/astparser/parser.go",
          "start_line": 499,
          "end_line": 521
        },
        {
          "symbol_name": "isStandardLibraryCall",
          "symbol_type": "method",
          "full_code": "func (p *Parser) isStandardLibraryCall(name string) bool {\n\t// Common standard library patterns\n\tstdLibPatterns := []string{\n\t\t\"std::\", \"java.\", \"System.\", \"String.\", \"Integer.\", \"List.\", \"Map.\", \"Set.\",\n\t\t\"os.\", \"sys.\", \"json.\", \"time.\", \"datetime.\", \"re.\", \"collections.\",\n\t\t\"fmt.\", \"strings.\", \"strconv.\", \"io.\", \"net.\", \"http.\", \"encoding.\",\n\t\t\"console.\", \"Math.\", \"Array.\", \"Object.\", \"JSON.\", \"Date.\",\n\t\t\"print\", \"println\", \"printf\", \"sprintf\", \"fprintf\",\n\t\t\"len\", \"cap\", \"make\", \"new\", \"append\", \"copy\",\n\t\t\"len\", \"str\", \"int\", \"float\", \"bool\", \"list\", \"dict\", \"set\",\n\t\t\"toString\", \"equals\", \"hashCode\", \"compareTo\",\n\t\t\"substring\", \"indexOf\", \"contains\", \"startsWith\", \"endsWith\",\n\t\t\"toLowerCase\", \"toUpperCase\", \"trim\", \"split\", \"join\",\n\t\t\"push\", \"pop\", \"shift\", \"unshift\", \"slice\", \"splice\",\n\t\t\"add\", \"remove\", \"get\", \"set\", \"put\", \"getOrDefault\",\n\t}\n\n\tfor _, pattern := range stdLibPatterns {\n\t\tif strings.Contains(name, pattern) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}",
          "doc_comment": "// isStandardLibraryCall checks if a call is to a standard library function",
          "context": {
            "package": "astparser",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": null,
          "file_path": "internal/reviewer/astparser/parser.go",
          "start_line": 524,
          "end_line": 548
        },
        {
          "symbol_name": "isBasicOperation",
          "symbol_type": "method",
          "full_code": "func (p *Parser) isBasicOperation(name string) bool {\n\tbasicOps := []string{\n\t\t\"+\", \"-\", \"*\", \"/\", \"%\", \"=\", \"==\", \"!=\", \"\u003c\", \"\u003e\", \"\u003c=\", \"\u003e=\",\n\t\t\"\u0026\u0026\", \"||\", \"!\", \"\u0026\", \"|\", \"^\", \"\u003c\u003c\", \"\u003e\u003e\",\n\t\t\"++\", \"--\", \"+=\", \"-=\", \"*=\", \"/=\", \"%=\",\n\t\t\"-\u003e\", \".\", \"::\", \"[]\", \"()\", \"{}\",\n\t}\n\n\tfor _, op := range basicOps {\n\t\tif name == op {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}",
          "doc_comment": "// isBasicOperation checks if a call is a basic operation",
          "context": {
            "package": "astparser",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": null,
          "file_path": "internal/reviewer/astparser/parser.go",
          "start_line": 551,
          "end_line": 566
        },
        {
          "symbol_name": "isSelfReference",
          "symbol_type": "method",
          "full_code": "func (p *Parser) isSelfReference(name string) bool {\n\tselfRefs := []string{\n\t\t\"this\", \"self\", \"super\", \"base\", \"me\", \"current\",\n\t\t\"this.\", \"self.\", \"super.\", \"base.\", \"me.\", \"current.\",\n\t}\n\n\tfor _, ref := range selfRefs {\n\t\tif strings.Contains(name, ref) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}",
          "doc_comment": "// isSelfReference checks if a call is a self-reference",
          "context": {
            "package": "astparser",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": null,
          "file_path": "internal/reviewer/astparser/parser.go",
          "start_line": 569,
          "end_line": 582
        },
        {
          "symbol_name": "walkNodeForDependencies",
          "symbol_type": "method",
          "full_code": "func (p *Parser) walkNodeForDependencies(node *sitter.Node, content string, dependencies *[]Dependency, isRootFunction, isFirstNode bool) {\n\tnodeType := node.Type()\n\n\t// Check if this node represents a function call\n\tif strings.Contains(nodeType, \"call\") {\n\t\tcall := p.extractDependency(node, content)\n\t\tif call.Name != \"\" \u0026\u0026 p.isSignificantCall(call.Name) {\n\t\t\t*dependencies = append(*dependencies, call)\n\t\t}\n\t}\n\n\t// Only include declarations/definitions if they're not the root function\n\tif !isRootFunction \u0026\u0026 !isFirstNode \u0026\u0026 (strings.Contains(nodeType, \"declaration\") || strings.Contains(nodeType, \"definition\")) {\n\t\tdeclaration := p.extractDependency(node, content)\n\t\tif declaration.Name != \"\" \u0026\u0026 p.isSignificantDeclaration(declaration.Name) {\n\t\t\t*dependencies = append(*dependencies, declaration)\n\t\t}\n\t}\n\n\t// Recursively check children\n\tchildCount := int(node.ChildCount())\n\tfor i := 0; i \u003c childCount; i++ {\n\t\tchild := node.Child(i)\n\t\tif child != nil {\n\t\t\tp.walkNodeForDependencies(child, content, dependencies, isRootFunction, false)\n\t\t}\n\t}\n}",
          "doc_comment": "// walkNodeForDependencies recursively walks the AST to find function calls",
          "context": {
            "package": "astparser",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "node.Type",
              "snippet": "node.Type()",
              "line": 586,
              "type": "function",
              "source_file": "external",
              "source_code": "// node.Type() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "p.extractDependency",
              "snippet": "p.extractDependency(node, content)",
              "line": 590,
              "type": "function",
              "source_file": "external",
              "source_code": "// p.extractDependency() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "p.isSignificantCall",
              "snippet": "p.isSignificantCall(call.Name)",
              "line": 591,
              "type": "function",
              "source_file": "external",
              "source_code": "// p.isSignificantCall() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "p.extractDependency",
              "snippet": "p.extractDependency(node, content)",
              "line": 598,
              "type": "function",
              "source_file": "external",
              "source_code": "// p.extractDependency() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "p.isSignificantDeclaration",
              "snippet": "p.isSignificantDeclaration(declaration.Name)",
              "line": 599,
              "type": "function",
              "source_file": "external",
              "source_code": "// p.isSignificantDeclaration() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "node.ChildCount",
              "snippet": "node.ChildCount()",
              "line": 605,
              "type": "function",
              "source_file": "external",
              "source_code": "// node.ChildCount() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "node.Child",
              "snippet": "node.Child(i)",
              "line": 607,
              "type": "function",
              "source_file": "external",
              "source_code": "// node.Child() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "p.walkNodeForDependencies",
              "snippet": "p.walkNodeForDependencies(child, content, dependencies, isRootFunction, false)",
              "line": 609,
              "type": "function",
              "source_file": "external",
              "source_code": "// p.walkNodeForDependencies() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/astparser/parser.go",
          "start_line": 585,
          "end_line": 612
        },
        {
          "symbol_name": "isSignificantCall",
          "symbol_type": "method",
          "full_code": "func (p *Parser) isSignificantCall(name string) bool {\n\t// Skip very short names (likely operators or basic operations)\n\tif len(name) \u003c= 2 {\n\t\treturn false\n\t}\n\n\t// Skip common patterns that are not meaningful dependencies\n\tskipPatterns := []string{\n\t\t\"get\", \"set\", \"add\", \"remove\", \"find\", \"create\", \"update\", \"delete\",\n\t\t\"toString\", \"equals\", \"hashCode\", \"clone\", \"copy\", \"clear\",\n\t\t\"size\", \"length\", \"count\", \"empty\", \"isEmpty\", \"hasNext\",\n\t\t\"next\", \"previous\", \"first\", \"last\", \"begin\", \"end\",\n\t}\n\n\tfor _, pattern := range skipPatterns {\n\t\tif strings.EqualFold(name, pattern) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}",
          "doc_comment": "// isSignificantCall determines if a function call is significant enough to include",
          "context": {
            "package": "astparser",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": null,
          "file_path": "internal/reviewer/astparser/parser.go",
          "start_line": 615,
          "end_line": 636
        },
        {
          "symbol_name": "isSignificantDeclaration",
          "symbol_type": "method",
          "full_code": "func (p *Parser) isSignificantDeclaration(name string) bool {\n\t// Skip very short names\n\tif len(name) \u003c= 2 {\n\t\treturn false\n\t}\n\n\t// Skip common variable names that are not meaningful\n\tskipNames := []string{\n\t\t\"i\", \"j\", \"k\", \"x\", \"y\", \"z\", \"a\", \"b\", \"c\", \"n\", \"m\",\n\t\t\"temp\", \"tmp\", \"var\", \"val\", \"item\", \"obj\", \"data\",\n\t\t\"result\", \"res\", \"ret\", \"value\", \"val\", \"item\", \"element\",\n\t}\n\n\tfor _, skipName := range skipNames {\n\t\tif strings.EqualFold(name, skipName) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}",
          "doc_comment": "// isSignificantDeclaration determines if a declaration is significant enough to include",
          "context": {
            "package": "astparser",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": null,
          "file_path": "internal/reviewer/astparser/parser.go",
          "start_line": 639,
          "end_line": 659
        },
        {
          "symbol_name": "extractDependency",
          "symbol_type": "method",
          "full_code": "func (p *Parser) extractDependency(node *sitter.Node, content string) Dependency {\n\tcall := Dependency{\n\t\tSnippet: p.getNodeText(node, content),\n\t\tLine:    int(node.StartPoint().Row) + 1,\n\t\tType:    getSymbolType(node.Type()),\n\t}\n\n\t// Try to extract the function name based on the node type\n\tcall.Name = p.extractFunctionName(node, content)\n\n\treturn call\n}",
          "doc_comment": "// extractFunctionCall extracts a function call from a call expression node",
          "context": {
            "package": "astparser",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "node.Type",
              "snippet": "node.Type()",
              "line": 666,
              "type": "function",
              "source_file": "external",
              "source_code": "// node.Type() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/astparser/parser.go",
          "start_line": 662,
          "end_line": 673
        },
        {
          "symbol_name": "extractFunctionName",
          "symbol_type": "method",
          "full_code": "func (p *Parser) extractFunctionName(node *sitter.Node, content string) string {\n\tnodeType := node.Type()\n\n\t// Handle different types of call expressions\n\tswitch {\n\tcase strings.Contains(nodeType, \"call\"):\n\t\treturn p.extractCallExpressionName(node, content)\n\tcase strings.Contains(nodeType, \"declaration\"):\n\t\treturn p.extractDeclarationName(node, content)\n\tcase strings.Contains(nodeType, \"definition\"):\n\t\treturn p.extractDefinitionName(node, content)\n\tdefault:\n\t\treturn p.findFirstIdentifier(node, content)\n\t}\n}",
          "doc_comment": "// extractFunctionName extracts the function name from a call expression",
          "context": {
            "package": "astparser",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "node.Type",
              "snippet": "node.Type()",
              "line": 677,
              "type": "function",
              "source_file": "external",
              "source_code": "// node.Type() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "p.findFirstIdentifier",
              "snippet": "p.findFirstIdentifier(node, content)",
              "line": 688,
              "type": "function",
              "source_file": "external",
              "source_code": "// p.findFirstIdentifier() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/astparser/parser.go",
          "start_line": 676,
          "end_line": 690
        },
        {
          "symbol_name": "extractCallExpressionName",
          "symbol_type": "method",
          "full_code": "func (p *Parser) extractCallExpressionName(node *sitter.Node, content string) string {\n\tchildCount := int(node.ChildCount())\n\n\t// Look for the function name in the call expression\n\tfor i := 0; i \u003c childCount; i++ {\n\t\tchild := node.Child(i)\n\t\tif child == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tchildType := child.Type()\n\n\t\t// Function name is usually in the first child or in a specific pattern\n\t\tif strings.Contains(childType, \"identifier\") ||\n\t\t\tstrings.Contains(childType, \"name\") ||\n\t\t\tstrings.Contains(childType, \"function\") ||\n\t\t\tstrings.Contains(childType, \"expression\") {\n\t\t\tname := p.getNodeText(child, content)\n\t\t\tif name != \"\" {\n\t\t\t\treturn name\n\t\t\t}\n\t\t}\n\n\t\t// For method calls, look for the method name\n\t\tif strings.Contains(childType, \"member\") || strings.Contains(childType, \"field\") {\n\t\t\tname := p.extractMethodName(child, content)\n\t\t\tif name != \"\" {\n\t\t\t\treturn name\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\"\n}",
          "doc_comment": "// extractCallExpressionName extracts the function name from a call expression",
          "context": {
            "package": "astparser",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "node.ChildCount",
              "snippet": "node.ChildCount()",
              "line": 694,
              "type": "function",
              "source_file": "external",
              "source_code": "// node.ChildCount() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "node.Child",
              "snippet": "node.Child(i)",
              "line": 698,
              "type": "function",
              "source_file": "external",
              "source_code": "// node.Child() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "child.Type",
              "snippet": "child.Type()",
              "line": 703,
              "type": "function",
              "source_file": "external",
              "source_code": "// child.Type() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/astparser/parser.go",
          "start_line": 693,
          "end_line": 726
        },
        {
          "symbol_name": "extractMethodName",
          "symbol_type": "method",
          "full_code": "func (p *Parser) extractMethodName(node *sitter.Node, content string) string {\n\tchildCount := int(node.ChildCount())\n\n\tfor i := 0; i \u003c childCount; i++ {\n\t\tchild := node.Child(i)\n\t\tif child == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tchildType := child.Type()\n\t\tif strings.Contains(childType, \"identifier\") || strings.Contains(childType, \"name\") {\n\t\t\treturn p.getNodeText(child, content)\n\t\t}\n\t}\n\n\treturn \"\"\n}",
          "doc_comment": "// extractMethodName extracts the method name from a member expression",
          "context": {
            "package": "astparser",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "node.ChildCount",
              "snippet": "node.ChildCount()",
              "line": 730,
              "type": "function",
              "source_file": "external",
              "source_code": "// node.ChildCount() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "node.Child",
              "snippet": "node.Child(i)",
              "line": 733,
              "type": "function",
              "source_file": "external",
              "source_code": "// node.Child() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "child.Type",
              "snippet": "child.Type()",
              "line": 738,
              "type": "function",
              "source_file": "external",
              "source_code": "// child.Type() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/astparser/parser.go",
          "start_line": 729,
          "end_line": 745
        },
        {
          "symbol_name": "extractDeclarationName",
          "symbol_type": "method",
          "full_code": "func (p *Parser) extractDeclarationName(node *sitter.Node, content string) string {\n\tchildCount := int(node.ChildCount())\n\n\tfor i := 0; i \u003c childCount; i++ {\n\t\tchild := node.Child(i)\n\t\tif child == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tchildType := child.Type()\n\t\tif strings.Contains(childType, \"identifier\") ||\n\t\t\tstrings.Contains(childType, \"name\") ||\n\t\t\tstrings.Contains(childType, \"variable\") {\n\t\t\treturn p.getNodeText(child, content)\n\t\t}\n\t}\n\n\treturn \"\"\n}",
          "doc_comment": "// extractDeclarationName extracts the name from a declaration",
          "context": {
            "package": "astparser",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "node.ChildCount",
              "snippet": "node.ChildCount()",
              "line": 749,
              "type": "function",
              "source_file": "external",
              "source_code": "// node.ChildCount() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "node.Child",
              "snippet": "node.Child(i)",
              "line": 752,
              "type": "function",
              "source_file": "external",
              "source_code": "// node.Child() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "child.Type",
              "snippet": "child.Type()",
              "line": 757,
              "type": "function",
              "source_file": "external",
              "source_code": "// child.Type() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/astparser/parser.go",
          "start_line": 748,
          "end_line": 766
        },
        {
          "symbol_name": "extractDefinitionName",
          "symbol_type": "method",
          "full_code": "func (p *Parser) extractDefinitionName(node *sitter.Node, content string) string {\n\tchildCount := int(node.ChildCount())\n\n\tfor i := 0; i \u003c childCount; i++ {\n\t\tchild := node.Child(i)\n\t\tif child == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tchildType := child.Type()\n\t\tif strings.Contains(childType, \"identifier\") ||\n\t\t\tstrings.Contains(childType, \"name\") ||\n\t\t\tstrings.Contains(childType, \"function\") ||\n\t\t\tstrings.Contains(childType, \"class\") {\n\t\t\treturn p.getNodeText(child, content)\n\t\t}\n\t}\n\n\treturn \"\"\n}",
          "doc_comment": "// extractDefinitionName extracts the name from a definition",
          "context": {
            "package": "astparser",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "node.ChildCount",
              "snippet": "node.ChildCount()",
              "line": 770,
              "type": "function",
              "source_file": "external",
              "source_code": "// node.ChildCount() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "node.Child",
              "snippet": "node.Child(i)",
              "line": 773,
              "type": "function",
              "source_file": "external",
              "source_code": "// node.Child() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "child.Type",
              "snippet": "child.Type()",
              "line": 778,
              "type": "function",
              "source_file": "external",
              "source_code": "// child.Type() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/astparser/parser.go",
          "start_line": 769,
          "end_line": 788
        },
        {
          "symbol_name": "FindAllSymbolsInFile",
          "symbol_type": "method",
          "full_code": "func (p *Parser) FindAllSymbolsInFile(ctx context.Context, filePath, content string) ([]AffectedSymbol, error) {\n\trootNode, err := p.GetFileAST(ctx, filePath, content)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar symbols []AffectedSymbol\n\tp.walkASTForSymbols(rootNode, filePath, content, \u0026symbols)\n\n\treturn symbols, nil\n}",
          "doc_comment": "// findAllSymbolsInFile finds all symbols in a file",
          "context": {
            "package": "astparser",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "p.GetFileAST",
              "snippet": "p.GetFileAST(ctx, filePath, content)",
              "line": 805,
              "type": "function",
              "source_file": "external",
              "source_code": "// p.GetFileAST() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "p.walkASTForSymbols",
              "snippet": "p.walkASTForSymbols(rootNode, filePath, content, \u0026symbols)",
              "line": 811,
              "type": "function",
              "source_file": "external",
              "source_code": "// p.walkASTForSymbols() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/astparser/parser.go",
          "start_line": 804,
          "end_line": 814
        },
        {
          "symbol_name": "getSymbolType",
          "symbol_type": "function",
          "full_code": "func getSymbolType(nodeType string) SymbolType {\n\t// First, check for exact matches\n\tswitch nodeType {\n\tcase \"function_declaration\", \"function_definition\", \"function_expression\", \"arrow_function\":\n\t\treturn SymbolTypeFunction\n\tcase \"method_declaration\", \"method_definition\":\n\t\treturn SymbolTypeMethod\n\tcase \"class_declaration\", \"class_definition\", \"class_specifier\":\n\t\treturn SymbolTypeClass\n\tcase \"interface_declaration\", \"interface_type\":\n\t\treturn SymbolTypeInterface\n\tcase \"struct_declaration\", \"struct_specifier\", \"struct_type\":\n\t\treturn SymbolTypeStruct\n\tcase \"enum_declaration\", \"enum_specifier\":\n\t\treturn SymbolTypeEnum\n\tcase \"variable_declaration\", \"var_declaration\", \"const_declaration\":\n\t\treturn SymbolTypeVariable\n\tcase \"import_statement\", \"import_declaration\":\n\t\treturn SymbolTypeImport\n\tcase \"package_declaration\":\n\t\treturn SymbolTypePackage\n\t}\n\n\t// Check for patterns\n\tswitch {\n\tcase strings.Contains(nodeType, \"function\"):\n\t\treturn SymbolTypeFunction\n\tcase strings.Contains(nodeType, \"method\"):\n\t\treturn SymbolTypeMethod\n\tcase strings.Contains(nodeType, \"class\"):\n\t\treturn SymbolTypeClass\n\tcase strings.Contains(nodeType, \"interface\"):\n\t\treturn SymbolTypeInterface\n\tcase strings.Contains(nodeType, \"struct\"):\n\t\treturn SymbolTypeStruct\n\tcase strings.Contains(nodeType, \"enum\"):\n\t\treturn SymbolTypeEnum\n\tcase strings.Contains(nodeType, \"var\") || strings.Contains(nodeType, \"variable\"):\n\t\treturn SymbolTypeVariable\n\tcase strings.Contains(nodeType, \"const\"):\n\t\treturn SymbolTypeConstant\n\tcase strings.Contains(nodeType, \"type\"):\n\t\treturn SymbolTypeType\n\tcase strings.Contains(nodeType, \"import\"):\n\t\treturn SymbolTypeImport\n\tcase strings.Contains(nodeType, \"package\"):\n\t\treturn SymbolTypePackage\n\tcase strings.Contains(nodeType, \"call\"):\n\t\treturn SymbolTypeFunction // Function calls\n\tcase strings.Contains(nodeType, \"declaration\"):\n\t\t// Default to variable for generic declarations\n\t\treturn SymbolTypeVariable\n\tdefault:\n\t\treturn SymbolType(nodeType)\n\t}\n}",
          "doc_comment": "",
          "context": {
            "package": "astparser",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "SymbolType",
              "snippet": "SymbolType(nodeType)",
              "line": 888,
              "type": "function",
              "source_file": "external",
              "source_code": "// SymbolType() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/astparser/parser.go",
          "start_line": 835,
          "end_line": 890
        }
      ],
      "related_files": []
    },
    {
      "file_path": "internal/reviewer/astparser/special_cases_helpers.go",
      "change_type": "Modified",
      "diff": "@@ -55,7 +55,7 @@ func (sch *SpecialCasesHandler) findAllSymbolsInFile(filePath, content string) (\n \t\treturn []AffectedSymbol{}, nil\n \t}\n \n-\trootNode, err := sch.astParser.ParseFileToAST(context.Background(), filePath, content)\n+\trootNode, err := sch.astParser.GetFileAST(context.Background(), filePath, content)\n \tif err != nil {\n \t\treturn nil, err\n \t}",
      "affected_symbols": [
        {
          "symbol_name": "findAllSymbolsInFile",
          "symbol_type": "method",
          "full_code": "func (sch *SpecialCasesHandler) findAllSymbolsInFile(filePath, content string) ([]AffectedSymbol, error) {\n\tif content == \"\" {\n\t\treturn []AffectedSymbol{}, nil\n\t}\n\n\trootNode, err := sch.astParser.GetFileAST(context.Background(), filePath, content)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar symbols []AffectedSymbol\n\tsch.walkASTForSymbols(rootNode, filePath, content, \u0026symbols)\n\n\treturn symbols, nil\n}",
          "doc_comment": "// findAllSymbolsInFile finds all symbols in a file using AST parsing",
          "context": {
            "package": "astparser",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "sch.astParser.GetFileAST",
              "snippet": "sch.astParser.GetFileAST(context.Background(), filePath, content)",
              "line": 58,
              "type": "function",
              "source_file": "external",
              "source_code": "// sch.astParser.GetFileAST() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "context.Background",
              "snippet": "context.Background()",
              "line": 58,
              "type": "function",
              "source_file": "external",
              "source_code": "// context.Background() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "sch.walkASTForSymbols",
              "snippet": "sch.walkASTForSymbols(rootNode, filePath, content, \u0026symbols)",
              "line": 64,
              "type": "function",
              "source_file": "external",
              "source_code": "// sch.walkASTForSymbols() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/astparser/special_cases_helpers.go",
          "start_line": 53,
          "end_line": 67
        }
      ],
      "related_files": []
    },
    {
      "file_path": "internal/reviewer/astparser/symbol_analyzer.go",
      "change_type": "Modified",
      "diff": "@@ -100,7 +100,7 @@ func (sa *ExternalRefsAnalyzer) FindSymbolCallers(ctx context.Context, data *mod\n \tfor _, file := range getAffectedFiles(data, symbol) {\n \t\tfileCallers, err := sa.analyzeFileForCallers(ctx, file.Content, file.Path, symbol)\n \t\tif err != nil {\n-\t\t\tsa.log.Warn(\"failed to analyze file for callers\", \"error\", err, \"file\", file.Path)\n+\t\t\t//sa.log.Warn(\"failed to analyze file for callers\", \"error\", err, \"file\", file.Path)\n \t\t\tcontinue\n \t\t}\n \t\tcallers = append(callers, fileCallers...)\n@@ -125,8 +125,7 @@ func (sa *ExternalRefsAnalyzer) analyzeFileForCallers(ctx context.Context, conte\n \t\treturn nil, nil\n \t}\n \n-\t// TODO: cache\n-\trootNode, err := sa.astParser.ParseFileToAST(ctx, filePath, content)\n+\trootNode, err := sa.astParser.GetFileAST(ctx, filePath, content)\n \tif err != nil {\n \t\treturn nil, errm.Wrap(err, \"failed to parse file to AST\")\n \t}\n@@ -168,7 +167,7 @@ func (sa *ExternalRefsAnalyzer) walkASTForCallers(node *sitter.Node, content, fi\n \t\t\t}\n \n \t\t\t// Find the containing function\n-\t\t\tcontainingFunc := sa.findContainingFunctionNode(node, content)\n+\t\t\tcontainingFunc := sa.findContainingFunctionNode(node, content, filePath)\n \t\t\tif containingFunc != \"\" {\n \t\t\t\tcaller.FunctionName = containingFunc\n \t\t\t}\n@@ -197,12 +196,12 @@ func (sa *ExternalRefsAnalyzer) getCallSiteSnippet(node *sitter.Node, content st\n }\n \n // findContainingFunctionNode finds the name of the function containing a node\n-func (sa *ExternalRefsAnalyzer) findContainingFunctionNode(node *sitter.Node, content string) string {\n+func (sa *ExternalRefsAnalyzer) findContainingFunctionNode(node *sitter.Node, content, filePath string) string {\n \tcurrent := node.Parent()\n \n \tfor current != nil {\n \t\tif sa.astParser.IsSymbolNode(current.Type()) {\n-\t\t\treturn sa.astParser.extractSymbolName(current, content)\n+\t\t\treturn sa.astParser.extractSymbolName(current, content, filePath)\n \t\t}\n \t\tcurrent = current.Parent()\n \t}\n@@ -272,7 +271,7 @@ func (sa *ExternalRefsAnalyzer) findSymbolDefinitionInSnapshot(ctx context.Conte\n \n // findDefinitionInFileWithAST finds symbol definition using AST parsing\n func (sa *ExternalRefsAnalyzer) findDefinitionInFileWithAST(ctx context.Context, file *model.RepositoryFile, symbolName string) (SymbolDefinition, bool) {\n-\trootNode, err := sa.astParser.ParseFileToAST(ctx, file.Path, file.Content)\n+\trootNode, err := sa.astParser.GetFileAST(ctx, file.Path, file.Content)\n \tif err != nil {\n \t\treturn SymbolDefinition{}, false\n \t}\n@@ -289,7 +288,7 @@ func (sa *ExternalRefsAnalyzer) walkASTForDefinition(node *sitter.Node, content,\n \n \t// Check for function definitions, variable declarations, etc.\n \tif sa.astParser.IsSymbolNode(nodeType) {\n-\t\textractedName := sa.astParser.extractSymbolName(node, content)\n+\t\textractedName := sa.astParser.extractSymbolName(node, content, filePath)\n \t\tif extractedName == symbolName {\n \t\t\t*definition = SymbolDefinition{\n \t\t\t\tFilePath:      filePath,",
      "affected_symbols": [
        {
          "symbol_name": "FindSymbolCallers",
          "symbol_type": "method",
          "full_code": "func (sa *ExternalRefsAnalyzer) FindSymbolCallers(ctx context.Context, data *model.RepositorySnapshot, symbol AffectedSymbol) ([]CallerInfo, error) {\n\tvar callers []CallerInfo\n\n\tif symbol.Name == \"\" {\n\t\treturn callers, nil\n\t}\n\n\t// Analyze each potential file with AST parsing for accurate results\n\tfor _, file := range getAffectedFiles(data, symbol) {\n\t\tfileCallers, err := sa.analyzeFileForCallers(ctx, file.Content, file.Path, symbol)\n\t\tif err != nil {\n\t\t\t//sa.log.Warn(\"failed to analyze file for callers\", \"error\", err, \"file\", file.Path)\n\t\t\tcontinue\n\t\t}\n\t\tcallers = append(callers, fileCallers...)\n\t}\n\n\treturn callers, nil\n}",
          "doc_comment": "// findSymbolCallers finds all places where a symbol is called/used",
          "context": {
            "package": "astparser",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "sa.analyzeFileForCallers",
              "snippet": "sa.analyzeFileForCallers(ctx, file.Content, file.Path, symbol)",
              "line": 101,
              "type": "function",
              "source_file": "external",
              "source_code": "// sa.analyzeFileForCallers() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/astparser/symbol_analyzer.go",
          "start_line": 92,
          "end_line": 110
        },
        {
          "symbol_name": "analyzeFileForCallers",
          "symbol_type": "method",
          "full_code": "func (sa *ExternalRefsAnalyzer) analyzeFileForCallers(ctx context.Context, content string, filePath string, symbol AffectedSymbol) ([]CallerInfo, error) {\n\tif symbol.Name == \"\" {\n\t\treturn nil, nil\n\t}\n\n\trootNode, err := sa.astParser.GetFileAST(ctx, filePath, content)\n\tif err != nil {\n\t\treturn nil, errm.Wrap(err, \"failed to parse file to AST\")\n\t}\n\n\tvar callers []CallerInfo\n\tsa.walkASTForCallers(rootNode, content, filePath, symbol, \u0026callers)\n\n\treturn callers, nil\n}",
          "doc_comment": "// analyzeFileForCallers analyzes a specific file to find callers of a symbol",
          "context": {
            "package": "astparser",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "sa.astParser.GetFileAST",
              "snippet": "sa.astParser.GetFileAST(ctx, filePath, content)",
              "line": 128,
              "type": "function",
              "source_file": "external",
              "source_code": "// sa.astParser.GetFileAST() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "errm.Wrap",
              "snippet": "errm.Wrap(err, \"failed to parse file to AST\")",
              "line": 130,
              "type": "function",
              "source_file": "external",
              "source_code": "// errm.Wrap() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "sa.walkASTForCallers",
              "snippet": "sa.walkASTForCallers(rootNode, content, filePath, symbol, \u0026callers)",
              "line": 134,
              "type": "function",
              "source_file": "external",
              "source_code": "// sa.walkASTForCallers() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/astparser/symbol_analyzer.go",
          "start_line": 123,
          "end_line": 137
        },
        {
          "symbol_name": "walkASTForCallers",
          "symbol_type": "method",
          "full_code": "func (sa *ExternalRefsAnalyzer) walkASTForCallers(node *sitter.Node, content, filePath string, symbol AffectedSymbol, callers *[]CallerInfo) {\n\tnodeType := node.Type()\n\n\tif strings.Contains(nodeType, \"call\") {\n\t\tcall := sa.astParser.extractDependency(node, content)\n\t\tif call.Name == symbol.Name || strings.HasSuffix(call.Name, \".\"+symbol.Name) {\n\t\t\tcaller := CallerInfo{\n\t\t\t\tFilePath:    filePath,\n\t\t\t\tLineNumber:  call.Line,\n\t\t\t\tCode:        sa.astParser.getNodeText(node, content),\n\t\t\t\tCodeSnippet: sa.getCallSiteSnippet(node, content),\n\t\t\t}\n\n\t\t\t// Find the containing function\n\t\t\tcontainingFunc := sa.findContainingFunctionNode(node, content, filePath)\n\t\t\tif containingFunc != \"\" {\n\t\t\t\tcaller.FunctionName = containingFunc\n\t\t\t}\n\n\t\t\t*callers = append(*callers, caller)\n\t\t}\n\t}\n\n\t// Recursively check children\n\tchildCount := int(node.ChildCount())\n\tfor i := 0; i \u003c childCount; i++ {\n\t\tchild := node.Child(i)\n\t\tif child != nil {\n\t\t\tsa.walkASTForCallers(child, content, filePath, symbol, callers)\n\t\t}\n\t}\n}",
          "doc_comment": "// walkASTForCallers walks the AST to find function calls",
          "context": {
            "package": "astparser",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "node.Type",
              "snippet": "node.Type()",
              "line": 157,
              "type": "function",
              "source_file": "external",
              "source_code": "// node.Type() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "sa.astParser.extractDependency",
              "snippet": "sa.astParser.extractDependency(node, content)",
              "line": 160,
              "type": "function",
              "source_file": "external",
              "source_code": "// sa.astParser.extractDependency() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "sa.findContainingFunctionNode",
              "snippet": "sa.findContainingFunctionNode(node, content, filePath)",
              "line": 170,
              "type": "function",
              "source_file": "external",
              "source_code": "// sa.findContainingFunctionNode() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "node.ChildCount",
              "snippet": "node.ChildCount()",
              "line": 180,
              "type": "function",
              "source_file": "external",
              "source_code": "// node.ChildCount() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "node.Child",
              "snippet": "node.Child(i)",
              "line": 182,
              "type": "function",
              "source_file": "external",
              "source_code": "// node.Child() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "sa.walkASTForCallers",
              "snippet": "sa.walkASTForCallers(child, content, filePath, symbol, callers)",
              "line": 184,
              "type": "function",
              "source_file": "external",
              "source_code": "// sa.walkASTForCallers() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/astparser/symbol_analyzer.go",
          "start_line": 156,
          "end_line": 187
        },
        {
          "symbol_name": "findContainingFunctionNode",
          "symbol_type": "method",
          "full_code": "func (sa *ExternalRefsAnalyzer) findContainingFunctionNode(node *sitter.Node, content, filePath string) string {\n\tcurrent := node.Parent()\n\n\tfor current != nil {\n\t\tif sa.astParser.IsSymbolNode(current.Type()) {\n\t\t\treturn sa.astParser.extractSymbolName(current, content, filePath)\n\t\t}\n\t\tcurrent = current.Parent()\n\t}\n\n\treturn \"unknown\"\n}",
          "doc_comment": "// findContainingFunctionNode finds the name of the function containing a node",
          "context": {
            "package": "astparser",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "node.Parent",
              "snippet": "node.Parent()",
              "line": 200,
              "type": "function",
              "source_file": "external",
              "source_code": "// node.Parent() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "sa.astParser.IsSymbolNode",
              "snippet": "sa.astParser.IsSymbolNode(current.Type())",
              "line": 203,
              "type": "function",
              "source_file": "external",
              "source_code": "// sa.astParser.IsSymbolNode() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/astparser/symbol_analyzer.go",
          "start_line": 199,
          "end_line": 210
        },
        {
          "symbol_name": "findDefinitionInFileWithAST",
          "symbol_type": "method",
          "full_code": "func (sa *ExternalRefsAnalyzer) findDefinitionInFileWithAST(ctx context.Context, file *model.RepositoryFile, symbolName string) (SymbolDefinition, bool) {\n\trootNode, err := sa.astParser.GetFileAST(ctx, file.Path, file.Content)\n\tif err != nil {\n\t\treturn SymbolDefinition{}, false\n\t}\n\n\tvar definition SymbolDefinition\n\tfound := sa.walkASTForDefinition(rootNode, file.Content, file.Path, symbolName, \u0026definition)\n\n\treturn definition, found\n}",
          "doc_comment": "// findDefinitionInFileWithAST finds symbol definition using AST parsing",
          "context": {
            "package": "astparser",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "sa.astParser.GetFileAST",
              "snippet": "sa.astParser.GetFileAST(ctx, file.Path, file.Content)",
              "line": 274,
              "type": "function",
              "source_file": "external",
              "source_code": "// sa.astParser.GetFileAST() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "sa.walkASTForDefinition",
              "snippet": "sa.walkASTForDefinition(rootNode, file.Content, file.Path, symbolName, \u0026definition)",
              "line": 280,
              "type": "function",
              "source_file": "external",
              "source_code": "// sa.walkASTForDefinition() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/astparser/symbol_analyzer.go",
          "start_line": 273,
          "end_line": 283
        },
        {
          "symbol_name": "walkASTForDefinition",
          "symbol_type": "method",
          "full_code": "func (sa *ExternalRefsAnalyzer) walkASTForDefinition(node *sitter.Node, content, filePath, symbolName string, definition *SymbolDefinition) bool {\n\tnodeType := node.Type()\n\n\t// Check for function definitions, variable declarations, etc.\n\tif sa.astParser.IsSymbolNode(nodeType) {\n\t\textractedName := sa.astParser.extractSymbolName(node, content, filePath)\n\t\tif extractedName == symbolName {\n\t\t\t*definition = SymbolDefinition{\n\t\t\t\tFilePath:      filePath,\n\t\t\t\tLineNumber:    int(node.StartPoint().Row) + 1,\n\t\t\t\tCode:          sa.astParser.getNodeText(node, content),\n\t\t\t\tDocumentation: sa.extractDocumentation(node, content),\n\t\t\t}\n\t\t\treturn true\n\t\t}\n\t}\n\n\t// Recursively check children\n\tchildCount := int(node.ChildCount())\n\tfor i := 0; i \u003c childCount; i++ {\n\t\tchild := node.Child(i)\n\t\tif child != nil {\n\t\t\tif sa.walkASTForDefinition(child, content, filePath, symbolName, definition) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false\n}",
          "doc_comment": "// walkASTForDefinition walks the AST to find symbol definitions",
          "context": {
            "package": "astparser",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "node.Type",
              "snippet": "node.Type()",
              "line": 287,
              "type": "function",
              "source_file": "external",
              "source_code": "// node.Type() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "sa.astParser.IsSymbolNode",
              "snippet": "sa.astParser.IsSymbolNode(nodeType)",
              "line": 290,
              "type": "function",
              "source_file": "external",
              "source_code": "// sa.astParser.IsSymbolNode() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "node.ChildCount",
              "snippet": "node.ChildCount()",
              "line": 304,
              "type": "function",
              "source_file": "external",
              "source_code": "// node.ChildCount() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "node.Child",
              "snippet": "node.Child(i)",
              "line": 306,
              "type": "function",
              "source_file": "external",
              "source_code": "// node.Child() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "sa.walkASTForDefinition",
              "snippet": "sa.walkASTForDefinition(child, content, filePath, symbolName, definition)",
              "line": 308,
              "type": "function",
              "source_file": "external",
              "source_code": "// sa.walkASTForDefinition() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/astparser/symbol_analyzer.go",
          "start_line": 286,
          "end_line": 315
        }
      ],
      "related_files": []
    },
    {
      "file_path": "internal/reviewer/astparser/types.go",
      "change_type": "Added",
      "diff": "@@ -0,0 +1,54 @@\n+package astparser\n+\n+import \"github.com/maxbolgarin/codry/internal/model\"\n+\n+// ChangeType represents the type of file change\n+type ChangeType string\n+\n+const (\n+\tChangeTypeModified ChangeType = \"Modified\"\n+\tChangeTypeAdded    ChangeType = \"Added\"\n+\tChangeTypeDeleted  ChangeType = \"Deleted\"\n+\tChangeTypeRenamed  ChangeType = \"Renamed\"\n+)\n+\n+// FileContext represents context for a single changed file\n+type FileContext struct {\n+\tFilePath        string           `json:\"file_path\"`\n+\tChangeType      ChangeType       `json:\"change_type\"`\n+\tDiff            string           `json:\"diff\"`\n+\tAffectedSymbols []AffectedSymbol `json:\"affected_symbols\"`\n+\tRelatedFiles    []RelatedFile    `json:\"related_files\"`\n+\tConfigContext   *ConfigContext   `json:\"config_context,omitempty\"`\n+}\n+\n+// RelatedFile represents a file related to the changed file\n+type RelatedFile struct {\n+\tFilePath         string `json:\"file_path\"`\n+\tRelationship     string `json:\"relationship\"` // \"caller\", \"dependency\", \"test\", \"same_package\"\n+\tCodeSnippet      string `json:\"code_snippet\"`\n+\tLine             int    `json:\"line,omitempty\"`\n+\tRelevantFunction string `json:\"relevant_function,omitempty\"`\n+}\n+\n+// ConfigContext represents context for configuration file changes\n+type ConfigContext struct {\n+\tConfigType       string        `json:\"config_type\"` // \"yaml\", \"json\", \"env\", etc.\n+\tChangedKeys      []string      `json:\"changed_keys\"`\n+\tConsumingCode    []RelatedFile `json:\"consuming_code\"`\n+\tImpactAssessment string        `json:\"impact_assessment\"`\n+}\n+\n+// determineChangeType determines the type of change for a file\n+func (cf *ContextManager) determineChangeType(fileDiff *model.FileDiff) ChangeType {\n+\tif fileDiff.IsNew {\n+\t\treturn ChangeTypeAdded\n+\t}\n+\tif fileDiff.IsDeleted {\n+\t\treturn ChangeTypeDeleted\n+\t}\n+\tif fileDiff.IsRenamed {\n+\t\treturn ChangeTypeRenamed\n+\t}\n+\treturn ChangeTypeModified\n+}",
      "affected_symbols": [],
      "related_files": []
    },
    {
      "file_path": "internal/reviewer/llmcontext/builder.go",
      "change_type": "Modified",
      "diff": "@@ -7,7 +7,6 @@ import (\n \t\"strings\"\n \t\"time\"\n \n-\t\"github.com/maxbolgarin/codry/internal/model\"\n \t\"github.com/maxbolgarin/codry/internal/model/interfaces\"\n \t\"github.com/maxbolgarin/codry/internal/reviewer/astparser\"\n \n@@ -23,125 +22,93 @@ type Builder struct {\n \tdiffParser     *astparser.DiffParser\n \tastParser      *astparser.Parser\n \tlog            logze.Logger\n+\tisVerbose      bool\n \n-\tmrContextBuilder *mrContextBuilder\n+\trepoDataProvider *repoDataProvider\n }\n \n // NewBuilder creates a new context bundle builder\n-func NewBuilder(provider interfaces.CodeProvider) *Builder {\n+func NewBuilder(provider interfaces.CodeProvider, isVerbose bool) *Builder {\n \treturn \u0026Builder{\n \t\tprovider:         provider,\n \t\tcontextFinder:    astparser.NewContextFinder(provider),\n \t\tsymbolAnalyzer:   astparser.NewExternalRefsAnalyzer(provider),\n \t\tdiffParser:       astparser.NewDiffParser(),\n \t\tastParser:        astparser.NewParser(),\n \t\tlog:              logze.With(\"component\", \"context_bundle_builder\"),\n-\t\tmrContextBuilder: newMRContextBuilder(provider),\n+\t\tisVerbose:        isVerbose,\n+\t\trepoDataProvider: newRepoDataProvider(provider, isVerbose),\n \t}\n }\n \n // BuildContext builds a comprehensive context bundle for LLM analysis\n func (cbb *Builder) BuildContext(ctx context.Context, projectID string, mrIID int) (*ContextBundle, error) {\n-\tmr, err := cbb.provider.GetMergeRequest(ctx, projectID, mrIID)\n-\tif err != nil {\n-\t\treturn nil, errm.Wrap(err, \"failed to get merge request\")\n-\t}\n-\tdiffs, err := cbb.provider.GetMergeRequestDiffs(ctx, projectID, mrIID)\n-\tif err != nil {\n-\t\treturn nil, errm.Wrap(err, \"failed to get MR diffs\")\n-\t}\n-\tallComments, err := cbb.provider.GetComments(ctx, projectID, mrIID)\n-\tif err != nil {\n-\t\treturn nil, errm.Wrap(err, \"failed to get comments\")\n-\t}\n+\tcbb.log.DebugIf(cbb.isVerbose, \"loading repository data\")\n \n-\trequest := mrContextRequest{\n-\t\tProjectID:    projectID,\n-\t\tMergeRequest: mr,\n-\t\tDiffs:        diffs,\n-\t\tComments:     allComments,\n-\t}\n-\n-\tmrContext, err := cbb.mrContextBuilder.gatherMRContext(ctx, request)\n+\terr := cbb.repoDataProvider.loadData(ctx, projectID, mrIID)\n \tif err != nil {\n-\t\treturn nil, errm.Wrap(err, \"failed to get MR context\")\n+\t\treturn nil, errm.Wrap(err, \"failed to load repository data\")\n \t}\n \n-\trepoInfo, err := cbb.provider.GetRepositoryInfo(ctx, projectID)\n-\tif err != nil {\n-\t\treturn nil, errm.Wrap(err, \"failed to get repository info\")\n-\t}\n+\tcbb.log.DebugIf(cbb.isVerbose, \"loaded all data for context gathering\")\n \n-\trepoDataHead, err := cbb.provider.GetRepositorySnapshot(ctx, projectID, mr.SHA)\n+\tmrContext, err := gatherMRContext(projectID, cbb.repoDataProvider)\n \tif err != nil {\n-\t\treturn nil, errm.Wrap(err, \"failed to get repository data\")\n+\t\treturn nil, errm.Wrap(err, \"failed to get MR context\")\n \t}\n \n-\tvar repoDataBase *model.RepositorySnapshot\n-\tfor _, branch := range repoInfo.Branches {\n-\t\tif branch.Name == mr.TargetBranch {\n-\t\t\trepoDataBase, err = cbb.provider.GetRepositorySnapshot(ctx, projectID, branch.SHA)\n-\t\t\tif err != nil {\n-\t\t\t\treturn nil, errm.Wrap(err, \"failed to get repository data\")\n-\t\t\t}\n-\t\t}\n-\t}\n+\tcbb.log.DebugIf(cbb.isVerbose, \"gathered MR context\")\n \n \tcontextRequest := astparser.ContextRequest{\n \t\tProjectID:    projectID,\n-\t\tMergeRequest: mr,\n-\t\tFileDiffs:    diffs,\n-\t\tRepoDataHead: repoDataHead,\n-\t\tRepoDataBase: repoDataBase,\n+\t\tMergeRequest: cbb.repoDataProvider.mr,\n+\t\tFileDiffs:    cbb.repoDataProvider.diffs,\n+\t\tRepoDataHead: cbb.repoDataProvider.repoDataHead,\n+\t\tRepoDataBase: cbb.repoDataProvider.repoDataBase,\n \t}\n \n \t// Gather basic context using ContextFinder\n-\tbasicContext, err := cbb.contextFinder.GatherContext(ctx, contextRequest)\n+\tfilesContext, err := cbb.contextFinder.GatherFilesContext(ctx, contextRequest)\n \tif err != nil {\n \t\treturn nil, errm.Wrap(err, \"failed to gather basic context\")\n \t}\n \n+\tcbb.log.DebugIf(cbb.isVerbose, \"gathered basic context\")\n+\n \t// Enhance with detailed analysis\n-\tenhancedFiles, err := cbb.enhanceFileContexts(ctx, contextRequest, basicContext.Files)\n+\tenhancedFiles, err := cbb.enhanceFileContexts(ctx, contextRequest, filesContext)\n \tif err != nil {\n \t\tcbb.log.Warn(\"failed to enhance file contexts\", \"error\", err)\n \t\t// Continue with basic context\n-\t\tenhancedFiles = basicContext.Files\n+\t\tenhancedFiles = filesContext\n \t}\n \n-\t// Build overview\n-\toverview := cbb.buildOverview(enhancedFiles)\n-\n-\t// Build summary\n-\tsummary := cbb.buildSummary(enhancedFiles, overview)\n-\n-\t// Build metadata\n-\tmetadata := cbb.buildMetadata()\n+\tcbb.log.DebugIf(cbb.isVerbose, \"enhanced file contexts\")\n \n \tbundle := \u0026ContextBundle{\n-\t\tOverview:  overview,\n \t\tFiles:     enhancedFiles,\n-\t\tSummary:   summary,\n-\t\tMetadata:  metadata,\n \t\tMRContext: mrContext,\n \t}\n \n+\tcbb.log.DebugIf(cbb.isVerbose, \"built context bundle\")\n+\ttime.Sleep(time.Second)\n+\n \treturn bundle, nil\n }\n \n // enhanceFileContexts enhances file contexts with detailed symbol analysis\n-func (cbb *Builder) enhanceFileContexts(ctx context.Context, request astparser.ContextRequest, files []astparser.FileContext) ([]astparser.FileContext, error) {\n-\tvar enhancedFiles []astparser.FileContext\n+func (cbb *Builder) enhanceFileContexts(ctx context.Context, request astparser.ContextRequest, files []*astparser.FileContext) ([]*astparser.FileContext, error) {\n+\tvar enhancedFiles []*astparser.FileContext\n \n \tfor _, fileContext := range files {\n-\t\tenhanced, err := cbb.enhanceFileContext(ctx, request, fileContext)\n+\t\tenhanced, err := cbb.enhanceFileContext(ctx, request, *fileContext)\n \t\tif err != nil {\n \t\t\tcbb.log.Warn(\"failed to enhance file context\", \"error\", err, \"file\", fileContext.FilePath)\n \t\t\t// Continue with original context\n \t\t\tenhancedFiles = append(enhancedFiles, fileContext)\n \t\t\tcontinue\n \t\t}\n-\t\tenhancedFiles = append(enhancedFiles, *enhanced)\n+\t\tenhancedFiles = append(enhancedFiles, enhanced)\n \t}\n \n \treturn enhancedFiles, nil\n@@ -183,7 +150,7 @@ func (cbb *Builder) enhanceFileContext(ctx context.Context, request astparser.Co\n \t\tenhanced.RelatedFiles = append(enhanced.RelatedFiles, cbb.convertUsageToRelatedFiles(usageContext)...)\n \n \t\t// Update symbol with enhanced context information\n-\t\tenhanced.AffectedSymbols[i] = cbb.enhanceSymbolWithContext(symbol, usageContext)\n+\t\tenhanced.AffectedSymbols[i] = cbb.enhanceSymbolWithContext(symbol)\n \t}\n \n \treturn \u0026enhanced, nil\n@@ -287,7 +254,7 @@ func (cbb *Builder) convertUsageToRelatedFiles(usage astparser.SymbolUsageContex\n }\n \n // enhanceSymbolWithContext enhances a symbol with usage context information\n-func (cbb *Builder) enhanceSymbolWithContext(symbol astparser.AffectedSymbol, usage astparser.SymbolUsageContext) astparser.AffectedSymbol {\n+func (cbb *Builder) enhanceSymbolWithContext(symbol astparser.AffectedSymbol) astparser.AffectedSymbol {\n \tenhanced := symbol\n \n \t// Update context information\n@@ -299,479 +266,6 @@ func (cbb *Builder) enhanceSymbolWithContext(symbol astparser.AffectedSymbol, us\n \treturn enhanced\n }\n \n-// buildOverview builds the overview context\n-func (cbb *Builder) buildOverview(files []astparser.FileContext) OverviewContext {\n-\toverview := OverviewContext{\n-\t\tTotalFiles:        len(files),\n-\t\tTotalSymbols:      0,\n-\t\tImpactScore:       0.0,\n-\t\tChangeComplexity:  astparser.ComplexityLow,\n-\t\tHighImpactChanges: make([]string, 0),\n-\t\tConfigChanges:     make([]ConfigChangeInfo, 0),\n-\t\tDeletedSymbols:    make([]DeletedSymbolInfo, 0),\n-\t\tPotentialIssues:   make([]string, 0),\n-\t}\n-\n-\tvar totalImpactScore float64\n-\tvar maxComplexity astparser.ComplexityLevel\n-\n-\tfor _, file := range files {\n-\t\t// Count symbols\n-\t\toverview.TotalSymbols += len(file.AffectedSymbols)\n-\n-\t\t// Analyze impact and complexity\n-\t\tfileComplexity := cbb.assessFileComplexity(file)\n-\t\tfileImpact := cbb.calculateFileImpactScore(file)\n-\n-\t\ttotalImpactScore += fileImpact\n-\n-\t\t// Track maximum complexity\n-\t\tif cbb.compareComplexity(fileComplexity, maxComplexity) \u003e 0 {\n-\t\t\tmaxComplexity = fileComplexity\n-\t\t}\n-\n-\t\t// Identify high-impact changes\n-\t\tif fileImpact \u003e 10.0 { // Threshold for high impact\n-\t\t\tdescription := fmt.Sprintf(\"High-impact changes in %s (%d symbols affected)\", file.FilePath, len(file.AffectedSymbols))\n-\t\t\toverview.HighImpactChanges = append(overview.HighImpactChanges, description)\n-\t\t}\n-\n-\t\t// Collect configuration changes\n-\t\tif file.ConfigContext != nil {\n-\t\t\tconfigChange := ConfigChangeInfo{\n-\t\t\t\tFilePath:      file.FilePath,\n-\t\t\t\tConfigType:    file.ConfigContext.ConfigType,\n-\t\t\t\tChangedKeys:   file.ConfigContext.ChangedKeys,\n-\t\t\t\tImpact:        file.ConfigContext.ImpactAssessment,\n-\t\t\t\tAffectedFiles: cbb.extractFilePathsFromRelated(file.ConfigContext.ConsumingCode),\n-\t\t\t}\n-\t\t\toverview.ConfigChanges = append(overview.ConfigChanges, configChange)\n-\t\t}\n-\n-\t\t// Collect deleted symbols\n-\t\tif file.ChangeType == astparser.ChangeTypeDeleted {\n-\t\t\tfor _, symbol := range file.AffectedSymbols {\n-\t\t\t\tdeletedInfo := DeletedSymbolInfo{\n-\t\t\t\t\tSymbol:           symbol,\n-\t\t\t\t\tBrokenReferences: cbb.findBrokenReferences(file.RelatedFiles),\n-\t\t\t\t\tImpact:           cbb.assessDeletionImpact(symbol, file.RelatedFiles),\n-\t\t\t\t}\n-\t\t\t\toverview.DeletedSymbols = append(overview.DeletedSymbols, deletedInfo)\n-\t\t\t}\n-\t\t}\n-\n-\t\t// Collect potential issues\n-\t\toverview.PotentialIssues = append(overview.PotentialIssues, cbb.identifyFileIssues(file)...)\n-\t}\n-\n-\toverview.ImpactScore = totalImpactScore\n-\toverview.ChangeComplexity = maxComplexity\n-\n-\treturn overview\n-}\n-\n-// buildSummary builds the summary context\n-func (cbb *Builder) buildSummary(files []astparser.FileContext, overview OverviewContext) SummaryContext {\n-\tsummary := SummaryContext{\n-\t\tAffectedAreas:   make([]string, 0),\n-\t\tReviewFocus:     make([]string, 0),\n-\t\tRecommendations: make([]string, 0),\n-\t}\n-\n-\t// Generate changes summary\n-\tsummary.ChangesSummary = cbb.generateChangesSummary(files, overview)\n-\n-\t// Identify affected areas\n-\tsummary.AffectedAreas = cbb.identifyAffectedAreas(files)\n-\n-\t// Determine review focus areas\n-\tsummary.ReviewFocus = cbb.determineReviewFocus(files, overview)\n-\n-\t// Assess risk\n-\tsummary.RiskAssessment = cbb.assessRisk(overview)\n-\n-\t// Generate recommendations\n-\tsummary.Recommendations = cbb.generateRecommendations(files, overview)\n-\n-\treturn summary\n-}\n-\n-// buildMetadata builds the metadata context\n-func (cbb *Builder) buildMetadata() MetadataContext {\n-\treturn MetadataContext{\n-\t\tAnalysisTimestamp:  fmt.Sprintf(\"%d\", time.Now().Unix()),\n-\t\tAnalysisVersion:    \"1.0\",\n-\t\tSupportedLanguages: []string{\"go\", \"javascript\", \"typescript\", \"python\"},\n-\t\tLimitations: []string{\n-\t\t\t\"AST parsing may fail for syntactically incorrect code\",\n-\t\t\t\"Cross-repository dependencies are not analyzed\",\n-\t\t\t\"Dynamic function calls may not be detected\",\n-\t\t\t\"Generated code analysis may be incomplete\",\n-\t\t},\n-\t}\n-}\n-\n-// Helper methods for building overview and summary\n-\n-// assessFileComplexity assesses the complexity of changes in a file\n-func (cbb *Builder) assessFileComplexity(file astparser.FileContext) astparser.ComplexityLevel {\n-\tsymbolCount := len(file.AffectedSymbols)\n-\trelatedCount := len(file.RelatedFiles)\n-\n-\tif symbolCount \u003e 10 || relatedCount \u003e 20 {\n-\t\treturn astparser.ComplexityCritical\n-\t} else if symbolCount \u003e 5 || relatedCount \u003e 10 {\n-\t\treturn astparser.ComplexityHigh\n-\t} else if symbolCount \u003e 2 || relatedCount \u003e 5 {\n-\t\treturn astparser.ComplexityMedium\n-\t} else {\n-\t\treturn astparser.ComplexityLow\n-\t}\n-}\n-\n-// calculateFileImpactScore calculates an impact score for a file\n-func (cbb *Builder) calculateFileImpactScore(file astparser.FileContext) float64 {\n-\tscore := 0.0\n-\n-\t// Base score from symbol count\n-\tscore += float64(len(file.AffectedSymbols)) * 2.0\n-\n-\t// Additional score based on symbol types\n-\tfor _, symbol := range file.AffectedSymbols {\n-\t\tswitch symbol.Type {\n-\t\tcase astparser.SymbolTypeInterface:\n-\t\t\tscore += 5.0\n-\t\tcase astparser.SymbolTypeClass, astparser.SymbolTypeStruct:\n-\t\t\tscore += 3.0\n-\t\tcase astparser.SymbolTypeFunction, astparser.SymbolTypeMethod:\n-\t\t\tscore += 2.0\n-\t\tdefault:\n-\t\t\tscore += 1.0\n-\t\t}\n-\n-\t\t// Score for dependencies\n-\t\tscore += float64(len(symbol.Dependencies)) * 0.5\n-\t}\n-\n-\t// Score for related files (callers/dependencies)\n-\tscore += float64(len(file.RelatedFiles)) * 0.5\n-\n-\t// Higher score for config files\n-\tif file.ConfigContext != nil {\n-\t\tscore += 5.0\n-\t\tscore += float64(len(file.ConfigContext.ChangedKeys)) * 1.0\n-\t}\n-\n-\treturn score\n-}\n-\n-// compareComplexity compares two complexity levels\n-func (cbb *Builder) compareComplexity(a, b astparser.ComplexityLevel) int {\n-\tlevels := map[astparser.ComplexityLevel]int{\n-\t\tastparser.ComplexityLow:      1,\n-\t\tastparser.ComplexityMedium:   2,\n-\t\tastparser.ComplexityHigh:     3,\n-\t\tastparser.ComplexityCritical: 4,\n-\t}\n-\n-\treturn levels[a] - levels[b]\n-}\n-\n-// extractFilePathsFromRelated extracts file paths from related files\n-func (cbb *Builder) extractFilePathsFromRelated(relatedFiles []astparser.RelatedFile) []string {\n-\tvar paths []string\n-\tfor _, rf := range relatedFiles {\n-\t\tpaths = append(paths, rf.FilePath)\n-\t}\n-\treturn paths\n-}\n-\n-// findBrokenReferences finds broken references from related files\n-func (cbb *Builder) findBrokenReferences(relatedFiles []astparser.RelatedFile) []astparser.RelatedFile {\n-\tvar broken []astparser.RelatedFile\n-\tfor _, rf := range relatedFiles {\n-\t\tif rf.Relationship == \"broken_caller\" || rf.Relationship == \"caller\" {\n-\t\t\tbroken = append(broken, rf)\n-\t\t}\n-\t}\n-\treturn broken\n-}\n-\n-// assessDeletionImpact assesses the impact of deleting a symbol\n-func (cbb *Builder) assessDeletionImpact(symbol astparser.AffectedSymbol, relatedFiles []astparser.RelatedFile) string {\n-\tbrokenCount := len(cbb.findBrokenReferences(relatedFiles))\n-\n-\tif brokenCount == 0 {\n-\t\treturn \"Low impact - no broken references found\"\n-\t} else if brokenCount \u003c= 3 {\n-\t\treturn fmt.Sprintf(\"Medium impact - %d references may be broken\", brokenCount)\n-\t} else {\n-\t\treturn fmt.Sprintf(\"High impact - %d references may be broken\", brokenCount)\n-\t}\n-}\n-\n-// identifyFileIssues identifies potential issues in a file\n-func (cbb *Builder) identifyFileIssues(file astparser.FileContext) []string {\n-\tvar issues []string\n-\n-\t// Large number of symbols affected\n-\tif len(file.AffectedSymbols) \u003e 10 {\n-\t\tissues = append(issues, fmt.Sprintf(\"Large change in %s - %d symbols affected\", file.FilePath, len(file.AffectedSymbols)))\n-\t}\n-\n-\t// Interface changes\n-\tfor _, symbol := range file.AffectedSymbols {\n-\t\tif symbol.Type == astparser.SymbolTypeInterface {\n-\t\t\tissues = append(issues, fmt.Sprintf(\"Interface %s.%s modified - potential breaking change\", file.FilePath, symbol.Name))\n-\t\t}\n-\t}\n-\n-\t// High coupling\n-\tif len(file.RelatedFiles) \u003e 15 {\n-\t\tissues = append(issues, fmt.Sprintf(\"High coupling in %s - %d related files\", file.FilePath, len(file.RelatedFiles)))\n-\t}\n-\n-\treturn issues\n-}\n-\n-// generateChangesSummary generates a summary of changes\n-func (cbb *Builder) generateChangesSummary(files []astparser.FileContext, overview OverviewContext) string {\n-\tvar parts []string\n-\n-\tparts = append(parts, fmt.Sprintf(\"%d files modified with %d symbols affected\", overview.TotalFiles, overview.TotalSymbols))\n-\n-\t// Add complexity information\n-\tparts = append(parts, fmt.Sprintf(\"Change complexity: %s\", overview.ChangeComplexity))\n-\n-\t// Add specific change type information\n-\taddedCount, modifiedCount, deletedCount := cbb.countChangeTypes(files)\n-\tif addedCount \u003e 0 {\n-\t\tparts = append(parts, fmt.Sprintf(\"%d files added\", addedCount))\n-\t}\n-\tif modifiedCount \u003e 0 {\n-\t\tparts = append(parts, fmt.Sprintf(\"%d files modified\", modifiedCount))\n-\t}\n-\tif deletedCount \u003e 0 {\n-\t\tparts = append(parts, fmt.Sprintf(\"%d files deleted\", deletedCount))\n-\t}\n-\n-\t// Add configuration changes\n-\tif len(overview.ConfigChanges) \u003e 0 {\n-\t\tparts = append(parts, fmt.Sprintf(\"%d configuration files changed\", len(overview.ConfigChanges)))\n-\t}\n-\n-\treturn strings.Join(parts, \". \")\n-}\n-\n-// identifyAffectedAreas identifies affected areas/modules\n-func (cbb *Builder) identifyAffectedAreas(files []astparser.FileContext) []string {\n-\tareaMap := make(map[string]int)\n-\n-\tfor _, file := range files {\n-\t\t// Extract area from file path (directory structure)\n-\t\tdir := filepath.Dir(file.FilePath)\n-\t\tif dir != \".\" {\n-\t\t\t// Use the top-level directory as the area\n-\t\t\tparts := strings.Split(dir, \"/\")\n-\t\t\tif len(parts) \u003e 0 {\n-\t\t\t\tarea := parts[0]\n-\t\t\t\tareaMap[area]++\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tvar areas []string\n-\tfor area, count := range areaMap {\n-\t\tareas = append(areas, fmt.Sprintf(\"%s (%d files)\", area, count))\n-\t}\n-\n-\treturn areas\n-}\n-\n-// determineReviewFocus determines what the review should focus on\n-func (cbb *Builder) determineReviewFocus(files []astparser.FileContext, overview OverviewContext) []string {\n-\tvar focus []string\n-\n-\t// High-impact changes\n-\tif len(overview.HighImpactChanges) \u003e 0 {\n-\t\tfocus = append(focus, \"High-impact changes requiring careful review\")\n-\t}\n-\n-\t// Interface changes\n-\tinterfaceChanges := 0\n-\tfor _, file := range files {\n-\t\tfor _, symbol := range file.AffectedSymbols {\n-\t\t\tif symbol.Type == astparser.SymbolTypeInterface {\n-\t\t\t\tinterfaceChanges++\n-\t\t\t}\n-\t\t}\n-\t}\n-\tif interfaceChanges \u003e 0 {\n-\t\tfocus = append(focus, fmt.Sprintf(\"Interface changes (%d) - check for breaking changes\", interfaceChanges))\n-\t}\n-\n-\t// Configuration changes\n-\tif len(overview.ConfigChanges) \u003e 0 {\n-\t\tfocus = append(focus, \"Configuration changes - verify impact on dependent systems\")\n-\t}\n-\n-\t// Deleted symbols\n-\tif len(overview.DeletedSymbols) \u003e 0 {\n-\t\tfocus = append(focus, \"Deleted symbols - check for broken references\")\n-\t}\n-\n-\t// Complex changes\n-\tif overview.ChangeComplexity == astparser.ComplexityHigh || overview.ChangeComplexity == astparser.ComplexityCritical {\n-\t\tfocus = append(focus, \"Complex changes requiring thorough testing\")\n-\t}\n-\n-\treturn focus\n-}\n-\n-// assessRisk assesses the overall risk of the changes\n-func (cbb *Builder) assessRisk(overview OverviewContext) RiskAssessment {\n-\tassessment := RiskAssessment{\n-\t\tLevel:       RiskLevelLow,\n-\t\tScore:       overview.ImpactScore,\n-\t\tFactors:     make([]string, 0),\n-\t\tMitigations: make([]string, 0),\n-\t}\n-\n-\t// Assess risk level based on various factors\n-\triskFactors := 0\n-\n-\tif overview.ChangeComplexity == astparser.ComplexityCritical {\n-\t\triskFactors += 3\n-\t\tassessment.Factors = append(assessment.Factors, \"Critical complexity changes\")\n-\t} else if overview.ChangeComplexity == astparser.ComplexityHigh {\n-\t\triskFactors += 2\n-\t\tassessment.Factors = append(assessment.Factors, \"High complexity changes\")\n-\t}\n-\n-\tif len(overview.DeletedSymbols) \u003e 0 {\n-\t\triskFactors += 2\n-\t\tassessment.Factors = append(assessment.Factors, fmt.Sprintf(\"%d symbols deleted\", len(overview.DeletedSymbols)))\n-\t}\n-\n-\tif len(overview.ConfigChanges) \u003e 0 {\n-\t\triskFactors += 1\n-\t\tassessment.Factors = append(assessment.Factors, \"Configuration changes\")\n-\t}\n-\n-\tif overview.ImpactScore \u003e 50 {\n-\t\triskFactors += 2\n-\t\tassessment.Factors = append(assessment.Factors, \"High impact score\")\n-\t}\n-\n-\t// Determine risk level\n-\tif riskFactors \u003e= 5 {\n-\t\tassessment.Level = RiskLevelCritical\n-\t} else if riskFactors \u003e= 3 {\n-\t\tassessment.Level = RiskLevelHigh\n-\t} else if riskFactors \u003e= 1 {\n-\t\tassessment.Level = RiskLevelMedium\n-\t}\n-\n-\t// Generate mitigations\n-\tassessment.Mitigations = cbb.generateMitigations(assessment.Level, assessment.Factors)\n-\n-\treturn assessment\n-}\n-\n-// generateRecommendations generates recommendations for the review\n-func (cbb *Builder) generateRecommendations(files []astparser.FileContext, overview OverviewContext) []string {\n-\tvar recommendations []string\n-\n-\t// Based on complexity\n-\tif overview.ChangeComplexity == astparser.ComplexityCritical {\n-\t\trecommendations = append(recommendations, \"Consider breaking this large change into smaller, more focused changes\")\n-\t}\n-\n-\t// Based on deleted symbols\n-\tif len(overview.DeletedSymbols) \u003e 0 {\n-\t\trecommendations = append(recommendations, \"Verify that all references to deleted symbols have been properly updated\")\n-\t}\n-\n-\t// Based on configuration changes\n-\tif len(overview.ConfigChanges) \u003e 0 {\n-\t\trecommendations = append(recommendations, \"Update documentation to reflect configuration changes\")\n-\t\trecommendations = append(recommendations, \"Consider backwards compatibility for configuration changes\")\n-\t}\n-\n-\t// Based on interface changes\n-\tinterfaceCount := 0\n-\tfor _, file := range files {\n-\t\tfor _, symbol := range file.AffectedSymbols {\n-\t\t\tif symbol.Type == astparser.SymbolTypeInterface {\n-\t\t\t\tinterfaceCount++\n-\t\t\t}\n-\t\t}\n-\t}\n-\tif interfaceCount \u003e 0 {\n-\t\trecommendations = append(recommendations, \"Review interface changes for backwards compatibility\")\n-\t\trecommendations = append(recommendations, \"Update API documentation if public interfaces changed\")\n-\t}\n-\n-\t// General recommendations\n-\tif overview.TotalSymbols \u003e 20 {\n-\t\trecommendations = append(recommendations, \"Ensure comprehensive test coverage for the large number of changes\")\n-\t}\n-\n-\treturn recommendations\n-}\n-\n-// generateMitigations generates risk mitigations\n-func (cbb *Builder) generateMitigations(level RiskLevel, factors []string) []string {\n-\tvar mitigations []string\n-\n-\tswitch level {\n-\tcase RiskLevelCritical:\n-\t\tmitigations = append(mitigations, \"Require multiple reviewers\")\n-\t\tmitigations = append(mitigations, \"Perform comprehensive testing\")\n-\t\tmitigations = append(mitigations, \"Consider staged deployment\")\n-\t\tmitigations = append(mitigations, \"Prepare rollback plan\")\n-\n-\tcase RiskLevelHigh:\n-\t\tmitigations = append(mitigations, \"Require thorough review\")\n-\t\tmitigations = append(mitigations, \"Ensure test coverage\")\n-\t\tmitigations = append(mitigations, \"Test in staging environment\")\n-\n-\tcase RiskLevelMedium:\n-\t\tmitigations = append(mitigations, \"Standard review process\")\n-\t\tmitigations = append(mitigations, \"Verify test coverage\")\n-\n-\tcase RiskLevelLow:\n-\t\tmitigations = append(mitigations, \"Standard review\")\n-\t}\n-\n-\t// Factor-specific mitigations\n-\tfor _, factor := range factors {\n-\t\tif strings.Contains(factor, \"deleted\") {\n-\t\t\tmitigations = append(mitigations, \"Run static analysis to find orphaned references\")\n-\t\t}\n-\t\tif strings.Contains(factor, \"Configuration\") {\n-\t\t\tmitigations = append(mitigations, \"Test configuration changes in isolated environment\")\n-\t\t}\n-\t}\n-\n-\treturn mitigations\n-}\n-\n-// countChangeTypes counts different types of changes\n-func (cbb *Builder) countChangeTypes(files []astparser.FileContext) (added, modified, deleted int) {\n-\tfor _, file := range files {\n-\t\tswitch file.ChangeType {\n-\t\tcase astparser.ChangeTypeAdded:\n-\t\t\tadded++\n-\t\tcase astparser.ChangeTypeModified, astparser.ChangeTypeRenamed:\n-\t\t\tmodified++\n-\t\tcase astparser.ChangeTypeDeleted:\n-\t\t\tdeleted++\n-\t\t}\n-\t}\n-\treturn\n-}\n-\n // extractPackageFromPath extracts package name from file path\n func (cbb *Builder) extractPackageFromPath(filePath string) string {\n \tdir := filepath.Dir(filePath)",
      "affected_symbols": [
        {
          "symbol_name": "provider",
          "symbol_type": "struct",
          "full_code": "type Builder struct {\n\tprovider       interfaces.CodeProvider\n\tcontextFinder  *astparser.ContextManager\n\tsymbolAnalyzer *astparser.ExternalRefsAnalyzer\n\tdiffParser     *astparser.DiffParser\n\tastParser      *astparser.Parser\n\tlog            logze.Logger\n\tisVerbose      bool\n\n\trepoDataProvider *repoDataProvider\n}",
          "doc_comment": "// Builder builds comprehensive context bundles for LLM analysis",
          "context": {
            "package": "llmcontext",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "provider",
              "snippet": "provider       interfaces.CodeProvider",
              "line": 19,
              "type": "variable",
              "source_file": "external",
              "source_code": "// provider() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "contextFinder",
              "snippet": "contextFinder  *astparser.ContextManager",
              "line": 20,
              "type": "variable",
              "source_file": "external",
              "source_code": "// contextFinder() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "symbolAnalyzer",
              "snippet": "symbolAnalyzer *astparser.ExternalRefsAnalyzer",
              "line": 21,
              "type": "variable",
              "source_file": "external",
              "source_code": "// symbolAnalyzer() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "diffParser",
              "snippet": "diffParser     *astparser.DiffParser",
              "line": 22,
              "type": "variable",
              "source_file": "external",
              "source_code": "// diffParser() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "astParser",
              "snippet": "astParser      *astparser.Parser",
              "line": 23,
              "type": "variable",
              "source_file": "external",
              "source_code": "// astParser() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "log",
              "snippet": "log            logze.Logger",
              "line": 24,
              "type": "variable",
              "source_file": "external",
              "source_code": "// log() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "isVerbose",
              "snippet": "isVerbose      bool",
              "line": 25,
              "type": "variable",
              "source_file": "external",
              "source_code": "// isVerbose() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "repoDataProvider",
              "snippet": "repoDataProvider *repoDataProvider",
              "line": 27,
              "type": "variable",
              "source_file": "external",
              "source_code": "// repoDataProvider() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/llmcontext/builder.go",
          "start_line": 18,
          "end_line": 28
        },
        {
          "symbol_name": "NewBuilder",
          "symbol_type": "function",
          "full_code": "func NewBuilder(provider interfaces.CodeProvider, isVerbose bool) *Builder {\n\treturn \u0026Builder{\n\t\tprovider:         provider,\n\t\tcontextFinder:    astparser.NewContextFinder(provider),\n\t\tsymbolAnalyzer:   astparser.NewExternalRefsAnalyzer(provider),\n\t\tdiffParser:       astparser.NewDiffParser(),\n\t\tastParser:        astparser.NewParser(),\n\t\tlog:              logze.With(\"component\", \"context_bundle_builder\"),\n\t\tisVerbose:        isVerbose,\n\t\trepoDataProvider: newRepoDataProvider(provider, isVerbose),\n\t}\n}",
          "doc_comment": "// NewBuilder creates a new context bundle builder",
          "context": {
            "package": "llmcontext",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "astparser.NewContextFinder",
              "snippet": "astparser.NewContextFinder(provider)",
              "line": 34,
              "type": "function",
              "source_file": "external",
              "source_code": "// astparser.NewContextFinder() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "astparser.NewExternalRefsAnalyzer",
              "snippet": "astparser.NewExternalRefsAnalyzer(provider)",
              "line": 35,
              "type": "function",
              "source_file": "external",
              "source_code": "// astparser.NewExternalRefsAnalyzer() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "astparser.NewDiffParser",
              "snippet": "astparser.NewDiffParser()",
              "line": 36,
              "type": "function",
              "source_file": "external",
              "source_code": "// astparser.NewDiffParser() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "astparser.NewParser",
              "snippet": "astparser.NewParser()",
              "line": 37,
              "type": "function",
              "source_file": "external",
              "source_code": "// astparser.NewParser() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "logze.With",
              "snippet": "logze.With(\"component\", \"context_bundle_builder\")",
              "line": 38,
              "type": "function",
              "source_file": "external",
              "source_code": "// logze.With() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/llmcontext/builder.go",
          "start_line": 31,
          "end_line": 42
        },
        {
          "symbol_name": "BuildContext",
          "symbol_type": "method",
          "full_code": "func (cbb *Builder) BuildContext(ctx context.Context, projectID string, mrIID int) (*ContextBundle, error) {\n\tcbb.log.DebugIf(cbb.isVerbose, \"loading repository data\")\n\n\terr := cbb.repoDataProvider.loadData(ctx, projectID, mrIID)\n\tif err != nil {\n\t\treturn nil, errm.Wrap(err, \"failed to load repository data\")\n\t}\n\n\tcbb.log.DebugIf(cbb.isVerbose, \"loaded all data for context gathering\")\n\n\tmrContext, err := gatherMRContext(projectID, cbb.repoDataProvider)\n\tif err != nil {\n\t\treturn nil, errm.Wrap(err, \"failed to get MR context\")\n\t}\n\n\tcbb.log.DebugIf(cbb.isVerbose, \"gathered MR context\")\n\n\tcontextRequest := astparser.ContextRequest{\n\t\tProjectID:    projectID,\n\t\tMergeRequest: cbb.repoDataProvider.mr,\n\t\tFileDiffs:    cbb.repoDataProvider.diffs,\n\t\tRepoDataHead: cbb.repoDataProvider.repoDataHead,\n\t\tRepoDataBase: cbb.repoDataProvider.repoDataBase,\n\t}\n\n\t// Gather basic context using ContextFinder\n\tfilesContext, err := cbb.contextFinder.GatherFilesContext(ctx, contextRequest)\n\tif err != nil {\n\t\treturn nil, errm.Wrap(err, \"failed to gather basic context\")\n\t}\n\n\tcbb.log.DebugIf(cbb.isVerbose, \"gathered basic context\")\n\n\t// Enhance with detailed analysis\n\tenhancedFiles, err := cbb.enhanceFileContexts(ctx, contextRequest, filesContext)\n\tif err != nil {\n\t\tcbb.log.Warn(\"failed to enhance file contexts\", \"error\", err)\n\t\t// Continue with basic context\n\t\tenhancedFiles = filesContext\n\t}\n\n\tcbb.log.DebugIf(cbb.isVerbose, \"enhanced file contexts\")\n\n\tbundle := \u0026ContextBundle{\n\t\tFiles:     enhancedFiles,\n\t\tMRContext: mrContext,\n\t}\n\n\tcbb.log.DebugIf(cbb.isVerbose, \"built context bundle\")\n\ttime.Sleep(time.Second)\n\n\treturn bundle, nil\n}",
          "doc_comment": "// BuildContext builds a comprehensive context bundle for LLM analysis",
          "context": {
            "package": "llmcontext",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "cbb.log.DebugIf",
              "snippet": "cbb.log.DebugIf(cbb.isVerbose, \"loading repository data\")",
              "line": 46,
              "type": "function",
              "source_file": "external",
              "source_code": "// cbb.log.DebugIf() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "cbb.repoDataProvider.loadData",
              "snippet": "cbb.repoDataProvider.loadData(ctx, projectID, mrIID)",
              "line": 48,
              "type": "function",
              "source_file": "external",
              "source_code": "// cbb.repoDataProvider.loadData() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "errm.Wrap",
              "snippet": "errm.Wrap(err, \"failed to load repository data\")",
              "line": 50,
              "type": "function",
              "source_file": "external",
              "source_code": "// errm.Wrap() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "cbb.log.DebugIf",
              "snippet": "cbb.log.DebugIf(cbb.isVerbose, \"loaded all data for context gathering\")",
              "line": 53,
              "type": "function",
              "source_file": "external",
              "source_code": "// cbb.log.DebugIf() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "gatherMRContext",
              "snippet": "gatherMRContext(projectID, cbb.repoDataProvider)",
              "line": 55,
              "type": "function",
              "source_file": "external",
              "source_code": "// gatherMRContext() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "errm.Wrap",
              "snippet": "errm.Wrap(err, \"failed to get MR context\")",
              "line": 57,
              "type": "function",
              "source_file": "external",
              "source_code": "// errm.Wrap() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "cbb.log.DebugIf",
              "snippet": "cbb.log.DebugIf(cbb.isVerbose, \"gathered MR context\")",
              "line": 60,
              "type": "function",
              "source_file": "external",
              "source_code": "// cbb.log.DebugIf() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "cbb.contextFinder.GatherFilesContext",
              "snippet": "cbb.contextFinder.GatherFilesContext(ctx, contextRequest)",
              "line": 71,
              "type": "function",
              "source_file": "external",
              "source_code": "// cbb.contextFinder.GatherFilesContext() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "errm.Wrap",
              "snippet": "errm.Wrap(err, \"failed to gather basic context\")",
              "line": 73,
              "type": "function",
              "source_file": "external",
              "source_code": "// errm.Wrap() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "cbb.log.DebugIf",
              "snippet": "cbb.log.DebugIf(cbb.isVerbose, \"gathered basic context\")",
              "line": 76,
              "type": "function",
              "source_file": "external",
              "source_code": "// cbb.log.DebugIf() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "cbb.enhanceFileContexts",
              "snippet": "cbb.enhanceFileContexts(ctx, contextRequest, filesContext)",
              "line": 79,
              "type": "function",
              "source_file": "external",
              "source_code": "// cbb.enhanceFileContexts() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "cbb.log.Warn",
              "snippet": "cbb.log.Warn(\"failed to enhance file contexts\", \"error\", err)",
              "line": 81,
              "type": "function",
              "source_file": "external",
              "source_code": "// cbb.log.Warn() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "cbb.log.DebugIf",
              "snippet": "cbb.log.DebugIf(cbb.isVerbose, \"enhanced file contexts\")",
              "line": 86,
              "type": "function",
              "source_file": "external",
              "source_code": "// cbb.log.DebugIf() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "cbb.log.DebugIf",
              "snippet": "cbb.log.DebugIf(cbb.isVerbose, \"built context bundle\")",
              "line": 93,
              "type": "function",
              "source_file": "external",
              "source_code": "// cbb.log.DebugIf() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/llmcontext/builder.go",
          "start_line": 45,
          "end_line": 97
        },
        {
          "symbol_name": "enhanceFileContexts",
          "symbol_type": "method",
          "full_code": "func (cbb *Builder) enhanceFileContexts(ctx context.Context, request astparser.ContextRequest, files []*astparser.FileContext) ([]*astparser.FileContext, error) {\n\tvar enhancedFiles []*astparser.FileContext\n\n\tfor _, fileContext := range files {\n\t\tenhanced, err := cbb.enhanceFileContext(ctx, request, *fileContext)\n\t\tif err != nil {\n\t\t\tcbb.log.Warn(\"failed to enhance file context\", \"error\", err, \"file\", fileContext.FilePath)\n\t\t\t// Continue with original context\n\t\t\tenhancedFiles = append(enhancedFiles, fileContext)\n\t\t\tcontinue\n\t\t}\n\t\tenhancedFiles = append(enhancedFiles, enhanced)\n\t}\n\n\treturn enhancedFiles, nil\n}",
          "doc_comment": "// enhanceFileContexts enhances file contexts with detailed symbol analysis",
          "context": {
            "package": "llmcontext",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "cbb.enhanceFileContext",
              "snippet": "cbb.enhanceFileContext(ctx, request, *fileContext)",
              "line": 104,
              "type": "function",
              "source_file": "external",
              "source_code": "// cbb.enhanceFileContext() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "cbb.log.Warn",
              "snippet": "cbb.log.Warn(\"failed to enhance file context\", \"error\", err, \"file\", fileContext.FilePath)",
              "line": 106,
              "type": "function",
              "source_file": "external",
              "source_code": "// cbb.log.Warn() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/llmcontext/builder.go",
          "start_line": 100,
          "end_line": 115
        },
        {
          "symbol_name": "enhancedFiles",
          "symbol_type": "variable",
          "full_code": "\tvar enhancedFiles []*astparser.FileContext",
          "doc_comment": "",
          "context": {
            "package": "llmcontext",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": null,
          "file_path": "internal/reviewer/llmcontext/builder.go",
          "start_line": 101,
          "end_line": 101
        },
        {
          "symbol_name": "enhanceFileContext",
          "symbol_type": "method",
          "full_code": "func (cbb *Builder) enhanceFileContext(ctx context.Context, request astparser.ContextRequest, fileContext astparser.FileContext) (*astparser.FileContext, error) {\n\tenhanced := fileContext\n\n\t// Get file content for detailed analysis\n\tvar content string\n\tvar err error\n\n\tif fileContext.ChangeType != astparser.ChangeTypeDeleted {\n\t\tcontent, err = cbb.provider.GetFileContent(ctx, request.ProjectID, fileContext.FilePath, request.MergeRequest.SHA)\n\t\tif err != nil {\n\t\t\tcbb.log.Warn(\"failed to get file content\", \"error\", err, \"file\", fileContext.FilePath)\n\t\t}\n\t}\n\n\t// Perform diff impact analysis\n\tif content != \"\" \u0026\u0026 fileContext.Diff != \"\" {\n\t\timpact, err := cbb.diffParser.AnalyzeDiffImpact(fileContext.Diff, fileContext.FilePath, content, cbb.astParser)\n\t\tif err == nil {\n\t\t\t// Add impact information to existing symbols or create new ones\n\t\t\tenhanced.AffectedSymbols = cbb.mergeSymbolInformation(enhanced.AffectedSymbols, impact.AffectedSymbols)\n\t\t}\n\t}\n\n\t// Enhance symbol information with usage context\n\tfor i, symbol := range enhanced.AffectedSymbols {\n\t\tusageContext, err := cbb.symbolAnalyzer.AnalyzeSymbolUsage(ctx, request.RepoDataHead, symbol)\n\t\tif err != nil {\n\t\t\tcbb.log.Warn(\"failed to analyze symbol usage\", \"error\", err, \"symbol\", symbol.Name)\n\t\t\tcontinue\n\t\t}\n\n\t\t// Convert usage context to related files\n\t\tenhanced.RelatedFiles = append(enhanced.RelatedFiles, cbb.convertUsageToRelatedFiles(usageContext)...)\n\n\t\t// Update symbol with enhanced context information\n\t\tenhanced.AffectedSymbols[i] = cbb.enhanceSymbolWithContext(symbol)\n\t}\n\n\treturn \u0026enhanced, nil\n}",
          "doc_comment": "// enhanceFileContext enhances a single file context with detailed analysis",
          "context": {
            "package": "llmcontext",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "cbb.provider.GetFileContent",
              "snippet": "cbb.provider.GetFileContent(ctx, request.ProjectID, fileContext.FilePath, request.MergeRequest.SHA)",
              "line": 126,
              "type": "function",
              "source_file": "external",
              "source_code": "// cbb.provider.GetFileContent() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "cbb.log.Warn",
              "snippet": "cbb.log.Warn(\"failed to get file content\", \"error\", err, \"file\", fileContext.FilePath)",
              "line": 128,
              "type": "function",
              "source_file": "external",
              "source_code": "// cbb.log.Warn() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "cbb.diffParser.AnalyzeDiffImpact",
              "snippet": "cbb.diffParser.AnalyzeDiffImpact(fileContext.Diff, fileContext.FilePath, content, cbb.astParser)",
              "line": 134,
              "type": "function",
              "source_file": "external",
              "source_code": "// cbb.diffParser.AnalyzeDiffImpact() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "cbb.symbolAnalyzer.AnalyzeSymbolUsage",
              "snippet": "cbb.symbolAnalyzer.AnalyzeSymbolUsage(ctx, request.RepoDataHead, symbol)",
              "line": 143,
              "type": "function",
              "source_file": "external",
              "source_code": "// cbb.symbolAnalyzer.AnalyzeSymbolUsage() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "cbb.log.Warn",
              "snippet": "cbb.log.Warn(\"failed to analyze symbol usage\", \"error\", err, \"symbol\", symbol.Name)",
              "line": 145,
              "type": "function",
              "source_file": "external",
              "source_code": "// cbb.log.Warn() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "cbb.convertUsageToRelatedFiles",
              "snippet": "cbb.convertUsageToRelatedFiles(usageContext)",
              "line": 150,
              "type": "function",
              "source_file": "external",
              "source_code": "// cbb.convertUsageToRelatedFiles() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "cbb.enhanceSymbolWithContext",
              "snippet": "cbb.enhanceSymbolWithContext(symbol)",
              "line": 153,
              "type": "function",
              "source_file": "external",
              "source_code": "// cbb.enhanceSymbolWithContext() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/llmcontext/builder.go",
          "start_line": 118,
          "end_line": 157
        },
        {
          "symbol_name": "enhanceSymbolWithContext",
          "symbol_type": "method",
          "full_code": "func (cbb *Builder) enhanceSymbolWithContext(symbol astparser.AffectedSymbol) astparser.AffectedSymbol {\n\tenhanced := symbol\n\n\t// Update context information\n\tenhanced.Context.Package = cbb.extractPackageFromPath(symbol.FilePath)\n\n\t// Set caller count and dependency information in a more structured way\n\t// This could be extended to include more detailed usage statistics\n\n\treturn enhanced\n}",
          "doc_comment": "// enhanceSymbolWithContext enhances a symbol with usage context information",
          "context": {
            "package": "llmcontext",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "cbb.extractPackageFromPath",
              "snippet": "cbb.extractPackageFromPath(symbol.FilePath)",
              "line": 261,
              "type": "function",
              "source_file": "external",
              "source_code": "// cbb.extractPackageFromPath() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/llmcontext/builder.go",
          "start_line": 257,
          "end_line": 267
        }
      ],
      "related_files": []
    },
    {
      "file_path": "internal/reviewer/llmcontext/context.go",
      "change_type": "Modified",
      "diff": "@@ -1,77 +1,261 @@\n package llmcontext\n \n import (\n+\t\"fmt\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\t\"github.com/maxbolgarin/codry/internal/model\"\n \t\"github.com/maxbolgarin/codry/internal/reviewer/astparser\"\n )\n \n // ContextBundle represents the final structured context for LLM\n type ContextBundle struct {\n-\tOverview  OverviewContext         `json:\"overview\"`\n-\tFiles     []astparser.FileContext `json:\"files\"`\n-\tSummary   SummaryContext          `json:\"summary\"`\n-\tMetadata  MetadataContext         `json:\"metadata\"`\n-\tMRContext *MRContext              `json:\"mr_context\"`\n+\tFiles     []*astparser.FileContext `json:\"files\"`\n+\tMRContext *MRContext               `json:\"mr_context\"`\n }\n \n-// OverviewContext provides high-level overview of the changes\n-type OverviewContext struct {\n-\tTotalFiles        int                       `json:\"total_files\"`\n-\tTotalSymbols      int                       `json:\"total_symbols\"`\n-\tImpactScore       float64                   `json:\"impact_score\"`\n-\tChangeComplexity  astparser.ComplexityLevel `json:\"change_complexity\"`\n-\tHighImpactChanges []string                  `json:\"high_impact_changes\"`\n-\tConfigChanges     []ConfigChangeInfo        `json:\"config_changes\"`\n-\tDeletedSymbols    []DeletedSymbolInfo       `json:\"deleted_symbols\"`\n-\tPotentialIssues   []string                  `json:\"potential_issues\"`\n+// MRContext holds comprehensive metadata about a merge request\n+type MRContext struct {\n+\t// Basic MR information\n+\tTitle       string    `json:\"title\"`\n+\tDescription string    `json:\"description\"`\n+\tBranchName  string    `json:\"branch_name\"`\n+\tCreatedAt   time.Time `json:\"created_at\"`\n+\tUpdatedAt   time.Time `json:\"updated_at\"`\n+\n+\t// Author information\n+\tAuthor         model.User       `json:\"author\"`\n+\tAuthorComments []*model.Comment `json:\"author_comments\"`\n+\n+\t// Commit information\n+\tCommits []CommitInfo `json:\"commits\"`\n+\n+\t// Issue/ticket links\n+\tLinkedIssues  []LinkedIssue  `json:\"linked_issues\"`\n+\tLinkedTickets []LinkedTicket `json:\"linked_tickets\"`\n+\n+\t// File changes\n+\tFileDiffs []*model.FileDiff       `json:\"file_diffs\"`\n+\tFilesStat map[string]FileDiffInfo `json:\"files_stat\"`\n+\n+\t// Context metadata\n+\tTotalCommits   int `json:\"total_commits\"`\n+\tTotalFiles     int `json:\"total_files\"`\n+\tTotalAdditions int `json:\"total_additions\"`\n+\tTotalDeletions int `json:\"total_deletions\"`\n }\n \n-// SummaryContext provides summary information for the LLM\n-type SummaryContext struct {\n-\tChangesSummary  string         `json:\"changes_summary\"`\n-\tAffectedAreas   []string       `json:\"affected_areas\"`\n-\tReviewFocus     []string       `json:\"review_focus\"`\n-\tRiskAssessment  RiskAssessment `json:\"risk_assessment\"`\n-\tRecommendations []string       `json:\"recommendations\"`\n+type FileDiffInfo struct {\n+\tTotalAdditions int `json:\"total_additions\"`\n+\tTotalDeletions int `json:\"total_deletions\"`\n }\n \n-// MetadataContext provides metadata about the analysis\n-type MetadataContext struct {\n-\tAnalysisTimestamp  string   `json:\"analysis_timestamp\"`\n-\tAnalysisVersion    string   `json:\"analysis_version\"`\n-\tSupportedLanguages []string `json:\"supported_languages\"`\n-\tLimitations        []string `json:\"limitations\"`\n+// CommitInfo contains detailed commit information\n+type CommitInfo struct {\n+\tSHA         string                      `json:\"sha\"`\n+\tSubject     string                      `json:\"subject\"`\n+\tBody        string                      `json:\"body\"`\n+\tAuthor      string                      `json:\"author\"`\n+\tTimestamp   time.Time                   `json:\"timestamp\"`\n+\tFileChanges map[string]CommitFileChange `json:\"file_changes\"`\n+\tTotalFiles  int                         `json:\"total_files\"`\n }\n \n-// ConfigChangeInfo represents information about configuration changes\n-type ConfigChangeInfo struct {\n-\tFilePath      string   `json:\"file_path\"`\n-\tConfigType    string   `json:\"config_type\"`\n-\tChangedKeys   []string `json:\"changed_keys\"`\n-\tImpact        string   `json:\"impact\"`\n-\tAffectedFiles []string `json:\"affected_files\"`\n+// CommitFileChange represents file changes in a specific commit\n+type CommitFileChange struct {\n+\tStatus    string `json:\"status\"`    // added, modified, deleted, renamed\n+\tAdditions int    `json:\"additions\"` // lines added in this file\n+\tDeletions int    `json:\"deletions\"` // lines deleted in this file\n+\tOldPath   string `json:\"old_path\"`  // for renamed files\n+\tNewPath   string `json:\"new_path\"`  // current file path\n+\tIsBinary  bool   `json:\"is_binary\"` // whether file is binary\n }\n \n-// DeletedSymbolInfo represents information about deleted symbols\n-type DeletedSymbolInfo struct {\n-\tSymbol           astparser.AffectedSymbol `json:\"symbol\"`\n-\tBrokenReferences []astparser.RelatedFile  `json:\"broken_references\"`\n-\tImpact           string                   `json:\"impact\"`\n+// LinkedIssue represents a linked GitHub/GitLab issue\n+type LinkedIssue struct {\n+\tID          string   `json:\"id\"`\n+\tNumber      int      `json:\"number\"`\n+\tTitle       string   `json:\"title\"`\n+\tDescription string   `json:\"description\"`\n+\tState       string   `json:\"state\"`\n+\tURL         string   `json:\"url\"`\n+\tLabels      []string `json:\"labels\"`\n }\n \n-// RiskAssessment provides risk assessment for the changes\n-type RiskAssessment struct {\n-\tLevel       RiskLevel `json:\"level\"`\n-\tScore       float64   `json:\"score\"`\n-\tFactors     []string  `json:\"factors\"`\n-\tMitigations []string  `json:\"mitigations\"`\n+// LinkedTicket represents a linked Jira/external ticket\n+type LinkedTicket struct {\n+\tID          string `json:\"id\"`\n+\tKey         string `json:\"key\"`\n+\tTitle       string `json:\"title\"`\n+\tDescription string `json:\"description\"`\n+\tStatus      string `json:\"status\"`\n+\tURL         string `json:\"url\"`\n+\tType        string `json:\"type\"`\n }\n \n-// RiskLevel represents the risk level of changes\n-type RiskLevel string\n+// BuildContextSummary creates a structured summary of the MR context for use in prompts\n+func (mrContext *MRContext) BuildContextSummary() string {\n+\tvar summary strings.Builder\n+\tsummary.Grow(2000) // Pre-allocate reasonable capacity\n \n-const (\n-\tRiskLevelLow      RiskLevel = \"low\"\n-\tRiskLevelMedium   RiskLevel = \"medium\"\n-\tRiskLevelHigh     RiskLevel = \"high\"\n-\tRiskLevelCritical RiskLevel = \"critical\"\n-)\n+\tsummary.WriteString(\"# MERGE REQUEST CONTEXT\\n\\n\")\n+\n+\t// Basic MR information\n+\tsummary.WriteString(\"## Basic Information\\n\")\n+\tsummary.WriteString(\"- Title: \")\n+\tsummary.WriteString(mrContext.Title)\n+\tsummary.WriteString(\"\\n- Branch: `\")\n+\tsummary.WriteString(mrContext.BranchName)\n+\tsummary.WriteString(\"`\\n- Author: \")\n+\tsummary.WriteString(mrContext.Author.Name)\n+\tsummary.WriteString(\" (@\")\n+\tsummary.WriteString(mrContext.Author.Username)\n+\tsummary.WriteString(\")\\n\")\n+\n+\t// Original description (filtered from AI content)\n+\tif mrContext.Description != \"\" {\n+\t\tsummary.WriteString(\"- Original Description:\\n```\\n\")\n+\t\tsummary.WriteString(mrContext.Description)\n+\t\tsummary.WriteString(\"\\n```\\n\")\n+\t}\n+\n+\t// Statistics\n+\tsummary.WriteString(\"\\n## Change Statistics\\n\")\n+\tsummary.WriteString(\"Total Changes: +\")\n+\tsummary.WriteString(intToString(mrContext.TotalAdditions))\n+\tsummary.WriteString(\" additions, -\")\n+\tsummary.WriteString(intToString(mrContext.TotalDeletions))\n+\tsummary.WriteString(\" deletions across \")\n+\tsummary.WriteString(intToString(mrContext.TotalFiles))\n+\tsummary.WriteString(\" files\\n\")\n+\n+\t// Show top changed files\n+\tmostChanged := mrContext.getMostChangedFiles(5)\n+\tif len(mostChanged) \u003e 0 {\n+\t\tsummary.WriteString(\"Most Changed Files:\\n\")\n+\t\tfor _, file := range mostChanged {\n+\t\t\tsummary.WriteString(\"  - \")\n+\t\t\tsummary.WriteString(file.FilePath)\n+\t\t\tsummary.WriteString(\": +\")\n+\t\t\tsummary.WriteString(intToString(file.Additions))\n+\t\t\tsummary.WriteString(\", -\")\n+\t\t\tsummary.WriteString(intToString(file.Deletions))\n+\t\t\tsummary.WriteString(\" (\")\n+\t\t\tsummary.WriteString(intToString(file.TotalChanges))\n+\t\t\tsummary.WriteString(\" total)\\n\")\n+\t\t}\n+\t}\n+\tsummary.WriteString(\"\\n## Commits: \")\n+\tsummary.WriteString(intToString(mrContext.TotalCommits))\n+\tsummary.WriteString(\" commits\\n\")\n+\tfor i, commit := range mrContext.Commits {\n+\t\t// Commit header with short SHA\n+\t\tsummary.WriteString(fmt.Sprintf(\"%d. \", i+1))\n+\t\tsummary.WriteString(commit.Subject)\n+\t\tsummary.WriteString(\" (@\") // Author\n+\t\tsummary.WriteString(commit.Author)\n+\t\tsummary.WriteString(\")\\nTime: \")\n+\t\tsummary.WriteString(commit.Timestamp.Format(time.RFC3339))\n+\t\tsummary.WriteString(\"\\nFiles: \")\n+\t\tsummary.WriteString(intToString(commit.TotalFiles))\n+\t\tsummary.WriteString(\"\\n\")\n+\n+\t\t// File changes in this commit\n+\t\tif len(commit.FileChanges) \u003e 0 {\n+\t\t\tfor _, change := range sortByTotalChanges(commit.FileChanges) {\n+\t\t\t\tfilePath := change.NewPath\n+\t\t\t\tif filePath == \"\" {\n+\t\t\t\t\tfilePath = change.OldPath\n+\t\t\t\t}\n+\n+\t\t\t\tsummary.WriteString(\"  - \")\n+\t\t\t\tsummary.WriteString(filePath)\n+\t\t\t\tsummary.WriteString(\": [\")\n+\t\t\t\tsummary.WriteString(change.Status)\n+\t\t\t\tsummary.WriteString(\"]: +\")\n+\t\t\t\tsummary.WriteString(intToString(change.Additions))\n+\t\t\t\tsummary.WriteString(\", -\")\n+\t\t\t\tsummary.WriteString(intToString(change.Deletions))\n+\n+\t\t\t\t// Show rename information\n+\t\t\t\tif change.Status == \"renamed\" \u0026\u0026 change.OldPath != \"\" \u0026\u0026 change.OldPath != change.NewPath {\n+\t\t\t\t\tsummary.WriteString(\" (from \")\n+\t\t\t\t\tsummary.WriteString(change.OldPath)\n+\t\t\t\t\tsummary.WriteString(\")\")\n+\t\t\t\t}\n+\n+\t\t\t\t// Binary file indicator\n+\t\t\t\tif change.IsBinary {\n+\t\t\t\t\tsummary.WriteString(\" [binary]\")\n+\t\t\t\t}\n+\n+\t\t\t\tsummary.WriteString(\"\\n\")\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Commit body if available and not too long\n+\t\tif commit.Body != \"\" \u0026\u0026 len(commit.Body) \u003c= 200 {\n+\t\t\tsummary.WriteString(\"  Description: \")\n+\t\t\tsummary.WriteString(commit.Body)\n+\t\t\tsummary.WriteString(\"\\n\")\n+\t\t} else if commit.Body != \"\" {\n+\t\t\tsummary.WriteString(\"  Description: \")\n+\t\t\tsummary.WriteString(commit.Body[:197])\n+\t\t\tsummary.WriteString(\"...\\n\")\n+\t\t}\n+\n+\t\tsummary.WriteString(\"\\n\")\n+\t}\n+\n+\t// Linked issues and tickets\n+\tif len(mrContext.LinkedIssues) \u003e 0 || len(mrContext.LinkedTickets) \u003e 0 {\n+\t\tsummary.WriteString(\"\\n## Linked References\\n\")\n+\n+\t\tif len(mrContext.LinkedIssues) \u003e 0 {\n+\t\t\tsummary.WriteString(\"- Issues: \")\n+\t\t\tfor i, issue := range mrContext.LinkedIssues {\n+\t\t\t\tif i \u003e 0 {\n+\t\t\t\t\tsummary.WriteString(\", \")\n+\t\t\t\t}\n+\t\t\t\tsummary.WriteString(\"#\")\n+\t\t\t\tsummary.WriteString(intToString(issue.Number))\n+\t\t\t}\n+\t\t\tsummary.WriteString(\"\\n\")\n+\t\t}\n+\n+\t\tif len(mrContext.LinkedTickets) \u003e 0 {\n+\t\t\tsummary.WriteString(\"- Tickets: \")\n+\t\t\tfor i, ticket := range mrContext.LinkedTickets {\n+\t\t\t\tif i \u003e 0 {\n+\t\t\t\t\tsummary.WriteString(\", \")\n+\t\t\t\t}\n+\t\t\t\tsummary.WriteString(ticket.Key)\n+\t\t\t}\n+\t\t\tsummary.WriteString(\"\\n\")\n+\t\t}\n+\t}\n+\n+\t// Author comments (provide context about author's intentions)\n+\tif len(mrContext.AuthorComments) \u003e 0 {\n+\t\tsummary.WriteString(\"\\n## Author Comments \u0026 Context\\n\")\n+\t\tfor i, comment := range mrContext.AuthorComments {\n+\t\t\tif i \u003e= 3 {\n+\t\t\t\tsummary.WriteString(\"- ... and \")\n+\t\t\t\tsummary.WriteString(intToString(len(mrContext.AuthorComments) - 3))\n+\t\t\t\tsummary.WriteString(\" more comments\\n\")\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tsummary.WriteString(\"- \")\n+\t\t\t// Truncate long comments\n+\t\t\tcommentBody := comment.Body\n+\t\t\tif len(commentBody) \u003e 150 {\n+\t\t\t\tcommentBody = commentBody[:150] + \"...\"\n+\t\t\t}\n+\t\t\tsummary.WriteString(commentBody)\n+\t\t\tsummary.WriteString(\"\\n\")\n+\t\t}\n+\t}\n+\n+\treturn summary.String()\n+}",
      "affected_symbols": [
        {
          "symbol_name": "Files",
          "symbol_type": "variable",
          "full_code": "\tFiles     []*astparser.FileContext `json:\"files\"`",
          "doc_comment": "",
          "context": {
            "package": "llmcontext",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": null,
          "file_path": "internal/reviewer/llmcontext/context.go",
          "start_line": 14,
          "end_line": 14
        },
        {
          "symbol_name": "Files",
          "symbol_type": "struct",
          "full_code": "type ContextBundle struct {\n\tFiles     []*astparser.FileContext `json:\"files\"`\n\tMRContext *MRContext               `json:\"mr_context\"`\n}",
          "doc_comment": "// ContextBundle represents the final structured context for LLM",
          "context": {
            "package": "llmcontext",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "Files",
              "snippet": "Files     []*astparser.FileContext `json:\"files\"`",
              "line": 14,
              "type": "variable",
              "source_file": "external",
              "source_code": "// Files() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "MRContext",
              "snippet": "MRContext *MRContext               `json:\"mr_context\"`",
              "line": 15,
              "type": "variable",
              "source_file": "external",
              "source_code": "// MRContext() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/llmcontext/context.go",
          "start_line": 13,
          "end_line": 16
        },
        {
          "symbol_name": "MRContext",
          "symbol_type": "type",
          "full_code": "type MRContext struct {\n\t// Basic MR information\n\tTitle       string    `json:\"title\"`\n\tDescription string    `json:\"description\"`\n\tBranchName  string    `json:\"branch_name\"`\n\tCreatedAt   time.Time `json:\"created_at\"`\n\tUpdatedAt   time.Time `json:\"updated_at\"`\n\n\t// Author information\n\tAuthor         model.User       `json:\"author\"`\n\tAuthorComments []*model.Comment `json:\"author_comments\"`\n\n\t// Commit information\n\tCommits []CommitInfo `json:\"commits\"`\n\n\t// Issue/ticket links\n\tLinkedIssues  []LinkedIssue  `json:\"linked_issues\"`\n\tLinkedTickets []LinkedTicket `json:\"linked_tickets\"`\n\n\t// File changes\n\tFileDiffs []*model.FileDiff       `json:\"file_diffs\"`\n\tFilesStat map[string]FileDiffInfo `json:\"files_stat\"`\n\n\t// Context metadata\n\tTotalCommits   int `json:\"total_commits\"`\n\tTotalFiles     int `json:\"total_files\"`\n\tTotalAdditions int `json:\"total_additions\"`\n\tTotalDeletions int `json:\"total_deletions\"`\n}",
          "doc_comment": "// MRContext holds comprehensive metadata about a merge request",
          "context": {
            "package": "llmcontext",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "Title",
              "snippet": "Title       string    `json:\"title\"`",
              "line": 21,
              "type": "variable",
              "source_file": "external",
              "source_code": "// Title() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "Description",
              "snippet": "Description string    `json:\"description\"`",
              "line": 22,
              "type": "variable",
              "source_file": "external",
              "source_code": "// Description() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "CreatedAt",
              "snippet": "CreatedAt   time.Time `json:\"created_at\"`",
              "line": 24,
              "type": "variable",
              "source_file": "external",
              "source_code": "// CreatedAt() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "UpdatedAt",
              "snippet": "UpdatedAt   time.Time `json:\"updated_at\"`",
              "line": 25,
              "type": "variable",
              "source_file": "external",
              "source_code": "// UpdatedAt() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "Author",
              "snippet": "Author         model.User       `json:\"author\"`",
              "line": 28,
              "type": "variable",
              "source_file": "external",
              "source_code": "// Author() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "Commits",
              "snippet": "Commits []CommitInfo `json:\"commits\"`",
              "line": 32,
              "type": "variable",
              "source_file": "external",
              "source_code": "// Commits() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "LinkedIssues",
              "snippet": "LinkedIssues  []LinkedIssue  `json:\"linked_issues\"`",
              "line": 35,
              "type": "variable",
              "source_file": "external",
              "source_code": "// LinkedIssues() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "LinkedTickets",
              "snippet": "LinkedTickets []LinkedTicket `json:\"linked_tickets\"`",
              "line": 36,
              "type": "variable",
              "source_file": "external",
              "source_code": "// LinkedTickets() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "FileDiffs",
              "snippet": "FileDiffs []*model.FileDiff       `json:\"file_diffs\"`",
              "line": 39,
              "type": "variable",
              "source_file": "external",
              "source_code": "// FileDiffs() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "FilesStat",
              "snippet": "FilesStat map[string]FileDiffInfo `json:\"files_stat\"`",
              "line": 40,
              "type": "variable",
              "source_file": "external",
              "source_code": "// FilesStat() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "TotalCommits",
              "snippet": "TotalCommits   int `json:\"total_commits\"`",
              "line": 43,
              "type": "variable",
              "source_file": "external",
              "source_code": "// TotalCommits() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "TotalFiles",
              "snippet": "TotalFiles     int `json:\"total_files\"`",
              "line": 44,
              "type": "variable",
              "source_file": "external",
              "source_code": "// TotalFiles() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "TotalAdditions",
              "snippet": "TotalAdditions int `json:\"total_additions\"`",
              "line": 45,
              "type": "variable",
              "source_file": "external",
              "source_code": "// TotalAdditions() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "TotalDeletions",
              "snippet": "TotalDeletions int `json:\"total_deletions\"`",
              "line": 46,
              "type": "variable",
              "source_file": "external",
              "source_code": "// TotalDeletions() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/llmcontext/context.go",
          "start_line": 19,
          "end_line": 47
        },
        {
          "symbol_name": "Title",
          "symbol_type": "struct",
          "full_code": "type MRContext struct {\n\t// Basic MR information\n\tTitle       string    `json:\"title\"`\n\tDescription string    `json:\"description\"`\n\tBranchName  string    `json:\"branch_name\"`\n\tCreatedAt   time.Time `json:\"created_at\"`\n\tUpdatedAt   time.Time `json:\"updated_at\"`\n\n\t// Author information\n\tAuthor         model.User       `json:\"author\"`\n\tAuthorComments []*model.Comment `json:\"author_comments\"`\n\n\t// Commit information\n\tCommits []CommitInfo `json:\"commits\"`\n\n\t// Issue/ticket links\n\tLinkedIssues  []LinkedIssue  `json:\"linked_issues\"`\n\tLinkedTickets []LinkedTicket `json:\"linked_tickets\"`\n\n\t// File changes\n\tFileDiffs []*model.FileDiff       `json:\"file_diffs\"`\n\tFilesStat map[string]FileDiffInfo `json:\"files_stat\"`\n\n\t// Context metadata\n\tTotalCommits   int `json:\"total_commits\"`\n\tTotalFiles     int `json:\"total_files\"`\n\tTotalAdditions int `json:\"total_additions\"`\n\tTotalDeletions int `json:\"total_deletions\"`\n}",
          "doc_comment": "// MRContext holds comprehensive metadata about a merge request",
          "context": {
            "package": "llmcontext",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "Title",
              "snippet": "Title       string    `json:\"title\"`",
              "line": 21,
              "type": "variable",
              "source_file": "external",
              "source_code": "// Title() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "Description",
              "snippet": "Description string    `json:\"description\"`",
              "line": 22,
              "type": "variable",
              "source_file": "external",
              "source_code": "// Description() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "CreatedAt",
              "snippet": "CreatedAt   time.Time `json:\"created_at\"`",
              "line": 24,
              "type": "variable",
              "source_file": "external",
              "source_code": "// CreatedAt() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "UpdatedAt",
              "snippet": "UpdatedAt   time.Time `json:\"updated_at\"`",
              "line": 25,
              "type": "variable",
              "source_file": "external",
              "source_code": "// UpdatedAt() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "Author",
              "snippet": "Author         model.User       `json:\"author\"`",
              "line": 28,
              "type": "variable",
              "source_file": "external",
              "source_code": "// Author() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "Commits",
              "snippet": "Commits []CommitInfo `json:\"commits\"`",
              "line": 32,
              "type": "variable",
              "source_file": "external",
              "source_code": "// Commits() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "LinkedIssues",
              "snippet": "LinkedIssues  []LinkedIssue  `json:\"linked_issues\"`",
              "line": 35,
              "type": "variable",
              "source_file": "external",
              "source_code": "// LinkedIssues() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "LinkedTickets",
              "snippet": "LinkedTickets []LinkedTicket `json:\"linked_tickets\"`",
              "line": 36,
              "type": "variable",
              "source_file": "external",
              "source_code": "// LinkedTickets() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "FileDiffs",
              "snippet": "FileDiffs []*model.FileDiff       `json:\"file_diffs\"`",
              "line": 39,
              "type": "variable",
              "source_file": "external",
              "source_code": "// FileDiffs() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "FilesStat",
              "snippet": "FilesStat map[string]FileDiffInfo `json:\"files_stat\"`",
              "line": 40,
              "type": "variable",
              "source_file": "external",
              "source_code": "// FilesStat() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "TotalCommits",
              "snippet": "TotalCommits   int `json:\"total_commits\"`",
              "line": 43,
              "type": "variable",
              "source_file": "external",
              "source_code": "// TotalCommits() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "TotalFiles",
              "snippet": "TotalFiles     int `json:\"total_files\"`",
              "line": 44,
              "type": "variable",
              "source_file": "external",
              "source_code": "// TotalFiles() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "TotalAdditions",
              "snippet": "TotalAdditions int `json:\"total_additions\"`",
              "line": 45,
              "type": "variable",
              "source_file": "external",
              "source_code": "// TotalAdditions() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "TotalDeletions",
              "snippet": "TotalDeletions int `json:\"total_deletions\"`",
              "line": 46,
              "type": "variable",
              "source_file": "external",
              "source_code": "// TotalDeletions() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/llmcontext/context.go",
          "start_line": 19,
          "end_line": 47
        },
        {
          "symbol_name": "Title",
          "symbol_type": "variable",
          "full_code": "\tTitle       string    `json:\"title\"`",
          "doc_comment": "// Basic MR information",
          "context": {
            "package": "llmcontext",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": null,
          "file_path": "internal/reviewer/llmcontext/context.go",
          "start_line": 21,
          "end_line": 21
        },
        {
          "symbol_name": "Author",
          "symbol_type": "variable",
          "full_code": "\tAuthor         model.User       `json:\"author\"`",
          "doc_comment": "// Author information",
          "context": {
            "package": "llmcontext",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": null,
          "file_path": "internal/reviewer/llmcontext/context.go",
          "start_line": 28,
          "end_line": 28
        },
        {
          "symbol_name": "Commits",
          "symbol_type": "variable",
          "full_code": "\tCommits []CommitInfo `json:\"commits\"`",
          "doc_comment": "// Commit information",
          "context": {
            "package": "llmcontext",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": null,
          "file_path": "internal/reviewer/llmcontext/context.go",
          "start_line": 32,
          "end_line": 32
        },
        {
          "symbol_name": "LinkedIssues",
          "symbol_type": "variable",
          "full_code": "\tLinkedIssues  []LinkedIssue  `json:\"linked_issues\"`",
          "doc_comment": "// Issue/ticket links",
          "context": {
            "package": "llmcontext",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": null,
          "file_path": "internal/reviewer/llmcontext/context.go",
          "start_line": 35,
          "end_line": 35
        },
        {
          "symbol_name": "FileDiffs",
          "symbol_type": "variable",
          "full_code": "\tFileDiffs []*model.FileDiff       `json:\"file_diffs\"`",
          "doc_comment": "// File changes",
          "context": {
            "package": "llmcontext",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": null,
          "file_path": "internal/reviewer/llmcontext/context.go",
          "start_line": 39,
          "end_line": 39
        },
        {
          "symbol_name": "TotalCommits",
          "symbol_type": "variable",
          "full_code": "\tTotalCommits   int `json:\"total_commits\"`",
          "doc_comment": "// Context metadata",
          "context": {
            "package": "llmcontext",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": null,
          "file_path": "internal/reviewer/llmcontext/context.go",
          "start_line": 43,
          "end_line": 43
        },
        {
          "symbol_name": "TotalAdditions",
          "symbol_type": "variable",
          "full_code": "\tTotalAdditions int `json:\"total_additions\"`",
          "doc_comment": "",
          "context": {
            "package": "llmcontext",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": null,
          "file_path": "internal/reviewer/llmcontext/context.go",
          "start_line": 50,
          "end_line": 50
        },
        {
          "symbol_name": "TotalAdditions",
          "symbol_type": "struct",
          "full_code": "type FileDiffInfo struct {\n\tTotalAdditions int `json:\"total_additions\"`\n\tTotalDeletions int `json:\"total_deletions\"`\n}",
          "doc_comment": "",
          "context": {
            "package": "llmcontext",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "TotalAdditions",
              "snippet": "TotalAdditions int `json:\"total_additions\"`",
              "line": 50,
              "type": "variable",
              "source_file": "external",
              "source_code": "// TotalAdditions() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "TotalDeletions",
              "snippet": "TotalDeletions int `json:\"total_deletions\"`",
              "line": 51,
              "type": "variable",
              "source_file": "external",
              "source_code": "// TotalDeletions() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/llmcontext/context.go",
          "start_line": 49,
          "end_line": 52
        },
        {
          "symbol_name": "CommitInfo",
          "symbol_type": "type",
          "full_code": "type CommitInfo struct {\n\tSHA         string                      `json:\"sha\"`\n\tSubject     string                      `json:\"subject\"`\n\tBody        string                      `json:\"body\"`\n\tAuthor      string                      `json:\"author\"`\n\tTimestamp   time.Time                   `json:\"timestamp\"`\n\tFileChanges map[string]CommitFileChange `json:\"file_changes\"`\n\tTotalFiles  int                         `json:\"total_files\"`\n}",
          "doc_comment": "// CommitInfo contains detailed commit information",
          "context": {
            "package": "llmcontext",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "SHA",
              "snippet": "SHA         string                      `json:\"sha\"`",
              "line": 56,
              "type": "variable",
              "source_file": "external",
              "source_code": "// SHA() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "Subject",
              "snippet": "Subject     string                      `json:\"subject\"`",
              "line": 57,
              "type": "variable",
              "source_file": "external",
              "source_code": "// Subject() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "Body",
              "snippet": "Body        string                      `json:\"body\"`",
              "line": 58,
              "type": "variable",
              "source_file": "external",
              "source_code": "// Body() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "Author",
              "snippet": "Author      string                      `json:\"author\"`",
              "line": 59,
              "type": "variable",
              "source_file": "external",
              "source_code": "// Author() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "FileChanges",
              "snippet": "FileChanges map[string]CommitFileChange `json:\"file_changes\"`",
              "line": 61,
              "type": "variable",
              "source_file": "external",
              "source_code": "// FileChanges() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "TotalFiles",
              "snippet": "TotalFiles  int                         `json:\"total_files\"`",
              "line": 62,
              "type": "variable",
              "source_file": "external",
              "source_code": "// TotalFiles() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/llmcontext/context.go",
          "start_line": 55,
          "end_line": 63
        },
        {
          "symbol_name": "SHA",
          "symbol_type": "variable",
          "full_code": "\tSHA         string                      `json:\"sha\"`",
          "doc_comment": "",
          "context": {
            "package": "llmcontext",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": null,
          "file_path": "internal/reviewer/llmcontext/context.go",
          "start_line": 56,
          "end_line": 56
        },
        {
          "symbol_name": "SHA",
          "symbol_type": "struct",
          "full_code": "type CommitInfo struct {\n\tSHA         string                      `json:\"sha\"`\n\tSubject     string                      `json:\"subject\"`\n\tBody        string                      `json:\"body\"`\n\tAuthor      string                      `json:\"author\"`\n\tTimestamp   time.Time                   `json:\"timestamp\"`\n\tFileChanges map[string]CommitFileChange `json:\"file_changes\"`\n\tTotalFiles  int                         `json:\"total_files\"`\n}",
          "doc_comment": "// CommitInfo contains detailed commit information",
          "context": {
            "package": "llmcontext",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "SHA",
              "snippet": "SHA         string                      `json:\"sha\"`",
              "line": 56,
              "type": "variable",
              "source_file": "external",
              "source_code": "// SHA() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "Subject",
              "snippet": "Subject     string                      `json:\"subject\"`",
              "line": 57,
              "type": "variable",
              "source_file": "external",
              "source_code": "// Subject() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "Body",
              "snippet": "Body        string                      `json:\"body\"`",
              "line": 58,
              "type": "variable",
              "source_file": "external",
              "source_code": "// Body() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "Author",
              "snippet": "Author      string                      `json:\"author\"`",
              "line": 59,
              "type": "variable",
              "source_file": "external",
              "source_code": "// Author() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "FileChanges",
              "snippet": "FileChanges map[string]CommitFileChange `json:\"file_changes\"`",
              "line": 61,
              "type": "variable",
              "source_file": "external",
              "source_code": "// FileChanges() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "TotalFiles",
              "snippet": "TotalFiles  int                         `json:\"total_files\"`",
              "line": 62,
              "type": "variable",
              "source_file": "external",
              "source_code": "// TotalFiles() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/llmcontext/context.go",
          "start_line": 55,
          "end_line": 63
        },
        {
          "symbol_name": "CommitFileChange",
          "symbol_type": "type",
          "full_code": "type CommitFileChange struct {\n\tStatus    string `json:\"status\"`    // added, modified, deleted, renamed\n\tAdditions int    `json:\"additions\"` // lines added in this file\n\tDeletions int    `json:\"deletions\"` // lines deleted in this file\n\tOldPath   string `json:\"old_path\"`  // for renamed files\n\tNewPath   string `json:\"new_path\"`  // current file path\n\tIsBinary  bool   `json:\"is_binary\"` // whether file is binary\n}",
          "doc_comment": "// CommitFileChange represents file changes in a specific commit",
          "context": {
            "package": "llmcontext",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "Status",
              "snippet": "Status    string `json:\"status\"`",
              "line": 67,
              "type": "variable",
              "source_file": "external",
              "source_code": "// Status() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "Additions",
              "snippet": "Additions int    `json:\"additions\"`",
              "line": 68,
              "type": "variable",
              "source_file": "external",
              "source_code": "// Additions() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "Deletions",
              "snippet": "Deletions int    `json:\"deletions\"`",
              "line": 69,
              "type": "variable",
              "source_file": "external",
              "source_code": "// Deletions() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "OldPath",
              "snippet": "OldPath   string `json:\"old_path\"`",
              "line": 70,
              "type": "variable",
              "source_file": "external",
              "source_code": "// OldPath() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "NewPath",
              "snippet": "NewPath   string `json:\"new_path\"`",
              "line": 71,
              "type": "variable",
              "source_file": "external",
              "source_code": "// NewPath() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "IsBinary",
              "snippet": "IsBinary  bool   `json:\"is_binary\"`",
              "line": 72,
              "type": "variable",
              "source_file": "external",
              "source_code": "// IsBinary() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/llmcontext/context.go",
          "start_line": 66,
          "end_line": 73
        },
        {
          "symbol_name": "Status",
          "symbol_type": "variable",
          "full_code": "\tStatus    string `json:\"status\"`    // added, modified, deleted, renamed",
          "doc_comment": "",
          "context": {
            "package": "llmcontext",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": null,
          "file_path": "internal/reviewer/llmcontext/context.go",
          "start_line": 67,
          "end_line": 67
        },
        {
          "symbol_name": "Status",
          "symbol_type": "struct",
          "full_code": "type CommitFileChange struct {\n\tStatus    string `json:\"status\"`    // added, modified, deleted, renamed\n\tAdditions int    `json:\"additions\"` // lines added in this file\n\tDeletions int    `json:\"deletions\"` // lines deleted in this file\n\tOldPath   string `json:\"old_path\"`  // for renamed files\n\tNewPath   string `json:\"new_path\"`  // current file path\n\tIsBinary  bool   `json:\"is_binary\"` // whether file is binary\n}",
          "doc_comment": "// CommitFileChange represents file changes in a specific commit",
          "context": {
            "package": "llmcontext",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "Status",
              "snippet": "Status    string `json:\"status\"`",
              "line": 67,
              "type": "variable",
              "source_file": "external",
              "source_code": "// Status() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "Additions",
              "snippet": "Additions int    `json:\"additions\"`",
              "line": 68,
              "type": "variable",
              "source_file": "external",
              "source_code": "// Additions() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "Deletions",
              "snippet": "Deletions int    `json:\"deletions\"`",
              "line": 69,
              "type": "variable",
              "source_file": "external",
              "source_code": "// Deletions() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "OldPath",
              "snippet": "OldPath   string `json:\"old_path\"`",
              "line": 70,
              "type": "variable",
              "source_file": "external",
              "source_code": "// OldPath() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "NewPath",
              "snippet": "NewPath   string `json:\"new_path\"`",
              "line": 71,
              "type": "variable",
              "source_file": "external",
              "source_code": "// NewPath() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "IsBinary",
              "snippet": "IsBinary  bool   `json:\"is_binary\"`",
              "line": 72,
              "type": "variable",
              "source_file": "external",
              "source_code": "// IsBinary() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/llmcontext/context.go",
          "start_line": 66,
          "end_line": 73
        },
        {
          "symbol_name": "LinkedIssue",
          "symbol_type": "type",
          "full_code": "type LinkedIssue struct {\n\tID          string   `json:\"id\"`\n\tNumber      int      `json:\"number\"`\n\tTitle       string   `json:\"title\"`\n\tDescription string   `json:\"description\"`\n\tState       string   `json:\"state\"`\n\tURL         string   `json:\"url\"`\n\tLabels      []string `json:\"labels\"`\n}",
          "doc_comment": "// LinkedIssue represents a linked GitHub/GitLab issue",
          "context": {
            "package": "llmcontext",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "Number",
              "snippet": "Number      int      `json:\"number\"`",
              "line": 78,
              "type": "variable",
              "source_file": "external",
              "source_code": "// Number() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "Title",
              "snippet": "Title       string   `json:\"title\"`",
              "line": 79,
              "type": "variable",
              "source_file": "external",
              "source_code": "// Title() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "Description",
              "snippet": "Description string   `json:\"description\"`",
              "line": 80,
              "type": "variable",
              "source_file": "external",
              "source_code": "// Description() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "State",
              "snippet": "State       string   `json:\"state\"`",
              "line": 81,
              "type": "variable",
              "source_file": "external",
              "source_code": "// State() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "URL",
              "snippet": "URL         string   `json:\"url\"`",
              "line": 82,
              "type": "variable",
              "source_file": "external",
              "source_code": "// URL() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "Labels",
              "snippet": "Labels      []string `json:\"labels\"`",
              "line": 83,
              "type": "variable",
              "source_file": "external",
              "source_code": "// Labels() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/llmcontext/context.go",
          "start_line": 76,
          "end_line": 84
        },
        {
          "symbol_name": "ID",
          "symbol_type": "variable",
          "full_code": "\tID          string   `json:\"id\"`",
          "doc_comment": "",
          "context": {
            "package": "llmcontext",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": null,
          "file_path": "internal/reviewer/llmcontext/context.go",
          "start_line": 77,
          "end_line": 77
        },
        {
          "symbol_name": "ID",
          "symbol_type": "struct",
          "full_code": "type LinkedIssue struct {\n\tID          string   `json:\"id\"`\n\tNumber      int      `json:\"number\"`\n\tTitle       string   `json:\"title\"`\n\tDescription string   `json:\"description\"`\n\tState       string   `json:\"state\"`\n\tURL         string   `json:\"url\"`\n\tLabels      []string `json:\"labels\"`\n}",
          "doc_comment": "// LinkedIssue represents a linked GitHub/GitLab issue",
          "context": {
            "package": "llmcontext",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "Number",
              "snippet": "Number      int      `json:\"number\"`",
              "line": 78,
              "type": "variable",
              "source_file": "external",
              "source_code": "// Number() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "Title",
              "snippet": "Title       string   `json:\"title\"`",
              "line": 79,
              "type": "variable",
              "source_file": "external",
              "source_code": "// Title() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "Description",
              "snippet": "Description string   `json:\"description\"`",
              "line": 80,
              "type": "variable",
              "source_file": "external",
              "source_code": "// Description() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "State",
              "snippet": "State       string   `json:\"state\"`",
              "line": 81,
              "type": "variable",
              "source_file": "external",
              "source_code": "// State() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "URL",
              "snippet": "URL         string   `json:\"url\"`",
              "line": 82,
              "type": "variable",
              "source_file": "external",
              "source_code": "// URL() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "Labels",
              "snippet": "Labels      []string `json:\"labels\"`",
              "line": 83,
              "type": "variable",
              "source_file": "external",
              "source_code": "// Labels() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/llmcontext/context.go",
          "start_line": 76,
          "end_line": 84
        },
        {
          "symbol_name": "LinkedTicket",
          "symbol_type": "type",
          "full_code": "type LinkedTicket struct {\n\tID          string `json:\"id\"`\n\tKey         string `json:\"key\"`\n\tTitle       string `json:\"title\"`\n\tDescription string `json:\"description\"`\n\tStatus      string `json:\"status\"`\n\tURL         string `json:\"url\"`\n\tType        string `json:\"type\"`\n}",
          "doc_comment": "// LinkedTicket represents a linked Jira/external ticket",
          "context": {
            "package": "llmcontext",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "Key",
              "snippet": "Key         string `json:\"key\"`",
              "line": 89,
              "type": "variable",
              "source_file": "external",
              "source_code": "// Key() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "Title",
              "snippet": "Title       string `json:\"title\"`",
              "line": 90,
              "type": "variable",
              "source_file": "external",
              "source_code": "// Title() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "Description",
              "snippet": "Description string `json:\"description\"`",
              "line": 91,
              "type": "variable",
              "source_file": "external",
              "source_code": "// Description() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "Status",
              "snippet": "Status      string `json:\"status\"`",
              "line": 92,
              "type": "variable",
              "source_file": "external",
              "source_code": "// Status() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "URL",
              "snippet": "URL         string `json:\"url\"`",
              "line": 93,
              "type": "variable",
              "source_file": "external",
              "source_code": "// URL() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "Type",
              "snippet": "Type        string `json:\"type\"`",
              "line": 94,
              "type": "variable",
              "source_file": "external",
              "source_code": "// Type() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/llmcontext/context.go",
          "start_line": 87,
          "end_line": 95
        },
        {
          "symbol_name": "BuildContextSummary",
          "symbol_type": "method",
          "full_code": "func (mrContext *MRContext) BuildContextSummary() string {\n\tvar summary strings.Builder\n\tsummary.Grow(2000) // Pre-allocate reasonable capacity\n\n\tsummary.WriteString(\"# MERGE REQUEST CONTEXT\\n\\n\")\n\n\t// Basic MR information\n\tsummary.WriteString(\"## Basic Information\\n\")\n\tsummary.WriteString(\"- Title: \")\n\tsummary.WriteString(mrContext.Title)\n\tsummary.WriteString(\"\\n- Branch: `\")\n\tsummary.WriteString(mrContext.BranchName)\n\tsummary.WriteString(\"`\\n- Author: \")\n\tsummary.WriteString(mrContext.Author.Name)\n\tsummary.WriteString(\" (@\")\n\tsummary.WriteString(mrContext.Author.Username)\n\tsummary.WriteString(\")\\n\")\n\n\t// Original description (filtered from AI content)\n\tif mrContext.Description != \"\" {\n\t\tsummary.WriteString(\"- Original Description:\\n```\\n\")\n\t\tsummary.WriteString(mrContext.Description)\n\t\tsummary.WriteString(\"\\n```\\n\")\n\t}\n\n\t// Statistics\n\tsummary.WriteString(\"\\n## Change Statistics\\n\")\n\tsummary.WriteString(\"Total Changes: +\")\n\tsummary.WriteString(intToString(mrContext.TotalAdditions))\n\tsummary.WriteString(\" additions, -\")\n\tsummary.WriteString(intToString(mrContext.TotalDeletions))\n\tsummary.WriteString(\" deletions across \")\n\tsummary.WriteString(intToString(mrContext.TotalFiles))\n\tsummary.WriteString(\" files\\n\")\n\n\t// Show top changed files\n\tmostChanged := mrContext.getMostChangedFiles(5)\n\tif len(mostChanged) \u003e 0 {\n\t\tsummary.WriteString(\"Most Changed Files:\\n\")\n\t\tfor _, file := range mostChanged {\n\t\t\tsummary.WriteString(\"  - \")\n\t\t\tsummary.WriteString(file.FilePath)\n\t\t\tsummary.WriteString(\": +\")\n\t\t\tsummary.WriteString(intToString(file.Additions))\n\t\t\tsummary.WriteString(\", -\")\n\t\t\tsummary.WriteString(intToString(file.Deletions))\n\t\t\tsummary.WriteString(\" (\")\n\t\t\tsummary.WriteString(intToString(file.TotalChanges))\n\t\t\tsummary.WriteString(\" total)\\n\")\n\t\t}\n\t}\n\tsummary.WriteString(\"\\n## Commits: \")\n\tsummary.WriteString(intToString(mrContext.TotalCommits))\n\tsummary.WriteString(\" commits\\n\")\n\tfor i, commit := range mrContext.Commits {\n\t\t// Commit header with short SHA\n\t\tsummary.WriteString(fmt.Sprintf(\"%d. \", i+1))\n\t\tsummary.WriteString(commit.Subject)\n\t\tsummary.WriteString(\" (@\") // Author\n\t\tsummary.WriteString(commit.Author)\n\t\tsummary.WriteString(\")\\nTime: \")\n\t\tsummary.WriteString(commit.Timestamp.Format(time.RFC3339))\n\t\tsummary.WriteString(\"\\nFiles: \")\n\t\tsummary.WriteString(intToString(commit.TotalFiles))\n\t\tsummary.WriteString(\"\\n\")\n\n\t\t// File changes in this commit\n\t\tif len(commit.FileChanges) \u003e 0 {\n\t\t\tfor _, change := range sortByTotalChanges(commit.FileChanges) {\n\t\t\t\tfilePath := change.NewPath\n\t\t\t\tif filePath == \"\" {\n\t\t\t\t\tfilePath = change.OldPath\n\t\t\t\t}\n\n\t\t\t\tsummary.WriteString(\"  - \")\n\t\t\t\tsummary.WriteString(filePath)\n\t\t\t\tsummary.WriteString(\": [\")\n\t\t\t\tsummary.WriteString(change.Status)\n\t\t\t\tsummary.WriteString(\"]: +\")\n\t\t\t\tsummary.WriteString(intToString(change.Additions))\n\t\t\t\tsummary.WriteString(\", -\")\n\t\t\t\tsummary.WriteString(intToString(change.Deletions))\n\n\t\t\t\t// Show rename information\n\t\t\t\tif change.Status == \"renamed\" \u0026\u0026 change.OldPath != \"\" \u0026\u0026 change.OldPath != change.NewPath {\n\t\t\t\t\tsummary.WriteString(\" (from \")\n\t\t\t\t\tsummary.WriteString(change.OldPath)\n\t\t\t\t\tsummary.WriteString(\")\")\n\t\t\t\t}\n\n\t\t\t\t// Binary file indicator\n\t\t\t\tif change.IsBinary {\n\t\t\t\t\tsummary.WriteString(\" [binary]\")\n\t\t\t\t}\n\n\t\t\t\tsummary.WriteString(\"\\n\")\n\t\t\t}\n\t\t}\n\n\t\t// Commit body if available and not too long\n\t\tif commit.Body != \"\" \u0026\u0026 len(commit.Body) \u003c= 200 {\n\t\t\tsummary.WriteString(\"  Description: \")\n\t\t\tsummary.WriteString(commit.Body)\n\t\t\tsummary.WriteString(\"\\n\")\n\t\t} else if commit.Body != \"\" {\n\t\t\tsummary.WriteString(\"  Description: \")\n\t\t\tsummary.WriteString(commit.Body[:197])\n\t\t\tsummary.WriteString(\"...\\n\")\n\t\t}\n\n\t\tsummary.WriteString(\"\\n\")\n\t}\n\n\t// Linked issues and tickets\n\tif len(mrContext.LinkedIssues) \u003e 0 || len(mrContext.LinkedTickets) \u003e 0 {\n\t\tsummary.WriteString(\"\\n## Linked References\\n\")\n\n\t\tif len(mrContext.LinkedIssues) \u003e 0 {\n\t\t\tsummary.WriteString(\"- Issues: \")\n\t\t\tfor i, issue := range mrContext.LinkedIssues {\n\t\t\t\tif i \u003e 0 {\n\t\t\t\t\tsummary.WriteString(\", \")\n\t\t\t\t}\n\t\t\t\tsummary.WriteString(\"#\")\n\t\t\t\tsummary.WriteString(intToString(issue.Number))\n\t\t\t}\n\t\t\tsummary.WriteString(\"\\n\")\n\t\t}\n\n\t\tif len(mrContext.LinkedTickets) \u003e 0 {\n\t\t\tsummary.WriteString(\"- Tickets: \")\n\t\t\tfor i, ticket := range mrContext.LinkedTickets {\n\t\t\t\tif i \u003e 0 {\n\t\t\t\t\tsummary.WriteString(\", \")\n\t\t\t\t}\n\t\t\t\tsummary.WriteString(ticket.Key)\n\t\t\t}\n\t\t\tsummary.WriteString(\"\\n\")\n\t\t}\n\t}\n\n\t// Author comments (provide context about author's intentions)\n\tif len(mrContext.AuthorComments) \u003e 0 {\n\t\tsummary.WriteString(\"\\n## Author Comments \u0026 Context\\n\")\n\t\tfor i, comment := range mrContext.AuthorComments {\n\t\t\tif i \u003e= 3 {\n\t\t\t\tsummary.WriteString(\"- ... and \")\n\t\t\t\tsummary.WriteString(intToString(len(mrContext.AuthorComments) - 3))\n\t\t\t\tsummary.WriteString(\" more comments\\n\")\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tsummary.WriteString(\"- \")\n\t\t\t// Truncate long comments\n\t\t\tcommentBody := comment.Body\n\t\t\tif len(commentBody) \u003e 150 {\n\t\t\t\tcommentBody = commentBody[:150] + \"...\"\n\t\t\t}\n\t\t\tsummary.WriteString(commentBody)\n\t\t\tsummary.WriteString(\"\\n\")\n\t\t}\n\t}\n\n\treturn summary.String()\n}",
          "doc_comment": "// BuildContextSummary creates a structured summary of the MR context for use in prompts",
          "context": {
            "package": "llmcontext",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "summary.Grow",
              "snippet": "summary.Grow(2000)",
              "line": 100,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.Grow() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(\"# MERGE REQUEST CONTEXT\\n\\n\")",
              "line": 102,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(\"## Basic Information\\n\")",
              "line": 105,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(\"- Title: \")",
              "line": 106,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(mrContext.Title)",
              "line": 107,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(\"\\n- Branch: `\")",
              "line": 108,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(mrContext.BranchName)",
              "line": 109,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(\"`\\n- Author: \")",
              "line": 110,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(mrContext.Author.Name)",
              "line": 111,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(\" (@\")",
              "line": 112,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(mrContext.Author.Username)",
              "line": 113,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(\")\\n\")",
              "line": 114,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(\"- Original Description:\\n```\\n\")",
              "line": 118,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(mrContext.Description)",
              "line": 119,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(\"\\n```\\n\")",
              "line": 120,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(\"\\n## Change Statistics\\n\")",
              "line": 124,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(\"Total Changes: +\")",
              "line": 125,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(intToString(mrContext.TotalAdditions))",
              "line": 126,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(\" additions, -\")",
              "line": 127,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(intToString(mrContext.TotalDeletions))",
              "line": 128,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(\" deletions across \")",
              "line": 129,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(intToString(mrContext.TotalFiles))",
              "line": 130,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(\" files\\n\")",
              "line": 131,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(\"Most Changed Files:\\n\")",
              "line": 136,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(\"  - \")",
              "line": 138,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(file.FilePath)",
              "line": 139,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(\": +\")",
              "line": 140,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(intToString(file.Additions))",
              "line": 141,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(\", -\")",
              "line": 142,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(intToString(file.Deletions))",
              "line": 143,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(\" (\")",
              "line": 144,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(intToString(file.TotalChanges))",
              "line": 145,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(\" total)\\n\")",
              "line": 146,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(\"\\n## Commits: \")",
              "line": 149,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(intToString(mrContext.TotalCommits))",
              "line": 150,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(\" commits\\n\")",
              "line": 151,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(fmt.Sprintf(\"%d. \", i+1))",
              "line": 154,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(commit.Subject)",
              "line": 155,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(\" (@\")",
              "line": 156,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(commit.Author)",
              "line": 157,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(\")\\nTime: \")",
              "line": 158,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(commit.Timestamp.Format(time.RFC3339))",
              "line": 159,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(\"\\nFiles: \")",
              "line": 160,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(intToString(commit.TotalFiles))",
              "line": 161,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(\"\\n\")",
              "line": 162,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "sortByTotalChanges",
              "snippet": "sortByTotalChanges(commit.FileChanges)",
              "line": 166,
              "type": "function",
              "source_file": "external",
              "source_code": "// sortByTotalChanges() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(\"  - \")",
              "line": 172,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(filePath)",
              "line": 173,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(\": [\")",
              "line": 174,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(change.Status)",
              "line": 175,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(\"]: +\")",
              "line": 176,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(intToString(change.Additions))",
              "line": 177,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(\", -\")",
              "line": 178,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(intToString(change.Deletions))",
              "line": 179,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(\" (from \")",
              "line": 183,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(change.OldPath)",
              "line": 184,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(\")\")",
              "line": 185,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(\" [binary]\")",
              "line": 190,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(\"\\n\")",
              "line": 193,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(\"  Description: \")",
              "line": 199,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(commit.Body)",
              "line": 200,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(\"\\n\")",
              "line": 201,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(\"  Description: \")",
              "line": 203,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(commit.Body[:197])",
              "line": 204,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(\"...\\n\")",
              "line": 205,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(\"\\n\")",
              "line": 208,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(\"\\n## Linked References\\n\")",
              "line": 213,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(\"- Issues: \")",
              "line": 216,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(\", \")",
              "line": 219,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(\"#\")",
              "line": 221,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(intToString(issue.Number))",
              "line": 222,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(\"\\n\")",
              "line": 224,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(\"- Tickets: \")",
              "line": 228,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(\", \")",
              "line": 231,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(ticket.Key)",
              "line": 233,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(\"\\n\")",
              "line": 235,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(\"\\n## Author Comments \u0026 Context\\n\")",
              "line": 241,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(\"- ... and \")",
              "line": 244,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(intToString(len(mrContext.AuthorComments) - 3))",
              "line": 245,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(\" more comments\\n\")",
              "line": 246,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(\"- \")",
              "line": 249,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(commentBody)",
              "line": 255,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.WriteString",
              "snippet": "summary.WriteString(\"\\n\")",
              "line": 256,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "summary.String",
              "snippet": "summary.String()",
              "line": 260,
              "type": "function",
              "source_file": "external",
              "source_code": "// summary.String() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/llmcontext/context.go",
          "start_line": 98,
          "end_line": 261
        },
        {
          "symbol_name": "summary",
          "symbol_type": "variable",
          "full_code": "\tvar summary strings.Builder",
          "doc_comment": "",
          "context": {
            "package": "llmcontext",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": null,
          "file_path": "internal/reviewer/llmcontext/context.go",
          "start_line": 99,
          "end_line": 99
        }
      ],
      "related_files": []
    },
    {
      "file_path": "internal/reviewer/llmcontext/mr_context.go",
      "change_type": "Modified",
      "diff": "@@ -1,264 +1,15 @@\n package llmcontext\n \n import (\n-\t\"context\"\n \t\"fmt\"\n \t\"regexp\"\n \t\"sort\"\n \t\"strings\"\n-\t\"time\"\n \n \t\"github.com/maxbolgarin/codry/internal/model\"\n-\t\"github.com/maxbolgarin/codry/internal/model/interfaces\"\n-\t\"github.com/maxbolgarin/errm\"\n \t\"github.com/maxbolgarin/logze/v2\"\n )\n \n-// MRContext holds comprehensive metadata about a merge request\n-type MRContext struct {\n-\t// Basic MR information\n-\tTitle       string    `json:\"title\"`\n-\tDescription string    `json:\"description\"`\n-\tBranchName  string    `json:\"branch_name\"`\n-\tCreatedAt   time.Time `json:\"created_at\"`\n-\tUpdatedAt   time.Time `json:\"updated_at\"`\n-\n-\t// Author information\n-\tAuthor         model.User       `json:\"author\"`\n-\tAuthorComments []*model.Comment `json:\"author_comments\"`\n-\n-\t// Commit information\n-\tCommits []CommitInfo `json:\"commits\"`\n-\n-\t// Issue/ticket links\n-\tLinkedIssues  []LinkedIssue  `json:\"linked_issues\"`\n-\tLinkedTickets []LinkedTicket `json:\"linked_tickets\"`\n-\n-\t// File changes\n-\tFileDiffs []*model.FileDiff       `json:\"file_diffs\"`\n-\tFilesStat map[string]FileDiffInfo `json:\"files_stat\"`\n-\n-\t// Context metadata\n-\tTotalCommits   int `json:\"total_commits\"`\n-\tTotalFiles     int `json:\"total_files\"`\n-\tTotalAdditions int `json:\"total_additions\"`\n-\tTotalDeletions int `json:\"total_deletions\"`\n-}\n-\n-type FileDiffInfo struct {\n-\tTotalAdditions int `json:\"total_additions\"`\n-\tTotalDeletions int `json:\"total_deletions\"`\n-}\n-\n-// CommitInfo contains detailed commit information\n-type CommitInfo struct {\n-\tSHA         string                      `json:\"sha\"`\n-\tSubject     string                      `json:\"subject\"`\n-\tBody        string                      `json:\"body\"`\n-\tAuthor      string                      `json:\"author\"`\n-\tTimestamp   time.Time                   `json:\"timestamp\"`\n-\tFileChanges map[string]CommitFileChange `json:\"file_changes\"`\n-\tTotalFiles  int                         `json:\"total_files\"`\n-}\n-\n-// CommitFileChange represents file changes in a specific commit\n-type CommitFileChange struct {\n-\tStatus    string `json:\"status\"`    // added, modified, deleted, renamed\n-\tAdditions int    `json:\"additions\"` // lines added in this file\n-\tDeletions int    `json:\"deletions\"` // lines deleted in this file\n-\tOldPath   string `json:\"old_path\"`  // for renamed files\n-\tNewPath   string `json:\"new_path\"`  // current file path\n-\tIsBinary  bool   `json:\"is_binary\"` // whether file is binary\n-}\n-\n-// LinkedIssue represents a linked GitHub/GitLab issue\n-type LinkedIssue struct {\n-\tID          string   `json:\"id\"`\n-\tNumber      int      `json:\"number\"`\n-\tTitle       string   `json:\"title\"`\n-\tDescription string   `json:\"description\"`\n-\tState       string   `json:\"state\"`\n-\tURL         string   `json:\"url\"`\n-\tLabels      []string `json:\"labels\"`\n-}\n-\n-// LinkedTicket represents a linked Jira/external ticket\n-type LinkedTicket struct {\n-\tID          string `json:\"id\"`\n-\tKey         string `json:\"key\"`\n-\tTitle       string `json:\"title\"`\n-\tDescription string `json:\"description\"`\n-\tStatus      string `json:\"status\"`\n-\tURL         string `json:\"url\"`\n-\tType        string `json:\"type\"`\n-}\n-\n-// BuildContextSummary creates a structured summary of the MR context for use in prompts\n-func (mrContext *MRContext) BuildContextSummary() string {\n-\tvar summary strings.Builder\n-\tsummary.Grow(2000) // Pre-allocate reasonable capacity\n-\n-\tsummary.WriteString(\"# MERGE REQUEST CONTEXT\\n\\n\")\n-\n-\t// Basic MR information\n-\tsummary.WriteString(\"## Basic Information\\n\")\n-\tsummary.WriteString(\"- Title: \")\n-\tsummary.WriteString(mrContext.Title)\n-\tsummary.WriteString(\"\\n- Branch: `\")\n-\tsummary.WriteString(mrContext.BranchName)\n-\tsummary.WriteString(\"`\\n- Author: \")\n-\tsummary.WriteString(mrContext.Author.Name)\n-\tsummary.WriteString(\" (@\")\n-\tsummary.WriteString(mrContext.Author.Username)\n-\tsummary.WriteString(\")\\n\")\n-\n-\t// Original description (filtered from AI content)\n-\tif mrContext.Description != \"\" {\n-\t\tsummary.WriteString(\"- Original Description:\\n```\\n\")\n-\t\tsummary.WriteString(mrContext.Description)\n-\t\tsummary.WriteString(\"\\n```\\n\")\n-\t}\n-\n-\t// Statistics\n-\tsummary.WriteString(\"\\n## Change Statistics\\n\")\n-\tsummary.WriteString(\"Total Changes: +\")\n-\tsummary.WriteString(intToString(mrContext.TotalAdditions))\n-\tsummary.WriteString(\" additions, -\")\n-\tsummary.WriteString(intToString(mrContext.TotalDeletions))\n-\tsummary.WriteString(\" deletions across \")\n-\tsummary.WriteString(intToString(mrContext.TotalFiles))\n-\tsummary.WriteString(\" files\\n\")\n-\n-\t// Show top changed files\n-\tmostChanged := mrContext.getMostChangedFiles(5)\n-\tif len(mostChanged) \u003e 0 {\n-\t\tsummary.WriteString(\"Most Changed Files:\\n\")\n-\t\tfor _, file := range mostChanged {\n-\t\t\tsummary.WriteString(\"  - \")\n-\t\t\tsummary.WriteString(file.FilePath)\n-\t\t\tsummary.WriteString(\": +\")\n-\t\t\tsummary.WriteString(intToString(file.Additions))\n-\t\t\tsummary.WriteString(\", -\")\n-\t\t\tsummary.WriteString(intToString(file.Deletions))\n-\t\t\tsummary.WriteString(\" (\")\n-\t\t\tsummary.WriteString(intToString(file.TotalChanges))\n-\t\t\tsummary.WriteString(\" total)\\n\")\n-\t\t}\n-\t}\n-\tsummary.WriteString(\"\\n## Commits: \")\n-\tsummary.WriteString(intToString(mrContext.TotalCommits))\n-\tsummary.WriteString(\" commits\\n\")\n-\tfor i, commit := range mrContext.Commits {\n-\t\t// Commit header with short SHA\n-\t\tsummary.WriteString(fmt.Sprintf(\"%d. \", i+1))\n-\t\tsummary.WriteString(commit.Subject)\n-\t\tsummary.WriteString(\" (@\") // Author\n-\t\tsummary.WriteString(commit.Author)\n-\t\tsummary.WriteString(\")\\nTime: \")\n-\t\tsummary.WriteString(commit.Timestamp.Format(time.RFC3339))\n-\t\tsummary.WriteString(\"\\nFiles: \")\n-\t\tsummary.WriteString(intToString(commit.TotalFiles))\n-\t\tsummary.WriteString(\"\\n\")\n-\n-\t\t// File changes in this commit\n-\t\tif len(commit.FileChanges) \u003e 0 {\n-\t\t\tfor _, change := range sortByTotalChanges(commit.FileChanges) {\n-\t\t\t\tfilePath := change.NewPath\n-\t\t\t\tif filePath == \"\" {\n-\t\t\t\t\tfilePath = change.OldPath\n-\t\t\t\t}\n-\n-\t\t\t\tsummary.WriteString(\"  - \")\n-\t\t\t\tsummary.WriteString(filePath)\n-\t\t\t\tsummary.WriteString(\": [\")\n-\t\t\t\tsummary.WriteString(change.Status)\n-\t\t\t\tsummary.WriteString(\"]: +\")\n-\t\t\t\tsummary.WriteString(intToString(change.Additions))\n-\t\t\t\tsummary.WriteString(\", -\")\n-\t\t\t\tsummary.WriteString(intToString(change.Deletions))\n-\n-\t\t\t\t// Show rename information\n-\t\t\t\tif change.Status == \"renamed\" \u0026\u0026 change.OldPath != \"\" \u0026\u0026 change.OldPath != change.NewPath {\n-\t\t\t\t\tsummary.WriteString(\" (from \")\n-\t\t\t\t\tsummary.WriteString(change.OldPath)\n-\t\t\t\t\tsummary.WriteString(\")\")\n-\t\t\t\t}\n-\n-\t\t\t\t// Binary file indicator\n-\t\t\t\tif change.IsBinary {\n-\t\t\t\t\tsummary.WriteString(\" [binary]\")\n-\t\t\t\t}\n-\n-\t\t\t\tsummary.WriteString(\"\\n\")\n-\t\t\t}\n-\t\t}\n-\n-\t\t// Commit body if available and not too long\n-\t\tif commit.Body != \"\" \u0026\u0026 len(commit.Body) \u003c= 200 {\n-\t\t\tsummary.WriteString(\"  Description: \")\n-\t\t\tsummary.WriteString(commit.Body)\n-\t\t\tsummary.WriteString(\"\\n\")\n-\t\t} else if commit.Body != \"\" {\n-\t\t\tsummary.WriteString(\"  Description: \")\n-\t\t\tsummary.WriteString(commit.Body[:197])\n-\t\t\tsummary.WriteString(\"...\\n\")\n-\t\t}\n-\n-\t\tsummary.WriteString(\"\\n\")\n-\t}\n-\n-\t// Linked issues and tickets\n-\tif len(mrContext.LinkedIssues) \u003e 0 || len(mrContext.LinkedTickets) \u003e 0 {\n-\t\tsummary.WriteString(\"\\n## Linked References\\n\")\n-\n-\t\tif len(mrContext.LinkedIssues) \u003e 0 {\n-\t\t\tsummary.WriteString(\"- Issues: \")\n-\t\t\tfor i, issue := range mrContext.LinkedIssues {\n-\t\t\t\tif i \u003e 0 {\n-\t\t\t\t\tsummary.WriteString(\", \")\n-\t\t\t\t}\n-\t\t\t\tsummary.WriteString(\"#\")\n-\t\t\t\tsummary.WriteString(intToString(issue.Number))\n-\t\t\t}\n-\t\t\tsummary.WriteString(\"\\n\")\n-\t\t}\n-\n-\t\tif len(mrContext.LinkedTickets) \u003e 0 {\n-\t\t\tsummary.WriteString(\"- Tickets: \")\n-\t\t\tfor i, ticket := range mrContext.LinkedTickets {\n-\t\t\t\tif i \u003e 0 {\n-\t\t\t\t\tsummary.WriteString(\", \")\n-\t\t\t\t}\n-\t\t\t\tsummary.WriteString(ticket.Key)\n-\t\t\t}\n-\t\t\tsummary.WriteString(\"\\n\")\n-\t\t}\n-\t}\n-\n-\t// Author comments (provide context about author's intentions)\n-\tif len(mrContext.AuthorComments) \u003e 0 {\n-\t\tsummary.WriteString(\"\\n## Author Comments \u0026 Context\\n\")\n-\t\tfor i, comment := range mrContext.AuthorComments {\n-\t\t\tif i \u003e= 3 {\n-\t\t\t\tsummary.WriteString(\"- ... and \")\n-\t\t\t\tsummary.WriteString(intToString(len(mrContext.AuthorComments) - 3))\n-\t\t\t\tsummary.WriteString(\" more comments\\n\")\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\tsummary.WriteString(\"- \")\n-\t\t\t// Truncate long comments\n-\t\t\tcommentBody := comment.Body\n-\t\t\tif len(commentBody) \u003e 150 {\n-\t\t\t\tcommentBody = commentBody[:150] + \"...\"\n-\t\t\t}\n-\t\t\tsummary.WriteString(commentBody)\n-\t\t\tsummary.WriteString(\"\\n\")\n-\t\t}\n-\t}\n-\n-\treturn summary.String()\n-}\n-\n const (\n \tstartMarkerDesc = \"\u003c!-- Codry: ai-desc-start --\u003e\"\n \tendMarkerDesc   = \"\u003c!-- Codry: ai-desc-end --\u003e\"\n@@ -283,69 +34,48 @@ var aiMarkers = []struct {\n \t{startMarkerCodeReview, endMarkerCodeReview},\n }\n \n-// mrContextBuilder gathers comprehensive metadata about merge requests\n-type mrContextBuilder struct {\n-\tprovider interfaces.CodeProvider\n-\tlog      logze.Logger\n-}\n-\n-// newMRContextBuilder creates a new context manager\n-func newMRContextBuilder(provider interfaces.CodeProvider) *mrContextBuilder {\n-\treturn \u0026mrContextBuilder{\n-\t\tprovider: provider,\n-\t\tlog:      logze.With(\"component\", \"mr_context_builder\"),\n-\t}\n-}\n-\n-type mrContextRequest struct {\n-\tProjectID    string\n-\tMergeRequest *model.MergeRequest\n-\tDiffs        []*model.FileDiff\n-\tComments     []*model.Comment\n-\tCommits      []*model.Commit\n-}\n-\n // GatherMRContext collects comprehensive metadata about a merge request\n-func (cm *mrContextBuilder) gatherMRContext(ctx context.Context, request mrContextRequest) (*MRContext, error) {\n-\tlog := cm.log.WithFields(\"project_id\", request.ProjectID, \"mr_iid\", request.MergeRequest.IID)\n+func gatherMRContext(projectID string, data *repoDataProvider) (*MRContext, error) {\n+\tlog := logze.With(\"project_id\", projectID, \"mr_iid\", data.mr.IID)\n \n \tmrContext := \u0026MRContext{\n-\t\tTitle:      request.MergeRequest.Title,\n-\t\tBranchName: request.MergeRequest.SourceBranch,\n-\t\tAuthor:     request.MergeRequest.Author,\n-\t\tCreatedAt:  request.MergeRequest.CreatedAt,\n-\t\tUpdatedAt:  request.MergeRequest.UpdatedAt,\n+\t\tTitle:      data.mr.Title,\n+\t\tBranchName: data.mr.SourceBranch,\n+\t\tAuthor:     data.mr.Author,\n+\t\tCreatedAt:  data.mr.CreatedAt,\n+\t\tUpdatedAt:  data.mr.UpdatedAt,\n+\t\tFileDiffs:  data.diffs,\n \t}\n \n \t// Step 1: Process description and filter AI content\n-\tif err := cm.processDescription(request.MergeRequest.Description, mrContext); err != nil {\n+\tif err := processDescription(data.mr.Description, mrContext); err != nil {\n \t\tlog.Warn(\"failed to process description\", \"error\", err)\n-\t\tmrContext.Description = request.MergeRequest.Description\n+\t\tmrContext.Description = data.mr.Description\n \t}\n \n \t// Step 3: Gather author comments\n-\tif err := cm.gatherAuthorComments(ctx, request, mrContext); err != nil {\n+\tif err := gatherAuthorComments(data, mrContext); err != nil {\n \t\tlog.Warn(\"failed to gather author comments\", \"error\", err)\n \t}\n \n \t// Step 4: Gather commit information\n-\tif err := cm.gatherCommitInfo(ctx, request, mrContext, log); err != nil {\n+\tif err := gatherCommitInfo(data, mrContext, log); err != nil {\n \t\tlog.Warn(\"failed to gather commit info\", \"error\", err)\n \t}\n \n \t// Step 5: Extract linked issues and tickets\n-\tif err := cm.extractLinkedReferences(mrContext); err != nil {\n+\tif err := extractLinkedReferences(mrContext); err != nil {\n \t\tlog.Warn(\"failed to extract linked references\", \"error\", err)\n \t}\n \n \t// Step 6: Calculate metadata statistics\n-\tcm.calculateMetadata(mrContext)\n+\tcalculateMetadata(mrContext)\n \n \treturn mrContext, nil\n }\n \n // processDescription filters out AI-generated content using markers\n-func (cm *mrContextBuilder) processDescription(originalDesc string, mrContext *MRContext) error {\n+func processDescription(originalDesc string, mrContext *MRContext) error {\n \tif originalDesc == \"\" {\n \t\tmrContext.Description = \"\"\n \t\treturn nil\n@@ -372,13 +102,13 @@ func (cm *mrContextBuilder) processDescription(originalDesc string, mrContext *M\n }\n \n // gatherAuthorComments collects all comments made by the MR author\n-func (cm *mrContextBuilder) gatherAuthorComments(ctx context.Context, request mrContextRequest, mrContext *MRContext) error {\n+func gatherAuthorComments(data *repoDataProvider, mrContext *MRContext) error {\n \n \tvar authorComments []*model.Comment\n \n commentsCycle:\n-\tfor _, comment := range request.Comments {\n-\t\tif comment.Author.Username == request.MergeRequest.Author.Username {\n+\tfor _, comment := range data.allComments {\n+\t\tif comment.Author.Username == data.mr.Author.Username {\n \t\t\tfor _, marker := range aiMarkers {\n \t\t\t\tif strings.Contains(comment.Body, marker.start) {\n \t\t\t\t\tcontinue commentsCycle\n@@ -393,46 +123,27 @@ commentsCycle:\n }\n \n // gatherCommitInfo collects detailed commit information using provider APIs\n-func (cm *mrContextBuilder) gatherCommitInfo(ctx context.Context, request mrContextRequest, mrContext *MRContext, log logze.Logger) error {\n-\n-\tcommits := request.Commits\n-\n-\tlog.Debug(\"retrieved commits from provider\", \"commit_count\", len(commits))\n+func gatherCommitInfo(data *repoDataProvider, mrContext *MRContext, log logze.Logger) error {\n \n \t// Convert provider commits to our internal format with file changes\n-\tfor _, commit := range commits {\n-\t\tcommitInfo, err := cm.processCommit(ctx, request, commit, mrContext)\n-\t\tif err != nil {\n-\t\t\tlog.Warn(\"failed to process commit, skipping\", \"commit_sha\", commit.SHA, \"error\", err)\n-\t\t\tcontinue\n-\t\t}\n+\tfor _, commit := range data.commits {\n+\t\tcommitInfo := processCommit(commit, data.commitsDiff)\n \t\tmrContext.Commits = append(mrContext.Commits, *commitInfo)\n \t}\n \n-\t// If no commits were successfully processed, fall back to the old method\n-\tif len(mrContext.Commits) == 0 {\n-\t\tlog.Warn(\"no commits were successfully processed, using fallback\")\n-\t\treturn cm.gatherCommitInfoFallback(request.MergeRequest, mrContext)\n-\t}\n-\n \treturn nil\n }\n \n // processCommit converts a provider commit to our internal format with file changes\n-func (cm *mrContextBuilder) processCommit(ctx context.Context, request mrContextRequest, commit *model.Commit, mrContext *MRContext) (*CommitInfo, error) {\n-\t// Get file changes for this specific commit\n-\tfileDiffs, err := cm.provider.GetCommitDiffs(ctx, request.ProjectID, commit.SHA)\n-\tif err != nil {\n-\t\treturn nil, errm.Wrap(err, \"failed to get commit diffs\")\n-\t}\n+func processCommit(commit *model.Commit, commitDiff []*model.FileDiff) *CommitInfo {\n \n-\t// Convert file diffs to our commit file changes format\n+\t// Convert file diffs to our commit file change\ts format\n \tfileChanges := make(map[string]CommitFileChange)\n-\tfor _, fileDiff := range fileDiffs {\n-\t\tstatus := cm.determineFileStatus(fileDiff)\n+\tfor _, fileDiff := range commitDiff {\n+\t\tstatus := determineFileStatus(fileDiff)\n \n \t\t// Parse the diff to count additions/deletions\n-\t\tadditions, deletions := cm.parseDiffStats(fileDiff.Diff)\n+\t\tadditions, deletions := parseDiffStats(fileDiff.Diff)\n \n \t\tfileChange := CommitFileChange{\n \t\t\tStatus:    status,\n@@ -463,58 +174,11 @@ func (cm *mrContextBuilder) processCommit(ctx context.Context, request mrContext\n \t\tTotalFiles:  len(fileChanges),\n \t}\n \n-\treturn commitInfo, nil\n-}\n-\n-// gatherCommitInfoFallback is the fallback method when provider APIs fail\n-func (cm *mrContextBuilder) gatherCommitInfoFallback(mr *model.MergeRequest, mrContext *MRContext) error {\n-\tif mr.SHA != \"\" {\n-\t\t// Create a commit entry representing the current state of the MR\n-\t\tfileChanges := make(map[string]CommitFileChange)\n-\n-\t\t// Map file diffs to commit file changes\n-\t\tfor _, fileDiff := range mrContext.FileDiffs {\n-\t\t\tstatus := cm.determineFileStatus(fileDiff)\n-\n-\t\t\t// Parse the diff to count additions/deletions\n-\t\t\tadditions, deletions := cm.parseDiffStats(fileDiff.Diff)\n-\n-\t\t\tfileChange := CommitFileChange{\n-\t\t\t\tStatus:    status,\n-\t\t\t\tAdditions: additions,\n-\t\t\t\tDeletions: deletions,\n-\t\t\t\tOldPath:   fileDiff.OldPath,\n-\t\t\t\tNewPath:   fileDiff.NewPath,\n-\t\t\t\tIsBinary:  fileDiff.IsBinary,\n-\t\t\t}\n-\n-\t\t\t// Use new path as key, fallback to old path for deleted files\n-\t\t\tkey := fileDiff.NewPath\n-\t\t\tif key == \"\" {\n-\t\t\t\tkey = fileDiff.OldPath\n-\t\t\t}\n-\n-\t\t\tfileChanges[key] = fileChange\n-\t\t}\n-\n-\t\tcommit := CommitInfo{\n-\t\t\tSHA:         mr.SHA,\n-\t\t\tSubject:     cm.generateCommitSubject(mr, fileChanges),\n-\t\t\tBody:        cm.generateCommitBody(mr, len(fileChanges)),\n-\t\t\tAuthor:      mr.Author.Name,\n-\t\t\tTimestamp:   mr.UpdatedAt,\n-\t\t\tFileChanges: fileChanges,\n-\t\t\tTotalFiles:  len(fileChanges),\n-\t\t}\n-\n-\t\tmrContext.Commits = append(mrContext.Commits, commit)\n-\t}\n-\n-\treturn nil\n+\treturn commitInfo\n }\n \n // determineFileStatus determines the status of a file change\n-func (cm *mrContextBuilder) determineFileStatus(fileDiff *model.FileDiff) string {\n+func determineFileStatus(fileDiff *model.FileDiff) string {\n \tif fileDiff.IsNew {\n \t\treturn \"added\"\n \t}\n@@ -528,7 +192,7 @@ func (cm *mrContextBuilder) determineFileStatus(fileDiff *model.FileDiff) string\n }\n \n // parseDiffStats parses a diff string to count additions and deletions\n-func (cm *mrContextBuilder) parseDiffStats(diff string) (additions, deletions int) {\n+func parseDiffStats(diff string) (additions, deletions int) {\n \tif diff == \"\" {\n \t\treturn 0, 0\n \t}\n@@ -546,7 +210,7 @@ func (cm *mrContextBuilder) parseDiffStats(diff string) (additions, deletions in\n }\n \n // generateCommitSubject creates a commit subject based on MR info\n-func (cm *mrContextBuilder) generateCommitSubject(mr *model.MergeRequest, fileChanges map[string]CommitFileChange) string {\n+func generateCommitSubject(mr *model.MergeRequest, fileChanges map[string]CommitFileChange) string {\n \t// Try to extract meaningful subject from MR title or use default\n \tif mr.Title != \"\" {\n \t\t// Truncate title if too long for commit subject\n@@ -569,7 +233,7 @@ func (cm *mrContextBuilder) generateCommitSubject(mr *model.MergeRequest, fileCh\n }\n \n // generateCommitBody creates a commit body with change summary\n-func (cm *mrContextBuilder) generateCommitBody(mr *model.MergeRequest, fileCount int) string {\n+func generateCommitBody(mr *model.MergeRequest, fileCount int) string {\n \tvar body strings.Builder\n \n \tif mr.Description != \"\" \u0026\u0026 len(mr.Description) \u003c 500 {\n@@ -592,7 +256,7 @@ func (cm *mrContextBuilder) generateCommitBody(mr *model.MergeRequest, fileCount\n }\n \n // extractLinkedReferences extracts linked issues and tickets from title, description, and commits\n-func (cm *mrContextBuilder) extractLinkedReferences(mrContext *MRContext) error {\n+func extractLinkedReferences(mrContext *MRContext) error {\n \ttextToAnalyze := strings.Join([]string{\n \t\tmrContext.Title,\n \t\tmrContext.Description,\n@@ -605,16 +269,16 @@ func (cm *mrContextBuilder) extractLinkedReferences(mrContext *MRContext) error\n \t}\n \n \t// Extract GitHub/GitLab issues\n-\tmrContext.LinkedIssues = cm.extractIssueReferences(textToAnalyze)\n+\tmrContext.LinkedIssues = extractIssueReferences(textToAnalyze)\n \n \t// Extract Jira tickets\n-\tmrContext.LinkedTickets = cm.extractTicketReferences(textToAnalyze)\n+\tmrContext.LinkedTickets = extractTicketReferences(textToAnalyze)\n \n \treturn nil\n }\n \n // extractIssueReferences finds GitHub/GitLab issue references\n-func (cm *mrContextBuilder) extractIssueReferences(text string) []LinkedIssue {\n+func extractIssueReferences(text string) []LinkedIssue {\n \tvar issues []LinkedIssue\n \n \t// Common patterns for issue references\n@@ -657,7 +321,7 @@ func (cm *mrContextBuilder) extractIssueReferences(text string) []LinkedIssue {\n }\n \n // extractTicketReferences finds Jira and other ticket references\n-func (cm *mrContextBuilder) extractTicketReferences(text string) []LinkedTicket {\n+func extractTicketReferences(text string) []LinkedTicket {\n \tvar tickets []LinkedTicket\n \n \t// Common patterns for ticket references\n@@ -698,7 +362,7 @@ func (cm *mrContextBuilder) extractTicketReferences(text string) []LinkedTicket\n }\n \n // calculateMetadata computes statistics about the MR\n-func (cm *mrContextBuilder) calculateMetadata(mrContext *MRContext) {\n+func calculateMetadata(mrContext *MRContext) {\n \tmrContext.TotalCommits = len(mrContext.Commits)\n \tmrContext.TotalFiles = len(mrContext.FileDiffs)\n \tmrContext.FilesStat = make(map[string]FileDiffInfo, len(mrContext.FileDiffs))",
      "affected_symbols": [
        {
          "symbol_name": "gatherMRContext",
          "symbol_type": "function",
          "full_code": "func gatherMRContext(projectID string, data *repoDataProvider) (*MRContext, error) {\n\tlog := logze.With(\"project_id\", projectID, \"mr_iid\", data.mr.IID)\n\n\tmrContext := \u0026MRContext{\n\t\tTitle:      data.mr.Title,\n\t\tBranchName: data.mr.SourceBranch,\n\t\tAuthor:     data.mr.Author,\n\t\tCreatedAt:  data.mr.CreatedAt,\n\t\tUpdatedAt:  data.mr.UpdatedAt,\n\t\tFileDiffs:  data.diffs,\n\t}\n\n\t// Step 1: Process description and filter AI content\n\tif err := processDescription(data.mr.Description, mrContext); err != nil {\n\t\tlog.Warn(\"failed to process description\", \"error\", err)\n\t\tmrContext.Description = data.mr.Description\n\t}\n\n\t// Step 3: Gather author comments\n\tif err := gatherAuthorComments(data, mrContext); err != nil {\n\t\tlog.Warn(\"failed to gather author comments\", \"error\", err)\n\t}\n\n\t// Step 4: Gather commit information\n\tif err := gatherCommitInfo(data, mrContext, log); err != nil {\n\t\tlog.Warn(\"failed to gather commit info\", \"error\", err)\n\t}\n\n\t// Step 5: Extract linked issues and tickets\n\tif err := extractLinkedReferences(mrContext); err != nil {\n\t\tlog.Warn(\"failed to extract linked references\", \"error\", err)\n\t}\n\n\t// Step 6: Calculate metadata statistics\n\tcalculateMetadata(mrContext)\n\n\treturn mrContext, nil\n}",
          "doc_comment": "// GatherMRContext collects comprehensive metadata about a merge request",
          "context": {
            "package": "llmcontext",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "logze.With",
              "snippet": "logze.With(\"project_id\", projectID, \"mr_iid\", data.mr.IID)",
              "line": 39,
              "type": "function",
              "source_file": "external",
              "source_code": "// logze.With() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "processDescription",
              "snippet": "processDescription(data.mr.Description, mrContext)",
              "line": 51,
              "type": "function",
              "source_file": "external",
              "source_code": "// processDescription() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "log.Warn",
              "snippet": "log.Warn(\"failed to process description\", \"error\", err)",
              "line": 52,
              "type": "function",
              "source_file": "external",
              "source_code": "// log.Warn() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "log.Warn",
              "snippet": "log.Warn(\"failed to gather author comments\", \"error\", err)",
              "line": 58,
              "type": "function",
              "source_file": "external",
              "source_code": "// log.Warn() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "gatherCommitInfo",
              "snippet": "gatherCommitInfo(data, mrContext, log)",
              "line": 62,
              "type": "function",
              "source_file": "external",
              "source_code": "// gatherCommitInfo() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "log.Warn",
              "snippet": "log.Warn(\"failed to gather commit info\", \"error\", err)",
              "line": 63,
              "type": "function",
              "source_file": "external",
              "source_code": "// log.Warn() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "extractLinkedReferences",
              "snippet": "extractLinkedReferences(mrContext)",
              "line": 67,
              "type": "function",
              "source_file": "external",
              "source_code": "// extractLinkedReferences() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "log.Warn",
              "snippet": "log.Warn(\"failed to extract linked references\", \"error\", err)",
              "line": 68,
              "type": "function",
              "source_file": "external",
              "source_code": "// log.Warn() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "calculateMetadata",
              "snippet": "calculateMetadata(mrContext)",
              "line": 72,
              "type": "function",
              "source_file": "external",
              "source_code": "// calculateMetadata() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/llmcontext/mr_context.go",
          "start_line": 38,
          "end_line": 75
        },
        {
          "symbol_name": "processDescription",
          "symbol_type": "function",
          "full_code": "func processDescription(originalDesc string, mrContext *MRContext) error {\n\tif originalDesc == \"\" {\n\t\tmrContext.Description = \"\"\n\t\treturn nil\n\t}\n\n\tfilteredDesc := originalDesc\n\n\t// Remove AI-generated sections\n\tfor _, marker := range aiMarkers {\n\t\tif strings.Contains(filteredDesc, marker.start) {\n\t\t\t// Remove content between markers\n\t\t\tre := regexp.MustCompile(regexp.QuoteMeta(marker.start) + `[\\s\\S]*?` + regexp.QuoteMeta(marker.end))\n\t\t\tfilteredDesc = re.ReplaceAllString(filteredDesc, \"\")\n\t\t}\n\t}\n\n\t// Clean up extra whitespace\n\tfilteredDesc = strings.TrimSpace(filteredDesc)\n\tfilteredDesc = regexp.MustCompile(`\\n\\s*\\n\\s*\\n`).ReplaceAllString(filteredDesc, \"\\n\\n\")\n\n\tmrContext.Description = filteredDesc\n\n\treturn nil\n}",
          "doc_comment": "// processDescription filters out AI-generated content using markers",
          "context": {
            "package": "llmcontext",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "regexp.MustCompile",
              "snippet": "regexp.MustCompile(regexp.QuoteMeta(marker.start) + `[\\s\\S]*?` + regexp.QuoteMeta(marker.end))",
              "line": 90,
              "type": "function",
              "source_file": "external",
              "source_code": "// regexp.MustCompile() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "regexp.QuoteMeta",
              "snippet": "regexp.QuoteMeta(marker.start)",
              "line": 90,
              "type": "function",
              "source_file": "external",
              "source_code": "// regexp.QuoteMeta() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "regexp.QuoteMeta",
              "snippet": "regexp.QuoteMeta(marker.end)",
              "line": 90,
              "type": "function",
              "source_file": "external",
              "source_code": "// regexp.QuoteMeta() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "regexp.MustCompile",
              "snippet": "regexp.MustCompile(`\\n\\s*\\n\\s*\\n`).ReplaceAllString(filteredDesc, \"\\n\\n\")",
              "line": 97,
              "type": "function",
              "source_file": "external",
              "source_code": "// regexp.MustCompile() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "regexp.MustCompile",
              "snippet": "regexp.MustCompile(`\\n\\s*\\n\\s*\\n`)",
              "line": 97,
              "type": "function",
              "source_file": "external",
              "source_code": "// regexp.MustCompile() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/llmcontext/mr_context.go",
          "start_line": 78,
          "end_line": 102
        },
        {
          "symbol_name": "gatherAuthorComments",
          "symbol_type": "function",
          "full_code": "func gatherAuthorComments(data *repoDataProvider, mrContext *MRContext) error {\n\n\tvar authorComments []*model.Comment\n\ncommentsCycle:\n\tfor _, comment := range data.allComments {\n\t\tif comment.Author.Username == data.mr.Author.Username {\n\t\t\tfor _, marker := range aiMarkers {\n\t\t\t\tif strings.Contains(comment.Body, marker.start) {\n\t\t\t\t\tcontinue commentsCycle\n\t\t\t\t}\n\t\t\t}\n\t\t\tauthorComments = append(authorComments, comment)\n\t\t}\n\t}\n\n\tmrContext.AuthorComments = authorComments\n\treturn nil\n}",
          "doc_comment": "// gatherAuthorComments collects all comments made by the MR author",
          "context": {
            "package": "llmcontext",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": null,
          "file_path": "internal/reviewer/llmcontext/mr_context.go",
          "start_line": 105,
          "end_line": 123
        },
        {
          "symbol_name": "gatherCommitInfo",
          "symbol_type": "function",
          "full_code": "func gatherCommitInfo(data *repoDataProvider, mrContext *MRContext, log logze.Logger) error {\n\n\t// Convert provider commits to our internal format with file changes\n\tfor _, commit := range data.commits {\n\t\tcommitInfo := processCommit(commit, data.commitsDiff)\n\t\tmrContext.Commits = append(mrContext.Commits, *commitInfo)\n\t}\n\n\treturn nil\n}",
          "doc_comment": "// gatherCommitInfo collects detailed commit information using provider APIs",
          "context": {
            "package": "llmcontext",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "processCommit",
              "snippet": "processCommit(commit, data.commitsDiff)",
              "line": 130,
              "type": "function",
              "source_file": "external",
              "source_code": "// processCommit() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/llmcontext/mr_context.go",
          "start_line": 126,
          "end_line": 135
        },
        {
          "symbol_name": "processCommit",
          "symbol_type": "function",
          "full_code": "func processCommit(commit *model.Commit, commitDiff []*model.FileDiff) *CommitInfo {\n\n\t// Convert file diffs to our commit file change\ts format\n\tfileChanges := make(map[string]CommitFileChange)\n\tfor _, fileDiff := range commitDiff {\n\t\tstatus := determineFileStatus(fileDiff)\n\n\t\t// Parse the diff to count additions/deletions\n\t\tadditions, deletions := parseDiffStats(fileDiff.Diff)\n\n\t\tfileChange := CommitFileChange{\n\t\t\tStatus:    status,\n\t\t\tAdditions: additions,\n\t\t\tDeletions: deletions,\n\t\t\tOldPath:   fileDiff.OldPath,\n\t\t\tNewPath:   fileDiff.NewPath,\n\t\t\tIsBinary:  fileDiff.IsBinary,\n\t\t}\n\n\t\t// Use new path as key, fallback to old path for deleted files\n\t\tkey := fileDiff.NewPath\n\t\tif key == \"\" {\n\t\t\tkey = fileDiff.OldPath\n\t\t}\n\n\t\tfileChanges[key] = fileChange\n\t}\n\n\t// Create our internal commit info\n\tcommitInfo := \u0026CommitInfo{\n\t\tSHA:         commit.SHA,\n\t\tSubject:     commit.Subject,\n\t\tBody:        commit.Body,\n\t\tAuthor:      commit.Author.Name,\n\t\tTimestamp:   commit.Timestamp,\n\t\tFileChanges: fileChanges,\n\t\tTotalFiles:  len(fileChanges),\n\t}\n\n\treturn commitInfo\n}",
          "doc_comment": "// processCommit converts a provider commit to our internal format with file changes",
          "context": {
            "package": "llmcontext",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "determineFileStatus",
              "snippet": "determineFileStatus(fileDiff)",
              "line": 143,
              "type": "function",
              "source_file": "external",
              "source_code": "// determineFileStatus() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "parseDiffStats",
              "snippet": "parseDiffStats(fileDiff.Diff)",
              "line": 146,
              "type": "function",
              "source_file": "external",
              "source_code": "// parseDiffStats() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/llmcontext/mr_context.go",
          "start_line": 138,
          "end_line": 178
        },
        {
          "symbol_name": "determineFileStatus",
          "symbol_type": "function",
          "full_code": "func determineFileStatus(fileDiff *model.FileDiff) string {\n\tif fileDiff.IsNew {\n\t\treturn \"added\"\n\t}\n\tif fileDiff.IsDeleted {\n\t\treturn \"deleted\"\n\t}\n\tif fileDiff.IsRenamed {\n\t\treturn \"renamed\"\n\t}\n\treturn \"modified\"\n}",
          "doc_comment": "// determineFileStatus determines the status of a file change",
          "context": {
            "package": "llmcontext",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": null,
          "file_path": "internal/reviewer/llmcontext/mr_context.go",
          "start_line": 181,
          "end_line": 192
        },
        {
          "symbol_name": "parseDiffStats",
          "symbol_type": "function",
          "full_code": "func parseDiffStats(diff string) (additions, deletions int) {\n\tif diff == \"\" {\n\t\treturn 0, 0\n\t}\n\n\tlines := strings.Split(diff, \"\\n\")\n\tfor _, line := range lines {\n\t\tif strings.HasPrefix(line, \"+\") \u0026\u0026 !strings.HasPrefix(line, \"+++\") {\n\t\t\tadditions++\n\t\t} else if strings.HasPrefix(line, \"-\") \u0026\u0026 !strings.HasPrefix(line, \"---\") {\n\t\t\tdeletions++\n\t\t}\n\t}\n\n\treturn additions, deletions\n}",
          "doc_comment": "// parseDiffStats parses a diff string to count additions and deletions",
          "context": {
            "package": "llmcontext",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": null,
          "file_path": "internal/reviewer/llmcontext/mr_context.go",
          "start_line": 195,
          "end_line": 210
        },
        {
          "symbol_name": "generateCommitSubject",
          "symbol_type": "function",
          "full_code": "func generateCommitSubject(mr *model.MergeRequest, fileChanges map[string]CommitFileChange) string {\n\t// Try to extract meaningful subject from MR title or use default\n\tif mr.Title != \"\" {\n\t\t// Truncate title if too long for commit subject\n\t\ttitle := mr.Title\n\t\tif len(title) \u003e 72 {\n\t\t\ttitle = title[:69] + \"...\"\n\t\t}\n\t\treturn title\n\t}\n\n\t// Fallback: describe the changes\n\tfileCount := len(fileChanges)\n\tif fileCount == 1 {\n\t\tfor filename := range fileChanges {\n\t\t\treturn \"Update \" + filename\n\t\t}\n\t}\n\n\treturn fmt.Sprintf(\"Update %d files\", fileCount)\n}",
          "doc_comment": "// generateCommitSubject creates a commit subject based on MR info",
          "context": {
            "package": "llmcontext",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": null,
          "file_path": "internal/reviewer/llmcontext/mr_context.go",
          "start_line": 213,
          "end_line": 233
        },
        {
          "symbol_name": "generateCommitBody",
          "symbol_type": "function",
          "full_code": "func generateCommitBody(mr *model.MergeRequest, fileCount int) string {\n\tvar body strings.Builder\n\n\tif mr.Description != \"\" \u0026\u0026 len(mr.Description) \u003c 500 {\n\t\tbody.WriteString(mr.Description)\n\t\tbody.WriteString(\"\\n\\n\")\n\t}\n\n\tbody.WriteString(\"Changes from MR: \")\n\tbody.WriteString(mr.Title)\n\tbody.WriteString(\"\\n\")\n\tbody.WriteString(\"Files modified: \")\n\tbody.WriteString(intToString(fileCount))\n\tbody.WriteString(\"\\n\")\n\tbody.WriteString(\"Branch: \")\n\tbody.WriteString(mr.SourceBranch)\n\tbody.WriteString(\" -\u003e \")\n\tbody.WriteString(mr.TargetBranch)\n\n\treturn body.String()\n}",
          "doc_comment": "// generateCommitBody creates a commit body with change summary",
          "context": {
            "package": "llmcontext",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "body.WriteString",
              "snippet": "body.WriteString(mr.Description)",
              "line": 240,
              "type": "function",
              "source_file": "external",
              "source_code": "// body.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "body.WriteString",
              "snippet": "body.WriteString(\"\\n\\n\")",
              "line": 241,
              "type": "function",
              "source_file": "external",
              "source_code": "// body.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "body.WriteString",
              "snippet": "body.WriteString(\"Changes from MR: \")",
              "line": 244,
              "type": "function",
              "source_file": "external",
              "source_code": "// body.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "body.WriteString",
              "snippet": "body.WriteString(mr.Title)",
              "line": 245,
              "type": "function",
              "source_file": "external",
              "source_code": "// body.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "body.WriteString",
              "snippet": "body.WriteString(\"\\n\")",
              "line": 246,
              "type": "function",
              "source_file": "external",
              "source_code": "// body.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "body.WriteString",
              "snippet": "body.WriteString(\"Files modified: \")",
              "line": 247,
              "type": "function",
              "source_file": "external",
              "source_code": "// body.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "body.WriteString",
              "snippet": "body.WriteString(intToString(fileCount))",
              "line": 248,
              "type": "function",
              "source_file": "external",
              "source_code": "// body.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "body.WriteString",
              "snippet": "body.WriteString(\"\\n\")",
              "line": 249,
              "type": "function",
              "source_file": "external",
              "source_code": "// body.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "body.WriteString",
              "snippet": "body.WriteString(\"Branch: \")",
              "line": 250,
              "type": "function",
              "source_file": "external",
              "source_code": "// body.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "body.WriteString",
              "snippet": "body.WriteString(mr.SourceBranch)",
              "line": 251,
              "type": "function",
              "source_file": "external",
              "source_code": "// body.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "body.WriteString",
              "snippet": "body.WriteString(\" -\u003e \")",
              "line": 252,
              "type": "function",
              "source_file": "external",
              "source_code": "// body.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "body.WriteString",
              "snippet": "body.WriteString(mr.TargetBranch)",
              "line": 253,
              "type": "function",
              "source_file": "external",
              "source_code": "// body.WriteString() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "body.String",
              "snippet": "body.String()",
              "line": 255,
              "type": "function",
              "source_file": "external",
              "source_code": "// body.String() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/llmcontext/mr_context.go",
          "start_line": 236,
          "end_line": 256
        },
        {
          "symbol_name": "extractLinkedReferences",
          "symbol_type": "function",
          "full_code": "func extractLinkedReferences(mrContext *MRContext) error {\n\ttextToAnalyze := strings.Join([]string{\n\t\tmrContext.Title,\n\t\tmrContext.Description,\n\t\tmrContext.BranchName,\n\t}, \" \")\n\n\t// Add commit messages to analysis\n\tfor _, commit := range mrContext.Commits {\n\t\ttextToAnalyze += \" \" + commit.Subject + \" \" + commit.Body\n\t}\n\n\t// Extract GitHub/GitLab issues\n\tmrContext.LinkedIssues = extractIssueReferences(textToAnalyze)\n\n\t// Extract Jira tickets\n\tmrContext.LinkedTickets = extractTicketReferences(textToAnalyze)\n\n\treturn nil\n}",
          "doc_comment": "// extractLinkedReferences extracts linked issues and tickets from title, description, and commits",
          "context": {
            "package": "llmcontext",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "extractIssueReferences",
              "snippet": "extractIssueReferences(textToAnalyze)",
              "line": 272,
              "type": "function",
              "source_file": "external",
              "source_code": "// extractIssueReferences() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "extractTicketReferences",
              "snippet": "extractTicketReferences(textToAnalyze)",
              "line": 275,
              "type": "function",
              "source_file": "external",
              "source_code": "// extractTicketReferences() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/llmcontext/mr_context.go",
          "start_line": 259,
          "end_line": 278
        },
        {
          "symbol_name": "extractIssueReferences",
          "symbol_type": "function",
          "full_code": "func extractIssueReferences(text string) []LinkedIssue {\n\tvar issues []LinkedIssue\n\n\t// Common patterns for issue references\n\tpatterns := []*regexp.Regexp{\n\t\tregexp.MustCompile(`#(\\d+)`),                      // #123\n\t\tregexp.MustCompile(`(?i)issue[s]?\\s*#?(\\d+)`),     // issue 123, issues #123\n\t\tregexp.MustCompile(`(?i)fix(?:es)?\\s+#?(\\d+)`),    // fixes #123\n\t\tregexp.MustCompile(`(?i)close[s]?\\s+#?(\\d+)`),     // closes #123\n\t\tregexp.MustCompile(`(?i)resolve[s]?\\s+#?(\\d+)`),   // resolves #123\n\t\tregexp.MustCompile(`(?i)implement[s]?\\s+#?(\\d+)`), // implements #123\n\t}\n\n\tissueNumbers := make(map[int]bool)\n\n\tfor _, pattern := range patterns {\n\t\tmatches := pattern.FindAllStringSubmatch(text, -1)\n\t\tfor _, match := range matches {\n\t\t\tif len(match) \u003e 1 {\n\t\t\t\tif num := parseInt(match[1]); num \u003e 0 {\n\t\t\t\t\tissueNumbers[num] = true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Convert to LinkedIssue structs (would be enriched with actual API calls)\n\tfor num := range issueNumbers {\n\t\tissues = append(issues, LinkedIssue{\n\t\t\tID:          \"\",\n\t\t\tNumber:      num,\n\t\t\tTitle:       \"\",\n\t\t\tDescription: \"\",\n\t\t\tState:       \"unknown\",\n\t\t\tURL:         \"\",\n\t\t\tLabels:      []string{},\n\t\t})\n\t}\n\n\treturn issues\n}",
          "doc_comment": "// extractIssueReferences finds GitHub/GitLab issue references",
          "context": {
            "package": "llmcontext",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "regexp.MustCompile",
              "snippet": "regexp.MustCompile(`#(\\d+)`)",
              "line": 286,
              "type": "function",
              "source_file": "external",
              "source_code": "// regexp.MustCompile() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "regexp.MustCompile",
              "snippet": "regexp.MustCompile(`(?i)issue[s]?\\s*#?(\\d+)`)",
              "line": 287,
              "type": "function",
              "source_file": "external",
              "source_code": "// regexp.MustCompile() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "regexp.MustCompile",
              "snippet": "regexp.MustCompile(`(?i)fix(?:es)?\\s+#?(\\d+)`)",
              "line": 288,
              "type": "function",
              "source_file": "external",
              "source_code": "// regexp.MustCompile() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "regexp.MustCompile",
              "snippet": "regexp.MustCompile(`(?i)close[s]?\\s+#?(\\d+)`)",
              "line": 289,
              "type": "function",
              "source_file": "external",
              "source_code": "// regexp.MustCompile() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "regexp.MustCompile",
              "snippet": "regexp.MustCompile(`(?i)resolve[s]?\\s+#?(\\d+)`)",
              "line": 290,
              "type": "function",
              "source_file": "external",
              "source_code": "// regexp.MustCompile() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "regexp.MustCompile",
              "snippet": "regexp.MustCompile(`(?i)implement[s]?\\s+#?(\\d+)`)",
              "line": 291,
              "type": "function",
              "source_file": "external",
              "source_code": "// regexp.MustCompile() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "pattern.FindAllStringSubmatch",
              "snippet": "pattern.FindAllStringSubmatch(text, -1)",
              "line": 297,
              "type": "function",
              "source_file": "external",
              "source_code": "// pattern.FindAllStringSubmatch() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "parseInt",
              "snippet": "parseInt(match[1])",
              "line": 300,
              "type": "function",
              "source_file": "external",
              "source_code": "// parseInt() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/llmcontext/mr_context.go",
          "start_line": 281,
          "end_line": 321
        },
        {
          "symbol_name": "extractTicketReferences",
          "symbol_type": "function",
          "full_code": "func extractTicketReferences(text string) []LinkedTicket {\n\tvar tickets []LinkedTicket\n\n\t// Common patterns for ticket references\n\tpatterns := []*regexp.Regexp{\n\t\tregexp.MustCompile(`([A-Z]{2,}-\\d+)`),                 // PROJ-123\n\t\tregexp.MustCompile(`(?i)jira[:\\s]+([A-Z]{2,}-\\d+)`),   // JIRA: PROJ-123\n\t\tregexp.MustCompile(`(?i)ticket[:\\s]+([A-Z]{2,}-\\d+)`), // Ticket: PROJ-123\n\t\tregexp.MustCompile(`(?i)story[:\\s]+([A-Z]{2,}-\\d+)`),  // Story: PROJ-123\n\t\tregexp.MustCompile(`(?i)task[:\\s]+([A-Z]{2,}-\\d+)`),   // Task: PROJ-123\n\t}\n\n\tticketKeys := make(map[string]bool)\n\n\tfor _, pattern := range patterns {\n\t\tmatches := pattern.FindAllStringSubmatch(text, -1)\n\t\tfor _, match := range matches {\n\t\t\tif len(match) \u003e 1 {\n\t\t\t\tkey := strings.ToUpper(match[1])\n\t\t\t\tticketKeys[key] = true\n\t\t\t}\n\t\t}\n\t}\n\n\t// Convert to LinkedTicket structs (would be enriched with actual API calls)\n\tfor key := range ticketKeys {\n\t\ttickets = append(tickets, LinkedTicket{\n\t\t\tID:          \"\",\n\t\t\tKey:         key,\n\t\t\tTitle:       \"\",\n\t\t\tDescription: \"\",\n\t\t\tStatus:      \"unknown\",\n\t\t\tURL:         \"\",\n\t\t\tType:        \"unknown\",\n\t\t})\n\t}\n\n\treturn tickets\n}",
          "doc_comment": "// extractTicketReferences finds Jira and other ticket references",
          "context": {
            "package": "llmcontext",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "regexp.MustCompile",
              "snippet": "regexp.MustCompile(`([A-Z]{2,}-\\d+)`)",
              "line": 329,
              "type": "function",
              "source_file": "external",
              "source_code": "// regexp.MustCompile() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "regexp.MustCompile",
              "snippet": "regexp.MustCompile(`(?i)jira[:\\s]+([A-Z]{2,}-\\d+)`)",
              "line": 330,
              "type": "function",
              "source_file": "external",
              "source_code": "// regexp.MustCompile() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "regexp.MustCompile",
              "snippet": "regexp.MustCompile(`(?i)ticket[:\\s]+([A-Z]{2,}-\\d+)`)",
              "line": 331,
              "type": "function",
              "source_file": "external",
              "source_code": "// regexp.MustCompile() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "regexp.MustCompile",
              "snippet": "regexp.MustCompile(`(?i)story[:\\s]+([A-Z]{2,}-\\d+)`)",
              "line": 332,
              "type": "function",
              "source_file": "external",
              "source_code": "// regexp.MustCompile() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "regexp.MustCompile",
              "snippet": "regexp.MustCompile(`(?i)task[:\\s]+([A-Z]{2,}-\\d+)`)",
              "line": 333,
              "type": "function",
              "source_file": "external",
              "source_code": "// regexp.MustCompile() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "pattern.FindAllStringSubmatch",
              "snippet": "pattern.FindAllStringSubmatch(text, -1)",
              "line": 339,
              "type": "function",
              "source_file": "external",
              "source_code": "// pattern.FindAllStringSubmatch() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/llmcontext/mr_context.go",
          "start_line": 324,
          "end_line": 362
        },
        {
          "symbol_name": "calculateMetadata",
          "symbol_type": "function",
          "full_code": "func calculateMetadata(mrContext *MRContext) {\n\tmrContext.TotalCommits = len(mrContext.Commits)\n\tmrContext.TotalFiles = len(mrContext.FileDiffs)\n\tmrContext.FilesStat = make(map[string]FileDiffInfo, len(mrContext.FileDiffs))\n\n\t// Calculate additions and deletions from diffs\n\tfor _, diff := range mrContext.FileDiffs {\n\t\tstat := FileDiffInfo{}\n\n\t\tfor line := range strings.SplitSeq(diff.Diff, \"\\n\") {\n\t\t\tif strings.HasPrefix(line, \"+\") \u0026\u0026 !strings.HasPrefix(line, \"+++\") {\n\t\t\t\tstat.TotalAdditions++\n\t\t\t\tmrContext.TotalAdditions++\n\t\t\t} else if strings.HasPrefix(line, \"-\") \u0026\u0026 !strings.HasPrefix(line, \"---\") {\n\t\t\t\tstat.TotalDeletions++\n\t\t\t\tmrContext.TotalDeletions++\n\t\t\t}\n\t\t}\n\n\t\tmrContext.FilesStat[diff.NewPath] = stat\n\t}\n}",
          "doc_comment": "// calculateMetadata computes statistics about the MR",
          "context": {
            "package": "llmcontext",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": null,
          "file_path": "internal/reviewer/llmcontext/mr_context.go",
          "start_line": 365,
          "end_line": 386
        }
      ],
      "related_files": []
    },
    {
      "file_path": "internal/reviewer/llmcontext/repodata.go",
      "change_type": "Added",
      "diff": "@@ -0,0 +1,182 @@\n+package llmcontext\n+\n+import (\n+\t\"context\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"github.com/maxbolgarin/abstract\"\n+\t\"github.com/maxbolgarin/codry/internal/model\"\n+\t\"github.com/maxbolgarin/codry/internal/model/interfaces\"\n+\t\"github.com/maxbolgarin/errm\"\n+\t\"github.com/maxbolgarin/logze/v2\"\n+)\n+\n+type repoDataProvider struct {\n+\tprovider interfaces.CodeProvider\n+\n+\tmr           *model.MergeRequest\n+\tdiffs        []*model.FileDiff\n+\tallComments  []*model.Comment\n+\trepoInfo     *model.RepositoryInfo\n+\trepoDataHead *model.RepositorySnapshot\n+\trepoDataBase *model.RepositorySnapshot\n+\n+\tcommits     []*model.Commit\n+\tcommitsDiff []*model.FileDiff\n+\n+\tisVerbose bool\n+\n+\tlog logze.Logger\n+\n+\tmu sync.Mutex\n+}\n+\n+func newRepoDataProvider(provider interfaces.CodeProvider, isVerbose bool) *repoDataProvider {\n+\treturn \u0026repoDataProvider{provider: provider, log: logze.With(\"Module\", \"repo_data_provider\"), isVerbose: isVerbose}\n+}\n+\n+func (r *repoDataProvider) loadData(ctx context.Context, projectID string, mrIID int) error {\n+\twaiterSet := abstract.NewWaiterSet(r.log)\n+\twaiterSet.Add(ctx, func(ctx context.Context) error {\n+\t\treturn r.loadMR(ctx, projectID, mrIID)\n+\t})\n+\twaiterSet.Add(ctx, func(ctx context.Context) error {\n+\t\treturn r.loadRepoInfo(ctx, projectID)\n+\t})\n+\twaiterSet.Add(ctx, func(ctx context.Context) error {\n+\t\treturn r.loadDiffs(ctx, projectID, mrIID)\n+\t})\n+\twaiterSet.Add(ctx, func(ctx context.Context) error {\n+\t\treturn r.loadAllComments(ctx, projectID, mrIID)\n+\t})\n+\twaiterSet.Add(ctx, func(ctx context.Context) error {\n+\t\treturn r.loadRepoDataHead(ctx, projectID)\n+\t})\n+\twaiterSet.Add(ctx, func(ctx context.Context) error {\n+\t\treturn r.loadRepoDataBase(ctx, projectID)\n+\t})\n+\twaiterSet.Add(ctx, func(ctx context.Context) error {\n+\t\treturn r.loadCommitsDiff(ctx, projectID, mrIID)\n+\t})\n+\terr := waiterSet.Await(ctx)\n+\tif err != nil {\n+\t\treturn errm.Wrap(err, \"failed to load repository data\")\n+\t}\n+\n+\treturn nil\n+}\n+\n+func (r *repoDataProvider) loadMR(ctx context.Context, projectID string, mrIID int) error {\n+\ttimer := abstract.StartTimer()\n+\tmr, err := r.provider.GetMergeRequest(ctx, projectID, mrIID)\n+\tif err != nil {\n+\t\treturn errm.Wrap(err, \"failed to get merge request\")\n+\t}\n+\tr.mu.Lock()\n+\tdefer r.mu.Unlock()\n+\tr.mr = mr\n+\tr.log.DebugIf(r.isVerbose, \"loaded merge request\", \"mr\", mrIID, \"elapsed\", timer.ElapsedTime().String())\n+\treturn nil\n+}\n+\n+func (r *repoDataProvider) loadDiffs(ctx context.Context, projectID string, mrIID int) error {\n+\ttimer := abstract.StartTimer()\n+\tdiffs, err := r.provider.GetMergeRequestDiffs(ctx, projectID, mrIID)\n+\tif err != nil {\n+\t\treturn errm.Wrap(err, \"failed to get MR diffs\")\n+\t}\n+\tr.mu.Lock()\n+\tdefer r.mu.Unlock()\n+\tr.diffs = diffs\n+\tr.log.DebugIf(r.isVerbose, \"loaded merge request diffs\", \"mr\", mrIID, \"elapsed\", timer.ElapsedTime().String())\n+\treturn nil\n+}\n+\n+func (r *repoDataProvider) loadCommitsDiff(ctx context.Context, projectID string, mrIID int) error {\n+\ttimer := abstract.StartTimer()\n+\tcommits, err := r.provider.GetMergeRequestCommits(ctx, projectID, mrIID)\n+\tif err != nil {\n+\t\treturn errm.Wrap(err, \"failed to get merge request commits\")\n+\t}\n+\tvar commitsDiff []*model.FileDiff\n+\tfor _, commit := range commits {\n+\t\tfileDiffs, err := r.provider.GetCommitDiffs(ctx, projectID, commit.SHA)\n+\t\tif err != nil {\n+\t\t\treturn errm.Wrap(err, \"failed to get commit diffs\")\n+\t\t}\n+\t\tcommitsDiff = append(commitsDiff, fileDiffs...)\n+\t}\n+\tr.mu.Lock()\n+\tdefer r.mu.Unlock()\n+\tr.commits = commits\n+\tr.commitsDiff = commitsDiff\n+\tr.log.DebugIf(r.isVerbose, \"loaded merge request commits diffs\", \"mr\", mrIID, \"elapsed\", timer.ElapsedTime().String())\n+\treturn nil\n+}\n+\n+func (r *repoDataProvider) loadAllComments(ctx context.Context, projectID string, mrIID int) error {\n+\ttimer := abstract.StartTimer()\n+\tcomments, err := r.provider.GetComments(ctx, projectID, mrIID)\n+\tif err != nil {\n+\t\treturn errm.Wrap(err, \"failed to get comments\")\n+\t}\n+\tr.mu.Lock()\n+\tdefer r.mu.Unlock()\n+\tr.allComments = comments\n+\tr.log.DebugIf(r.isVerbose, \"loaded merge request comments\", \"mr\", mrIID, \"elapsed\", timer.ElapsedTime().String())\n+\treturn nil\n+}\n+\n+func (r *repoDataProvider) loadRepoInfo(ctx context.Context, projectID string) error {\n+\ttimer := abstract.StartTimer()\n+\trepoInfo, err := r.provider.GetRepositoryInfo(ctx, projectID)\n+\tif err != nil {\n+\t\treturn errm.Wrap(err, \"failed to get repository info\")\n+\t}\n+\tr.mu.Lock()\n+\tdefer r.mu.Unlock()\n+\tr.repoInfo = repoInfo\n+\tr.log.DebugIf(r.isVerbose, \"loaded repository info\", \"repo\", repoInfo.Name, \"elapsed\", timer.ElapsedTime().String())\n+\treturn nil\n+}\n+\n+func (r *repoDataProvider) loadRepoDataHead(ctx context.Context, projectID string) error {\n+\ttimer := abstract.StartTimer()\n+\tfor r.mr == nil {\n+\t\ttime.Sleep(100 * time.Millisecond)\n+\t}\n+\trepoDataHead, err := r.provider.GetRepositorySnapshot(ctx, projectID, r.mr.SHA)\n+\tif err != nil {\n+\t\treturn errm.Wrap(err, \"failed to get repository data (head)\")\n+\t}\n+\tr.mu.Lock()\n+\tdefer r.mu.Unlock()\n+\tr.repoDataHead = repoDataHead\n+\tr.log.DebugIf(r.isVerbose, \"loaded repository data (head)\", \"mr\", r.mr.SHA, \"elapsed\", timer.ElapsedTime().String())\n+\treturn nil\n+}\n+\n+func (r *repoDataProvider) loadRepoDataBase(ctx context.Context, projectID string) error {\n+\ttimer := abstract.StartTimer()\n+\tfor r.repoInfo == nil {\n+\t\ttime.Sleep(100 * time.Millisecond)\n+\t}\n+\tfor r.mr == nil {\n+\t\ttime.Sleep(100 * time.Millisecond)\n+\t}\n+\tfor _, branch := range r.repoInfo.Branches {\n+\t\tif branch.Name == r.mr.TargetBranch {\n+\t\t\trepoDataBase, err := r.provider.GetRepositorySnapshot(ctx, projectID, branch.SHA)\n+\t\t\tif err != nil {\n+\t\t\t\treturn errm.Wrap(err, \"failed to get repository data\")\n+\t\t\t}\n+\t\t\tr.mu.Lock()\n+\t\t\tdefer r.mu.Unlock()\n+\t\t\tr.repoDataBase = repoDataBase\n+\t\t\tr.log.DebugIf(r.isVerbose, \"loaded repository data (base)\", \"mr\", r.mr.IID, \"elapsed\", timer.ElapsedTime().String())\n+\t\t\treturn nil\n+\t\t}\n+\t}\n+\treturn errm.New(\"failed to find repository data for base branch\")\n+}",
      "affected_symbols": [],
      "related_files": []
    },
    {
      "file_path": "internal/reviewer/reviewer.go",
      "change_type": "Modified",
      "diff": "@@ -62,7 +62,7 @@ func New(cfg Config, provider interfaces.CodeProvider, agent *agent.Agent) (*Rev\n \t\tparser:         astparser.NewDiffParser(),\n \t\tprocessedMRs:   abstract.NewSafeMapOfMaps[string, string, string](),\n \t\treviewedMRs:    abstract.NewSafeMap[string, reviewTrackingInfo](),\n-\t\tcontextBuilder: llmcontext.NewBuilder(provider),\n+\t\tcontextBuilder: llmcontext.NewBuilder(provider, cfg.Verbose),\n \t}\n \n \treturn s, nil",
      "affected_symbols": [
        {
          "symbol_name": "New",
          "symbol_type": "function",
          "full_code": "func New(cfg Config, provider interfaces.CodeProvider, agent *agent.Agent) (*Reviewer, error) {\n\tif err := cfg.PrepareAndValidate(); err != nil {\n\t\treturn nil, errm.Wrap(err, \"failed to prepare and validate config\")\n\t}\n\n\tpool, err := ants.NewPool(defaultPoolSize)\n\tif err != nil {\n\t\treturn nil, errm.Wrap(err, \"failed to create ants pool\")\n\t}\n\n\ts := \u0026Reviewer{\n\t\tprovider:       provider,\n\t\tagent:          agent,\n\t\tcfg:            cfg,\n\t\tlog:            logze.With(\"component\", \"reviewer\"),\n\t\tpool:           pool,\n\t\tparser:         astparser.NewDiffParser(),\n\t\tprocessedMRs:   abstract.NewSafeMapOfMaps[string, string, string](),\n\t\treviewedMRs:    abstract.NewSafeMap[string, reviewTrackingInfo](),\n\t\tcontextBuilder: llmcontext.NewBuilder(provider, cfg.Verbose),\n\t}\n\n\treturn s, nil\n}",
          "doc_comment": "// New creates a new reviewer",
          "context": {
            "package": "reviewer",
            "module": "",
            "namespace": ""
          },
          "callers": null,
          "dependencies": [
            {
              "name": "cfg.PrepareAndValidate",
              "snippet": "cfg.PrepareAndValidate()",
              "line": 47,
              "type": "function",
              "source_file": "external",
              "source_code": "// cfg.PrepareAndValidate() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "errm.Wrap",
              "snippet": "errm.Wrap(err, \"failed to prepare and validate config\")",
              "line": 48,
              "type": "function",
              "source_file": "external",
              "source_code": "// errm.Wrap() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "ants.NewPool",
              "snippet": "ants.NewPool(defaultPoolSize)",
              "line": 51,
              "type": "function",
              "source_file": "external",
              "source_code": "// ants.NewPool() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "errm.Wrap",
              "snippet": "errm.Wrap(err, \"failed to create ants pool\")",
              "line": 53,
              "type": "function",
              "source_file": "external",
              "source_code": "// errm.Wrap() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "logze.With",
              "snippet": "logze.With(\"component\", \"reviewer\")",
              "line": 60,
              "type": "function",
              "source_file": "external",
              "source_code": "// logze.With() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "astparser.NewDiffParser",
              "snippet": "astparser.NewDiffParser()",
              "line": 62,
              "type": "function",
              "source_file": "external",
              "source_code": "// astparser.NewDiffParser() - definition not found in current scope",
              "documentation": ""
            },
            {
              "name": "llmcontext.NewBuilder",
              "snippet": "llmcontext.NewBuilder(provider, cfg.Verbose)",
              "line": 65,
              "type": "function",
              "source_file": "external",
              "source_code": "// llmcontext.NewBuilder() - definition not found in current scope",
              "documentation": ""
            }
          ],
          "file_path": "internal/reviewer/reviewer.go",
          "start_line": 46,
          "end_line": 69
        }
      ],
      "related_files": []
    }
  ],
  "mr_context": {
    "title": "Feat ast parser",
    "description": "@coderabitai ignore",
    "branch_name": "feat-ast_parser",
    "created_at": "2025-07-18T14:37:27Z",
    "updated_at": "2025-07-18T14:37:38Z",
    "author": {
      "ID": "43585189",
      "Username": "maxbolgarin",
      "Name": "",
      "Email": ""
    },
    "author_comments": null,
    "commits": [
      {
        "sha": "6883cc9d359dd1b7233ebb129e8a31ea9ec93f9f",
        "subject": "Enhance AST parsing with multi-language symbol and dependency extraction",
        "body": "Co-authored-by: thegreenoverdrive \u003cthegreenoverdrive@gmail.com\u003e",
        "author": "Cursor Agent",
        "timestamp": "2025-07-16T20:32:28Z",
        "file_changes": {
          "context_bundle.json": {
            "status": "modified",
            "additions": 0,
            "deletions": 0,
            "old_path": "",
            "new_path": "context_bundle.json",
            "is_binary": true
          },
          "internal/reviewer/astparser/context_manager.go": {
            "status": "modified",
            "additions": 77,
            "deletions": 235,
            "old_path": "",
            "new_path": "internal/reviewer/astparser/context_manager.go",
            "is_binary": false
          },
          "internal/reviewer/astparser/diff_parser.go": {
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "old_path": "",
            "new_path": "internal/reviewer/astparser/diff_parser.go",
            "is_binary": false
          },
          "internal/reviewer/astparser/languages.go": {
            "status": "modified",
            "additions": 40,
            "deletions": 56,
            "old_path": "",
            "new_path": "internal/reviewer/astparser/languages.go",
            "is_binary": false
          },
          "internal/reviewer/astparser/parser.go": {
            "status": "modified",
            "additions": 80,
            "deletions": 84,
            "old_path": "",
            "new_path": "internal/reviewer/astparser/parser.go",
            "is_binary": false
          },
          "internal/reviewer/astparser/special_cases_helpers.go": {
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "old_path": "",
            "new_path": "internal/reviewer/astparser/special_cases_helpers.go",
            "is_binary": false
          },
          "internal/reviewer/astparser/symbol_analyzer.go": {
            "status": "modified",
            "additions": 7,
            "deletions": 8,
            "old_path": "",
            "new_path": "internal/reviewer/astparser/symbol_analyzer.go",
            "is_binary": false
          },
          "internal/reviewer/astparser/types.go": {
            "status": "added",
            "additions": 54,
            "deletions": 0,
            "old_path": "",
            "new_path": "internal/reviewer/astparser/types.go",
            "is_binary": false
          },
          "internal/reviewer/llmcontext/builder.go": {
            "status": "modified",
            "additions": 31,
            "deletions": 537,
            "old_path": "",
            "new_path": "internal/reviewer/llmcontext/builder.go",
            "is_binary": false
          },
          "internal/reviewer/llmcontext/context.go": {
            "status": "modified",
            "additions": 238,
            "deletions": 54,
            "old_path": "",
            "new_path": "internal/reviewer/llmcontext/context.go",
            "is_binary": false
          },
          "internal/reviewer/llmcontext/mr_context.go": {
            "status": "modified",
            "additions": 37,
            "deletions": 373,
            "old_path": "",
            "new_path": "internal/reviewer/llmcontext/mr_context.go",
            "is_binary": false
          },
          "internal/reviewer/llmcontext/repodata.go": {
            "status": "added",
            "additions": 182,
            "deletions": 0,
            "old_path": "",
            "new_path": "internal/reviewer/llmcontext/repodata.go",
            "is_binary": false
          },
          "internal/reviewer/reviewer.go": {
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "old_path": "",
            "new_path": "internal/reviewer/reviewer.go",
            "is_binary": false
          },
          "test_ast_parser.go": {
            "status": "deleted",
            "additions": 0,
            "deletions": 115,
            "old_path": "",
            "new_path": "test_ast_parser.go",
            "is_binary": false
          }
        },
        "total_files": 14
      },
      {
        "sha": "8cca7db5e9bd0fcd7c44424def270f52db2bc0c7",
        "subject": "feat: make ast parser better",
        "body": "",
        "author": "maxbolgarin",
        "timestamp": "2025-07-18T14:35:58Z",
        "file_changes": {
          "context_bundle.json": {
            "status": "modified",
            "additions": 0,
            "deletions": 0,
            "old_path": "",
            "new_path": "context_bundle.json",
            "is_binary": true
          },
          "internal/reviewer/astparser/context_manager.go": {
            "status": "modified",
            "additions": 77,
            "deletions": 235,
            "old_path": "",
            "new_path": "internal/reviewer/astparser/context_manager.go",
            "is_binary": false
          },
          "internal/reviewer/astparser/diff_parser.go": {
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "old_path": "",
            "new_path": "internal/reviewer/astparser/diff_parser.go",
            "is_binary": false
          },
          "internal/reviewer/astparser/languages.go": {
            "status": "modified",
            "additions": 40,
            "deletions": 56,
            "old_path": "",
            "new_path": "internal/reviewer/astparser/languages.go",
            "is_binary": false
          },
          "internal/reviewer/astparser/parser.go": {
            "status": "modified",
            "additions": 80,
            "deletions": 84,
            "old_path": "",
            "new_path": "internal/reviewer/astparser/parser.go",
            "is_binary": false
          },
          "internal/reviewer/astparser/special_cases_helpers.go": {
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "old_path": "",
            "new_path": "internal/reviewer/astparser/special_cases_helpers.go",
            "is_binary": false
          },
          "internal/reviewer/astparser/symbol_analyzer.go": {
            "status": "modified",
            "additions": 7,
            "deletions": 8,
            "old_path": "",
            "new_path": "internal/reviewer/astparser/symbol_analyzer.go",
            "is_binary": false
          },
          "internal/reviewer/astparser/types.go": {
            "status": "added",
            "additions": 54,
            "deletions": 0,
            "old_path": "",
            "new_path": "internal/reviewer/astparser/types.go",
            "is_binary": false
          },
          "internal/reviewer/llmcontext/builder.go": {
            "status": "modified",
            "additions": 31,
            "deletions": 537,
            "old_path": "",
            "new_path": "internal/reviewer/llmcontext/builder.go",
            "is_binary": false
          },
          "internal/reviewer/llmcontext/context.go": {
            "status": "modified",
            "additions": 238,
            "deletions": 54,
            "old_path": "",
            "new_path": "internal/reviewer/llmcontext/context.go",
            "is_binary": false
          },
          "internal/reviewer/llmcontext/mr_context.go": {
            "status": "modified",
            "additions": 37,
            "deletions": 373,
            "old_path": "",
            "new_path": "internal/reviewer/llmcontext/mr_context.go",
            "is_binary": false
          },
          "internal/reviewer/llmcontext/repodata.go": {
            "status": "added",
            "additions": 182,
            "deletions": 0,
            "old_path": "",
            "new_path": "internal/reviewer/llmcontext/repodata.go",
            "is_binary": false
          },
          "internal/reviewer/reviewer.go": {
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "old_path": "",
            "new_path": "internal/reviewer/reviewer.go",
            "is_binary": false
          },
          "test_ast_parser.go": {
            "status": "deleted",
            "additions": 0,
            "deletions": 115,
            "old_path": "",
            "new_path": "test_ast_parser.go",
            "is_binary": false
          }
        },
        "total_files": 14
      }
    ],
    "linked_issues": null,
    "linked_tickets": null,
    "file_diffs": [
      {
        "OldPath": "",
        "NewPath": "context_bundle.json",
        "Diff": "",
        "IsNew": false,
        "IsDeleted": false,
        "IsRenamed": false,
        "IsBinary": true,
        "ContentType": ""
      },
      {
        "OldPath": "",
        "NewPath": "internal/reviewer/astparser/context_manager.go",
        "Diff": "@@ -2,7 +2,6 @@ package astparser\n \n import (\n \t\"context\"\n-\t\"fmt\"\n \t\"path/filepath\"\n \t\"strings\"\n \n@@ -22,48 +21,6 @@ type ContextManager struct {\n \tlog            logze.Logger\n }\n \n-// ChangeType represents the type of file change\n-type ChangeType string\n-\n-const (\n-\tChangeTypeModified ChangeType = \"Modified\"\n-\tChangeTypeAdded    ChangeType = \"Added\"\n-\tChangeTypeDeleted  ChangeType = \"Deleted\"\n-\tChangeTypeRenamed  ChangeType = \"Renamed\"\n-)\n-\n-// ContextBundle represents the final structured context for LLM\n-type ContextBundle struct {\n-\tFiles []FileContext `json:\"files\"`\n-}\n-\n-// FileContext represents context for a single changed file\n-type FileContext struct {\n-\tFilePath        string           `json:\"file_path\"`\n-\tChangeType      ChangeType       `json:\"change_type\"`\n-\tDiff            string           `json:\"diff_hunk\"`\n-\tAffectedSymbols []AffectedSymbol `json:\"affected_symbols\"`\n-\tRelatedFiles    []RelatedFile    `json:\"related_files\"`\n-\tConfigContext   *ConfigContext   `json:\"config_context,omitempty\"`\n-}\n-\n-// RelatedFile represents a file related to the changed file\n-type RelatedFile struct {\n-\tFilePath         string `json:\"file_path\"`\n-\tRelationship     string `json:\"relationship\"` // \"caller\", \"dependency\", \"test\", \"same_package\"\n-\tCodeSnippet      string `json:\"code_snippet\"`\n-\tLine             int    `json:\"line,omitempty\"`\n-\tRelevantFunction string `json:\"relevant_function,omitempty\"`\n-}\n-\n-// ConfigContext represents context for configuration file changes\n-type ConfigContext struct {\n-\tConfigType       string        `json:\"config_type\"` // \"yaml\", \"json\", \"env\", etc.\n-\tChangedKeys      []string      `json:\"changed_keys\"`\n-\tConsumingCode    []RelatedFile `json:\"consuming_code\"`\n-\tImpactAssessment string        `json:\"impact_assessment\"`\n-}\n-\n // newContextFinder creates a new context finder\n func NewContextFinder(provider interfaces.CodeProvider) *ContextManager {\n \treturn \u0026ContextManager{\n@@ -84,11 +41,9 @@ type ContextRequest struct {\n }\n \n // GatherContext gathers comprehensive context for a merge request\n-func (cf *ContextManager) GatherContext(ctx context.Context, request ContextRequest) (*ContextBundle, error) {\n-\tbundle := \u0026ContextBundle{\n-\t\tFiles: make([]FileContext, 0, len(request.FileDiffs)),\n-\t}\n+func (cf *ContextManager) GatherFilesContext(ctx context.Context, request ContextRequest) ([]*FileContext, error) {\n \n+\tfiles := make([]*FileContext, 0, len(request.FileDiffs))\n \t// Process each changed file\n \tfor _, fileDiff := range request.FileDiffs {\n \t\tfileContext, err := cf.processFileDiff(ctx, request, fileDiff)\n@@ -98,11 +53,11 @@ func (cf *ContextManager) GatherContext(ctx context.Context, request ContextRequ\n \t\t}\n \n \t\tif fileContext != nil {\n-\t\t\tbundle.Files = append(bundle.Files, *fileContext)\n+\t\t\tfiles = append(files, fileContext)\n \t\t}\n \t}\n \n-\treturn bundle, nil\n+\treturn files, nil\n }\n \n // processFileDiff processes a single file diff to extract context\n@@ -117,7 +72,9 @@ func (cf *ContextManager) processFileDiff(ctx context.Context, request ContextRe\n \t}\n \n \tif cf.isConfigFile(fileDiff.NewPath) {\n-\t\treturn cf.processConfigFile(ctx, request, fileDiff, fileContext)\n+\t\t// TODO: add config file processing\n+\t\tcf.log.Warn(\"config file detected, skipping\", \"file\", fileDiff.NewPath)\n+\t\treturn fileContext, nil\n \t}\n \n \t// Handle different change types\n@@ -136,20 +93,6 @@ func (cf *ContextManager) processFileDiff(ctx context.Context, request ContextRe\n \treturn fileContext, nil\n }\n \n-// determineChangeType determines the type of change for a file\n-func (cf *ContextManager) determineChangeType(fileDiff *model.FileDiff) ChangeType {\n-\tif fileDiff.IsNew {\n-\t\treturn ChangeTypeAdded\n-\t}\n-\tif fileDiff.IsDeleted {\n-\t\treturn ChangeTypeDeleted\n-\t}\n-\tif fileDiff.IsRenamed {\n-\t\treturn ChangeTypeRenamed\n-\t}\n-\treturn ChangeTypeModified\n-}\n-\n // processAddedFile processes a newly added file\n func (cf *ContextManager) processAddedFile(ctx context.Context, request ContextRequest, fileDiff *model.FileDiff, fileContext *FileContext) (*FileContext, error) {\n \t// For new files, the entire file is \"affected\"\n@@ -167,13 +110,13 @@ func (cf *ContextManager) processAddedFile(ctx context.Context, request ContextR\n \t}\n \n \t// Find all symbols in the new file\n-\tallSymbols, err := cf.astParser.findAllSymbolsInFile(fileDiff.NewPath, content)\n+\tallSymbols, err := cf.astParser.FindAllSymbolsInFile(ctx, fileDiff.NewPath, content)\n \tif err != nil {\n \t\tcf.log.Warn(\"failed to find symbols in new file\", \"error\", err, \"file\", fileDiff.NewPath)\n \t\treturn fileContext, nil\n \t}\n \n-\t// For each symbol, find if it's already being used (cross-references within the same PR)\n+\t// For each symbol, find if it's already being used\n \tfor _, symbol := range allSymbols {\n \t\t// Analyze usage context\n \t\tusageContext, err := cf.symbolAnalyzer.AnalyzeSymbolUsage(ctx, request.RepoDataHead, symbol)\n@@ -184,14 +127,31 @@ func (cf *ContextManager) processAddedFile(ctx context.Context, request ContextR\n \n \t\t// Add caller information to related files\n \t\tfor _, caller := range usageContext.Callers {\n-\t\t\trelatedFile := RelatedFile{\n+\t\t\tsymbol.Callers = append(symbol.Callers, Dependency{\n+\t\t\t\tName: caller.FunctionName,\n+\t\t\t\tLine: caller.LineNumber,\n+\t\t\t\tType: SymbolTypeFunction,\n+\t\t\t\tCode: lang.Check(caller.CodeSnippet, caller.Code),\n+\t\t\t})\n+\t\t\tfileContext.RelatedFiles = append(fileContext.RelatedFiles, RelatedFile{\n \t\t\t\tFilePath:         caller.FilePath,\n \t\t\t\tRelationship:     \"caller\",\n \t\t\t\tCodeSnippet:      caller.CodeSnippet,\n \t\t\t\tLine:             caller.LineNumber,\n \t\t\t\tRelevantFunction: caller.FunctionName,\n+\t\t\t})\n+\t\t}\n+\n+\t\tdepMap := make(map[string]Dependency)\n+\t\tfor _, dep := range usageContext.Dependencies {\n+\t\t\tdepMap[dep.SymbolName] = Dependency{\n+\t\t\t\tName: dep.SymbolName,\n+\t\t\t\tCode: dep.Code,\n \t\t\t}\n-\t\t\tfileContext.RelatedFiles = append(fileContext.RelatedFiles, relatedFile)\n+\t\t}\n+\n+\t\tfor i := range symbol.Dependencies {\n+\t\t\tsymbol.Dependencies[i].Code = depMap[symbol.Dependencies[i].Name].Code\n \t\t}\n \n \t\t// Set usage context for the symbol\n@@ -220,7 +180,7 @@ func (cf *ContextManager) processDeletedFile(ctx context.Context, request Contex\n \t}\n \n \t// Find all symbols that were in the deleted file\n-\tallSymbols, err := cf.astParser.findAllSymbolsInFile(fileDiff.OldPath, content)\n+\tallSymbols, err := cf.astParser.FindAllSymbolsInFile(ctx, fileDiff.OldPath, content)\n \tif err != nil {\n \t\tcf.log.Warn(\"failed to find symbols in deleted file\", \"error\", err, \"file\", fileDiff.OldPath)\n \t\treturn fileContext, nil\n@@ -234,18 +194,37 @@ func (cf *ContextManager) processDeletedFile(ctx context.Context, request Contex\n \t\t\tcontinue\n \t\t}\n \n-\t\t// Any callers found indicate potential issues\n+\t\t// Add caller information to related files\n \t\tfor _, caller := range usageContext.Callers {\n-\t\t\trelatedFile := RelatedFile{\n+\t\t\tsymbol.Callers = append(symbol.Callers, Dependency{\n+\t\t\t\tName: caller.FunctionName,\n+\t\t\t\tLine: caller.LineNumber,\n+\t\t\t\tType: SymbolTypeFunction,\n+\t\t\t\tCode: lang.Check(caller.CodeSnippet, caller.Code),\n+\t\t\t})\n+\t\t\tfileContext.RelatedFiles = append(fileContext.RelatedFiles, RelatedFile{\n \t\t\t\tFilePath:         caller.FilePath,\n-\t\t\t\tRelationship:     \"broken_caller\",\n+\t\t\t\tRelationship:     \"caller\",\n \t\t\t\tCodeSnippet:      caller.CodeSnippet,\n \t\t\t\tLine:             caller.LineNumber,\n \t\t\t\tRelevantFunction: caller.FunctionName,\n+\t\t\t})\n+\t\t}\n+\n+\t\tdepMap := make(map[string]Dependency)\n+\t\tfor _, dep := range usageContext.Dependencies {\n+\t\t\tdepMap[dep.SymbolName] = Dependency{\n+\t\t\t\tName: dep.SymbolName,\n+\t\t\t\tCode: dep.Code,\n \t\t\t}\n-\t\t\tfileContext.RelatedFiles = append(fileContext.RelatedFiles, relatedFile)\n \t\t}\n \n+\t\tfor i := range symbol.Dependencies {\n+\t\t\tsymbol.Dependencies[i].Code = depMap[symbol.Dependencies[i].Name].Code\n+\t\t}\n+\n+\t\t// Set usage context for the symbol\n+\t\tsymbol.Context.Package = cf.extractPackageFromPath(fileDiff.NewPath)\n \t\tfileContext.AffectedSymbols = append(fileContext.AffectedSymbols, symbol)\n \t}\n \n@@ -296,27 +275,46 @@ func (cf *ContextManager) processModifiedFile(ctx context.Context, request Conte\n \t\t\tcontinue\n \t\t}\n \n-\t\t// Add caller information\n+\t\t// Add caller information to related files\n \t\tfor _, caller := range usageContext.Callers {\n-\t\t\trelatedFile := RelatedFile{\n+\t\t\tsymbol.Callers = append(symbol.Callers, Dependency{\n+\t\t\t\tName: caller.FunctionName,\n+\t\t\t\tLine: caller.LineNumber,\n+\t\t\t\tType: SymbolTypeFunction,\n+\t\t\t\tCode: lang.Check(caller.CodeSnippet, caller.Code),\n+\t\t\t})\n+\t\t\tfileContext.RelatedFiles = append(fileContext.RelatedFiles, RelatedFile{\n \t\t\t\tFilePath:         caller.FilePath,\n \t\t\t\tRelationship:     \"caller\",\n \t\t\t\tCodeSnippet:      caller.CodeSnippet,\n \t\t\t\tLine:             caller.LineNumber,\n \t\t\t\tRelevantFunction: caller.FunctionName,\n+\t\t\t})\n+\t\t}\n+\n+\t\tdepMap := make(map[string]Dependency)\n+\t\tfor _, dep := range usageContext.Dependencies {\n+\t\t\tdepMap[dep.SymbolName] = Dependency{\n+\t\t\t\tName: dep.SymbolName,\n+\t\t\t\tCode: dep.Code,\n \t\t\t}\n-\t\t\tfileContext.RelatedFiles = append(fileContext.RelatedFiles, relatedFile)\n \t\t}\n \n+\t\tfor i := range symbol.Dependencies {\n+\t\t\tsymbol.Dependencies[i].Code = depMap[symbol.Dependencies[i].Name].Code\n+\t\t}\n+\n+\t\t// Set usage context for the symbol\n+\t\tsymbol.Context.Package = cf.extractPackageFromPath(fileDiff.NewPath)\n+\n \t\t// Add dependency information\n \t\tfor _, dep := range usageContext.Dependencies {\n \t\t\tif dep.SourceFile == \"internal\" \u0026\u0026 dep.SymbolName != \"\" {\n-\t\t\t\trelatedFile := RelatedFile{\n+\t\t\t\tfileContext.RelatedFiles = append(fileContext.RelatedFiles, RelatedFile{\n \t\t\t\t\tFilePath:         dep.SourceFile,\n \t\t\t\t\tRelationship:     \"dependency\",\n \t\t\t\t\tRelevantFunction: dep.SymbolName,\n-\t\t\t\t}\n-\t\t\t\tfileContext.RelatedFiles = append(fileContext.RelatedFiles, relatedFile)\n+\t\t\t\t})\n \t\t\t}\n \t\t}\n \n@@ -326,40 +324,6 @@ func (cf *ContextManager) processModifiedFile(ctx context.Context, request Conte\n \treturn fileContext, nil\n }\n \n-// processConfigFile processes changes in configuration files\n-func (cf *ContextManager) processConfigFile(ctx context.Context, request ContextRequest, fileDiff *model.FileDiff, fileContext *FileContext) (*FileContext, error) {\n-\t// Extract changed configuration keys\n-\tchangedKeys := cf.extractChangedConfigKeys(fileDiff.Diff)\n-\n-\t// Find code that consumes this configuration\n-\tconsumers, err := cf.symbolAnalyzer.findConfigFileConsumers(ctx, request.ProjectID, request.MergeRequest.SHA, fileDiff.NewPath)\n-\tif err != nil {\n-\t\tcf.log.Warn(\"failed to find config file consumers\", \"error\", err, \"file\", fileDiff.NewPath)\n-\t}\n-\n-\t// Create config context\n-\tconfigContext := \u0026ConfigContext{\n-\t\tConfigType:       cf.detectConfigType(fileDiff.NewPath),\n-\t\tChangedKeys:      changedKeys,\n-\t\tConsumingCode:    make([]RelatedFile, 0),\n-\t\tImpactAssessment: cf.assessConfigImpact(changedKeys),\n-\t}\n-\n-\t// Add consuming code as related files\n-\tfor _, consumer := range consumers {\n-\t\trelatedFile := RelatedFile{\n-\t\t\tFilePath:     consumer,\n-\t\t\tRelationship: \"config_consumer\",\n-\t\t}\n-\t\tconfigContext.ConsumingCode = append(configContext.ConsumingCode, relatedFile)\n-\t\tfileContext.RelatedFiles = append(fileContext.RelatedFiles, relatedFile)\n-\t}\n-\n-\tfileContext.ConfigContext = configContext\n-\n-\treturn fileContext, nil\n-}\n-\n // Helper methods\n \n // extractContentFromDiff extracts file content from diff (for new files)\n@@ -376,13 +340,6 @@ func (cf *ContextManager) extractContentFromDiff(diff string) string {\n \treturn strings.Join(content, \"\\n\")\n }\n \n-// getBaseFileContent gets the file content from the base branch\n-func (cf *ContextManager) getBaseFileContent(ctx context.Context, request model.ReviewRequest, filePath string) (string, error) {\n-\t// This would ideally get the content from the base branch\n-\t// For now, we'll try to get it from the current SHA as a fallback\n-\treturn cf.provider.GetFileContent(ctx, request.ProjectID, filePath, request.MergeRequest.SHA)\n-}\n-\n // isConfigFile checks if a file is a configuration file\n func (cf *ContextManager) isConfigFile(filePath string) bool {\n \tconfigExtensions := []string{\".yaml\", \".yml\", \".json\", \".toml\", \".ini\", \".conf\", \".config\", \".env\"}\n@@ -408,121 +365,6 @@ func (cf *ContextManager) isConfigFile(filePath string) bool {\n \treturn false\n }\n \n-// extractChangedConfigKeys extracts configuration keys that were changed\n-func (cf *ContextManager) extractChangedConfigKeys(diff string) []string {\n-\tvar keys []string\n-\tlines := strings.Split(diff, \"\\n\")\n-\n-\tfor _, line := range lines {\n-\t\tif strings.HasPrefix(line, \"+\") || strings.HasPrefix(line, \"-\") {\n-\t\t\t// Simple key extraction (this could be enhanced with proper YAML/JSON parsing)\n-\t\t\tkey := cf.extractKeyFromConfigLine(line[1:]) // Remove +/- prefix\n-\t\t\tif key != \"\" {\n-\t\t\t\tkeys = append(keys, key)\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\treturn keys\n-}\n-\n-// extractKeyFromConfigLine extracts a configuration key from a config file line\n-func (cf *ContextManager) extractKeyFromConfigLine(line string) string {\n-\tline = strings.TrimSpace(line)\n-\n-\t// YAML style: key: value\n-\tif colonIndex := strings.Index(line, \":\"); colonIndex != -1 {\n-\t\tkey := strings.TrimSpace(line[:colonIndex])\n-\t\t// Remove any leading dashes (YAML list items)\n-\t\tkey = strings.TrimLeft(key, \"- \")\n-\t\treturn key\n-\t}\n-\n-\t// JSON style: \"key\": value\n-\tif strings.Contains(line, \"\\\":\") {\n-\t\tparts := strings.Split(line, \"\\\":\")\n-\t\tif len(parts) \u003e 0 {\n-\t\t\tkey := strings.Trim(parts[0], \"\\\"\")\n-\t\t\tkey = strings.TrimSpace(key)\n-\t\t\treturn key\n-\t\t}\n-\t}\n-\n-\treturn \"\"\n-}\n-\n-// detectConfigType detects the type of configuration file\n-func (cf *ContextManager) detectConfigType(filePath string) string {\n-\text := strings.ToLower(filepath.Ext(filePath))\n-\tfilename := strings.ToLower(filepath.Base(filePath))\n-\n-\tswitch ext {\n-\tcase \".yaml\", \".yml\":\n-\t\treturn \"yaml\"\n-\tcase \".json\":\n-\t\treturn \"json\"\n-\tcase \".toml\":\n-\t\treturn \"toml\"\n-\tcase \".ini\":\n-\t\treturn \"ini\"\n-\tcase \".env\":\n-\t\treturn \"env\"\n-\tdefault:\n-\t\t// Check specific filenames\n-\t\tif filename == \"makefile\" {\n-\t\t\treturn \"makefile\"\n-\t\t}\n-\t\tif filename == \"dockerfile\" {\n-\t\t\treturn \"dockerfile\"\n-\t\t}\n-\t\treturn \"unknown\"\n-\t}\n-}\n-\n-// assessConfigImpact provides an impact assessment for configuration changes\n-func (cf *ContextManager) assessConfigImpact(changedKeys []string) string {\n-\tif len(changedKeys) == 0 {\n-\t\treturn \"No configuration keys changed\"\n-\t}\n-\n-\t// Simple impact assessment based on key names\n-\thighImpactKeys := []string{\"database\", \"db\", \"password\", \"secret\", \"api_key\", \"token\", \"host\", \"port\", \"url\"}\n-\tmediumImpactKeys := []string{\"timeout\", \"retry\", \"cache\", \"log\", \"debug\", \"feature\", \"flag\"}\n-\n-\thighImpactCount := 0\n-\tmediumImpactCount := 0\n-\n-\tfor _, key := range changedKeys {\n-\t\tlowerKey := strings.ToLower(key)\n-\n-\t\tisHighImpact := false\n-\t\tfor _, highKey := range highImpactKeys {\n-\t\t\tif strings.Contains(lowerKey, highKey) {\n-\t\t\t\thighImpactCount++\n-\t\t\t\tisHighImpact = true\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t}\n-\n-\t\tif !isHighImpact {\n-\t\t\tfor _, mediumKey := range mediumImpactKeys {\n-\t\t\t\tif strings.Contains(lowerKey, mediumKey) {\n-\t\t\t\t\tmediumImpactCount++\n-\t\t\t\t\tbreak\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tif highImpactCount \u003e 0 {\n-\t\treturn fmt.Sprintf(\"High impact: %d critical configuration keys changed\", highImpactCount)\n-\t} else if mediumImpactCount \u003e 0 {\n-\t\treturn fmt.Sprintf(\"Medium impact: %d configuration keys changed\", mediumImpactCount)\n-\t} else {\n-\t\treturn fmt.Sprintf(\"Low impact: %d configuration keys changed\", len(changedKeys))\n-\t}\n-}\n-\n // extractPackageFromPath extracts package/module name from file path\n func (cf *ContextManager) extractPackageFromPath(filePath string) string {\n \tdir := filepath.Dir(filePath)",
        "IsNew": false,
        "IsDeleted": false,
        "IsRenamed": false,
        "IsBinary": false,
        "ContentType": ""
      },
      {
        "OldPath": "",
        "NewPath": "internal/reviewer/astparser/diff_parser.go",
        "Diff": "@@ -988,7 +988,7 @@ func (dp *DiffParser) CreateLineToSymbolMap(filePath, content string, astParser\n \tlineToSymbols := make(map[int][]AffectedSymbol)\n \n \t// Parse file to get all symbols\n-\trootNode, err := astParser.ParseFileToAST(context.Background(), filePath, content)\n+\trootNode, err := astParser.GetFileAST(context.Background(), filePath, content)\n \tif err != nil {\n \t\treturn nil, err\n \t}",
        "IsNew": false,
        "IsDeleted": false,
        "IsRenamed": false,
        "IsBinary": false,
        "ContentType": ""
      },
      {
        "OldPath": "",
        "NewPath": "internal/reviewer/astparser/languages.go",
        "Diff": "@@ -318,36 +318,97 @@ var symbolNodes = map[string]bool{\n \t\"struct_type\":          true,\n \t\"func_literal\":         true,\n \t\"method_spec\":          true,\n+\t\"function_spec\":        true,\n \n \t// JavaScript/TypeScript\n \t\"function_expression\":    true,\n \t\"arrow_function\":         true,\n \t\"method_definition\":      true,\n-\t\"class_declaration\":      true,\n \t\"variable_declaration\":   true,\n \t\"variable_declarator\":    true,\n-\t\"interface_declaration\":  true,\n \t\"type_alias_declaration\": true,\n-\t\"enum_declaration\":       true,\n \t\"namespace_declaration\":  true,\n \t\"module_declaration\":     true,\n \t\"export_statement\":       true,\n \t\"import_statement\":       true,\n \t\"lexical_declaration\":    true,\n \n \t// Python\n-\t\"function_def\":     true, // function_definition\n-\t\"class_definition\": true,\n+\t\"function_definition\":  true,\n+\t\"async_function_def\":   true,\n+\t\"decorated_definition\": true,\n \n \t// Java\n \t\"constructor_declaration\":    true,\n \t\"local_variable_declaration\": true,\n+\t\"field_declaration\":          true,\n \n \t// C/C++\n-\t\"function_definition\":                   true,\n \t\"constructor_or_destructor_declaration\": true,\n \t\"struct_specifier\":                      true,\n \t\"union_specifier\":                       true,\n \t\"enum_specifier\":                        true,\n-\t\"class_specifier\":                       true,\n+\t\"function_declarator\":                   true,\n+\t\"declaration\":                           true,\n+\n+\t// C#\n+\t\"property_declaration\": true,\n+\t\"struct_declaration\":   true,\n+\n+\t// Ruby\n+\t\"method\":            true,\n+\t\"module\":            true,\n+\t\"def\":               true,\n+\t\"class_definition\":  true,\n+\t\"module_definition\": true,\n+\n+\t// Rust\n+\t\"function_item\": true,\n+\t\"struct_item\":   true,\n+\t\"enum_item\":     true,\n+\t\"trait_item\":    true,\n+\t\"impl_item\":     true,\n+\t\"mod_item\":      true,\n+\t\"const_item\":    true,\n+\t\"static_item\":   true,\n+\n+\t// Swift\n+\t\"enum_declaration\":     true,\n+\t\"protocol_declaration\": true,\n+\t\"constant_declaration\": true,\n+\n+\t// Kotlin\n+\t\"object_declaration\": true,\n+\n+\t// Scala\n+\t\"object_definition\": true,\n+\t\"trait_definition\":  true,\n+\t\"val_definition\":    true,\n+\t\"var_definition\":    true,\n+\n+\t// Elixir\n+\t\"function\":    true,\n+\t\"defp\":        true,\n+\t\"defmodule\":   true,\n+\t\"defstruct\":   true,\n+\t\"defprotocol\": true,\n+\n+\t// Lua\n+\t\"function_statement\":       true,\n+\t\"local_function_statement\": true,\n+\t\"local_statement\":          true,\n+\n+\t// OCaml\n+\t\"value_definition\":     true,\n+\t\"type_definition\":      true,\n+\t\"exception_definition\": true,\n+\n+\t// Svelte\n+\t\"script\":    true,\n+\t\"component\": true,\n+\n+\t// Generic patterns that might be missed\n+\t\"definition\":    true,\n+\t\"specification\": true,\n+\t\"declarator\":    true,\n }",
        "IsNew": false,
        "IsDeleted": false,
        "IsRenamed": false,
        "IsBinary": false,
        "ContentType": ""
      },
      {
        "OldPath": "",
        "NewPath": "internal/reviewer/astparser/parser.go",
        "Diff": "@@ -5,15 +5,11 @@ import (\n \t\"maps\"\n \t\"strings\"\n \n+\t\"github.com/maxbolgarin/abstract\"\n \t\"github.com/maxbolgarin/errm\"\n \tsitter \"github.com/smacker/go-tree-sitter\"\n )\n \n-// Parser handles parsing code using Tree-sitter to map lines to syntax nodes\n-type Parser struct {\n-\tlanguages map[ProgrammingLanguage]*sitter.Language\n-}\n-\n // SymbolType represents the type of a code symbol\n type SymbolType string\n \n@@ -62,6 +58,7 @@ type Dependency struct {\n \tSnippet string     `json:\"snippet\"`\n \tLine    int        `json:\"line\"`\n \tType    SymbolType `json:\"type\"`\n+\tCode    string     `json:\"code\"`\n }\n \n // NodePosition represents a position in the source code\n@@ -72,17 +69,29 @@ type NodePosition struct {\n \tEndColumn   int\n }\n \n+// Parser handles parsing code using Tree-sitter to map lines to syntax nodes\n+type Parser struct {\n+\tlanguages map[ProgrammingLanguage]*sitter.Language\n+\n+\tastCache *abstract.SafeMap[string, *sitter.Node]\n+}\n+\n // NewParser creates a new AST parser with supported languages\n func NewParser() *Parser {\n \tlanguages := make(map[ProgrammingLanguage]*sitter.Language, len(languagesParsers))\n \tmaps.Copy(languages, languagesParsers)\n \treturn \u0026Parser{\n \t\tlanguages: languages,\n+\t\tastCache:  abstract.NewSafeMap[string, *sitter.Node](),\n \t}\n }\n \n // ParseFileToAST parses a file's content to AST using Tree-sitter\n-func (p *Parser) ParseFileToAST(ctx context.Context, filePath, content string) (*sitter.Node, error) {\n+func (p *Parser) GetFileAST(ctx context.Context, filePath, content string) (*sitter.Node, error) {\n+\tif node, ok := p.astCache.Lookup(filePath); ok {\n+\t\treturn node, nil\n+\t}\n+\n \tlanguage := DetectProgrammingLanguage(filePath)\n \tlanguageParser, ok := p.languages[language]\n \tif !ok {\n@@ -97,6 +106,8 @@ func (p *Parser) ParseFileToAST(ctx context.Context, filePath, content string) (\n \t\treturn nil, errm.Wrap(err, \"failed to parse AST\", \"file\", filePath)\n \t}\n \n+\tp.astCache.Set(filePath, tree.RootNode())\n+\n \treturn tree.RootNode(), nil\n }\n \n@@ -138,7 +149,7 @@ func (p *Parser) findSmallestEnclosingNodeRecursive(node *sitter.Node, lineNumbe\n \n // FindAffectedSymbols finds all symbols affected by changes in the given lines\n func (p *Parser) FindAffectedSymbols(ctx context.Context, filePath, fileContent string, changedLines []int) ([]AffectedSymbol, error) {\n-\trootNode, err := p.ParseFileToAST(ctx, filePath, fileContent)\n+\trootNode, err := p.GetFileAST(ctx, filePath, fileContent)\n \tif err != nil {\n \t\treturn nil, errm.Wrap(err, \"failed to parse file to AST\", \"file\", filePath)\n \t}\n@@ -204,7 +215,7 @@ func (p *Parser) ExtractSymbolFromNode(node *sitter.Node, filePath, fileContent\n \t\tFilePath:  filePath,\n \t\tStartLine: int(node.StartPoint().Row) + 1, // Convert to 1-based\n \t\tEndLine:   int(node.EndPoint().Row) + 1,   // Convert to 1-based\n-\t\tName:      p.extractSymbolName(node, fileContent),\n+\t\tName:      p.extractSymbolName(node, fileContent, filePath),\n \t\tType:      getSymbolType(node.Type()),\n \t}\n \tsymbol.DocComment = p.extractDocComment(node, fileContent, symbol.StartLine)\n@@ -221,19 +232,215 @@ func (p *Parser) ExtractSymbolFromNode(node *sitter.Node, filePath, fileContent\n }\n \n // extractSymbolName extracts the symbol name from a symbol declaration node\n-func (p *Parser) extractSymbolName(node *sitter.Node, content string) string {\n+func (p *Parser) extractSymbolName(node *sitter.Node, content string, filePath string) string {\n \tchildCount := int(node.ChildCount())\n+\n+\t// First, try to find a direct identifier child\n \tfor i := 0; i \u003c childCount; i++ {\n \t\tchild := node.Child(i)\n \t\tif child == nil {\n \t\t\tcontinue\n \t\t}\n \n \t\tchildType := child.Type()\n-\t\tif strings.Contains(childType, \"identifier\") {\n-\t\t\treturn p.getNodeText(child, content)\n+\t\tif strings.Contains(childType, \"identifier\") ||\n+\t\t\tstrings.Contains(childType, \"name\") ||\n+\t\t\tstrings.Contains(childType, \"variable_name\") ||\n+\t\t\tstrings.Contains(childType, \"function_name\") ||\n+\t\t\tstrings.Contains(childType, \"class_name\") ||\n+\t\t\tstrings.Contains(childType, \"method_name\") {\n+\t\t\tname := p.getNodeText(child, content)\n+\t\t\tif name != \"\" {\n+\t\t\t\treturn name\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// For languages with different patterns, try alternative approaches\n+\tlanguage := DetectProgrammingLanguage(filePath)\n+\tswitch language {\n+\tcase LanguageGo:\n+\t\treturn p.extractGoSymbolName(node, content)\n+\tcase LanguageJavaScript, LanguageTypeScript, LanguageTSX:\n+\t\treturn p.extractJSSymbolName(node, content)\n+\tcase LanguagePython:\n+\t\treturn p.extractPythonSymbolName(node, content)\n+\tcase LanguageJava:\n+\t\treturn p.extractJavaSymbolName(node, content)\n+\tcase LanguageCpp:\n+\t\treturn p.extractCppSymbolName(node, content)\n+\t}\n+\n+\t// Fallback: look for any identifier in the node\n+\treturn p.findFirstIdentifier(node, content)\n+}\n+\n+// extractGoSymbolName extracts symbol names from Go AST nodes\n+func (p *Parser) extractGoSymbolName(node *sitter.Node, content string) string {\n+\tnodeType := node.Type()\n+\n+\tswitch nodeType {\n+\tcase \"function_declaration\", \"method_declaration\":\n+\t\t// Look for the function name in the function spec\n+\t\tfor i := 0; i \u003c int(node.ChildCount()); i++ {\n+\t\t\tchild := node.Child(i)\n+\t\t\tif child != nil \u0026\u0026 child.Type() == \"function_spec\" {\n+\t\t\t\treturn p.extractGoSymbolName(child, content)\n+\t\t\t}\n+\t\t}\n+\tcase \"function_spec\":\n+\t\t// Function name is usually the first identifier\n+\t\tfor i := 0; i \u003c int(node.ChildCount()); i++ {\n+\t\t\tchild := node.Child(i)\n+\t\t\tif child != nil \u0026\u0026 strings.Contains(child.Type(), \"identifier\") {\n+\t\t\t\treturn p.getNodeText(child, content)\n+\t\t\t}\n+\t\t}\n+\tcase \"type_declaration\", \"var_declaration\", \"const_declaration\":\n+\t\t// Look for the type/var/const spec\n+\t\tfor i := 0; i \u003c int(node.ChildCount()); i++ {\n+\t\t\tchild := node.Child(i)\n+\t\t\tif child != nil \u0026\u0026 (strings.Contains(child.Type(), \"spec\") || strings.Contains(child.Type(), \"declaration\")) {\n+\t\t\t\treturn p.extractGoSymbolName(child, content)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn p.findFirstIdentifier(node, content)\n+}\n+\n+// extractJSSymbolName extracts symbol names from JavaScript/TypeScript AST nodes\n+func (p *Parser) extractJSSymbolName(node *sitter.Node, content string) string {\n+\tnodeType := node.Type()\n+\n+\tswitch nodeType {\n+\tcase \"function_declaration\", \"function_expression\", \"arrow_function\":\n+\t\t// Look for the function name\n+\t\tfor i := 0; i \u003c int(node.ChildCount()); i++ {\n+\t\t\tchild := node.Child(i)\n+\t\t\tif child != nil \u0026\u0026 child.Type() == \"identifier\" {\n+\t\t\t\treturn p.getNodeText(child, content)\n+\t\t\t}\n+\t\t}\n+\tcase \"class_declaration\":\n+\t\t// Look for the class name\n+\t\tfor i := 0; i \u003c int(node.ChildCount()); i++ {\n+\t\t\tchild := node.Child(i)\n+\t\t\tif child != nil \u0026\u0026 child.Type() == \"identifier\" {\n+\t\t\t\treturn p.getNodeText(child, content)\n+\t\t\t}\n+\t\t}\n+\tcase \"variable_declarator\":\n+\t\t// Look for the variable name\n+\t\tfor i := 0; i \u003c int(node.ChildCount()); i++ {\n+\t\t\tchild := node.Child(i)\n+\t\t\tif child != nil \u0026\u0026 child.Type() == \"identifier\" {\n+\t\t\t\treturn p.getNodeText(child, content)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn p.findFirstIdentifier(node, content)\n+}\n+\n+// extractPythonSymbolName extracts symbol names from Python AST nodes\n+func (p *Parser) extractPythonSymbolName(node *sitter.Node, content string) string {\n+\tnodeType := node.Type()\n+\n+\tswitch nodeType {\n+\tcase \"function_definition\":\n+\t\t// Look for the function name\n+\t\tfor i := 0; i \u003c int(node.ChildCount()); i++ {\n+\t\t\tchild := node.Child(i)\n+\t\t\tif child != nil \u0026\u0026 child.Type() == \"identifier\" {\n+\t\t\t\treturn p.getNodeText(child, content)\n+\t\t\t}\n+\t\t}\n+\tcase \"class_definition\":\n+\t\t// Look for the class name\n+\t\tfor i := 0; i \u003c int(node.ChildCount()); i++ {\n+\t\t\tchild := node.Child(i)\n+\t\t\tif child != nil \u0026\u0026 child.Type() == \"identifier\" {\n+\t\t\t\treturn p.getNodeText(child, content)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn p.findFirstIdentifier(node, content)\n+}\n+\n+// extractJavaSymbolName extracts symbol names from Java AST nodes\n+func (p *Parser) extractJavaSymbolName(node *sitter.Node, content string) string {\n+\tnodeType := node.Type()\n+\n+\tswitch nodeType {\n+\tcase \"method_declaration\", \"constructor_declaration\":\n+\t\t// Look for the method/constructor name\n+\t\tfor i := 0; i \u003c int(node.ChildCount()); i++ {\n+\t\t\tchild := node.Child(i)\n+\t\t\tif child != nil \u0026\u0026 child.Type() == \"identifier\" {\n+\t\t\t\treturn p.getNodeText(child, content)\n+\t\t\t}\n+\t\t}\n+\tcase \"class_declaration\", \"interface_declaration\":\n+\t\t// Look for the class/interface name\n+\t\tfor i := 0; i \u003c int(node.ChildCount()); i++ {\n+\t\t\tchild := node.Child(i)\n+\t\t\tif child != nil \u0026\u0026 child.Type() == \"identifier\" {\n+\t\t\t\treturn p.getNodeText(child, content)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn p.findFirstIdentifier(node, content)\n+}\n+\n+// extractCppSymbolName extracts symbol names from C++ AST nodes\n+func (p *Parser) extractCppSymbolName(node *sitter.Node, content string) string {\n+\tnodeType := node.Type()\n+\n+\tswitch nodeType {\n+\tcase \"function_definition\", \"function_declarator\":\n+\t\t// Look for the function name\n+\t\tfor i := 0; i \u003c int(node.ChildCount()); i++ {\n+\t\t\tchild := node.Child(i)\n+\t\t\tif child != nil \u0026\u0026 child.Type() == \"identifier\" {\n+\t\t\t\treturn p.getNodeText(child, content)\n+\t\t\t}\n+\t\t}\n+\tcase \"class_specifier\", \"struct_specifier\":\n+\t\t// Look for the class/struct name\n+\t\tfor i := 0; i \u003c int(node.ChildCount()); i++ {\n+\t\t\tchild := node.Child(i)\n+\t\t\tif child != nil \u0026\u0026 child.Type() == \"identifier\" {\n+\t\t\t\treturn p.getNodeText(child, content)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn p.findFirstIdentifier(node, content)\n+}\n+\n+// findFirstIdentifier finds the first identifier in a node tree\n+func (p *Parser) findFirstIdentifier(node *sitter.Node, content string) string {\n+\tif node == nil {\n+\t\treturn \"\"\n+\t}\n+\n+\tif strings.Contains(node.Type(), \"identifier\") {\n+\t\treturn p.getNodeText(node, content)\n+\t}\n+\n+\tchildCount := int(node.ChildCount())\n+\tfor i := 0; i \u003c childCount; i++ {\n+\t\tchild := node.Child(i)\n+\t\tif child != nil {\n+\t\t\tif result := p.findFirstIdentifier(child, content); result != \"\" {\n+\t\t\t\treturn result\n+\t\t\t}\n \t\t}\n \t}\n+\n \treturn \"\"\n }\n \n@@ -271,7 +478,107 @@ func (p *Parser) extractDependencies(node *sitter.Node, content string, isRootFu\n \n \tp.walkNodeForDependencies(node, content, \u0026dependencies, isRootFunction, true)\n \n-\treturn dependencies\n+\t// Filter out standard library calls and basic operations\n+\treturn p.filterDependencies(dependencies)\n+}\n+\n+// filterDependencies filters out standard library calls and basic operations\n+func (p *Parser) filterDependencies(dependencies []Dependency) []Dependency {\n+\tvar filtered []Dependency\n+\n+\tfor _, dep := range dependencies {\n+\t\tif p.shouldIncludeDependency(dep) {\n+\t\t\tfiltered = append(filtered, dep)\n+\t\t}\n+\t}\n+\n+\treturn filtered\n+}\n+\n+// shouldIncludeDependency determines if a dependency should be included\n+func (p *Parser) shouldIncludeDependency(dep Dependency) bool {\n+\t// Skip empty names\n+\tif dep.Name == \"\" {\n+\t\treturn false\n+\t}\n+\n+\t// Skip standard library calls\n+\tif p.isStandardLibraryCall(dep.Name) {\n+\t\treturn false\n+\t}\n+\n+\t// Skip basic operations and common patterns\n+\tif p.isBasicOperation(dep.Name) {\n+\t\treturn false\n+\t}\n+\n+\t// Skip self-references and common patterns\n+\tif p.isSelfReference(dep.Name) {\n+\t\treturn false\n+\t}\n+\n+\treturn true\n+}\n+\n+// isStandardLibraryCall checks if a call is to a standard library function\n+func (p *Parser) isStandardLibraryCall(name string) bool {\n+\t// Common standard library patterns\n+\tstdLibPatterns := []string{\n+\t\t\"std::\", \"java.\", \"System.\", \"String.\", \"Integer.\", \"List.\", \"Map.\", \"Set.\",\n+\t\t\"os.\", \"sys.\", \"json.\", \"time.\", \"datetime.\", \"re.\", \"collections.\",\n+\t\t\"fmt.\", \"strings.\", \"strconv.\", \"io.\", \"net.\", \"http.\", \"encoding.\",\n+\t\t\"console.\", \"Math.\", \"Array.\", \"Object.\", \"JSON.\", \"Date.\",\n+\t\t\"print\", \"println\", \"printf\", \"sprintf\", \"fprintf\",\n+\t\t\"len\", \"cap\", \"make\", \"new\", \"append\", \"copy\",\n+\t\t\"len\", \"str\", \"int\", \"float\", \"bool\", \"list\", \"dict\", \"set\",\n+\t\t\"toString\", \"equals\", \"hashCode\", \"compareTo\",\n+\t\t\"substring\", \"indexOf\", \"contains\", \"startsWith\", \"endsWith\",\n+\t\t\"toLowerCase\", \"toUpperCase\", \"trim\", \"split\", \"join\",\n+\t\t\"push\", \"pop\", \"shift\", \"unshift\", \"slice\", \"splice\",\n+\t\t\"add\", \"remove\", \"get\", \"set\", \"put\", \"getOrDefault\",\n+\t}\n+\n+\tfor _, pattern := range stdLibPatterns {\n+\t\tif strings.Contains(name, pattern) {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\n+\treturn false\n+}\n+\n+// isBasicOperation checks if a call is a basic operation\n+func (p *Parser) isBasicOperation(name string) bool {\n+\tbasicOps := []string{\n+\t\t\"+\", \"-\", \"*\", \"/\", \"%\", \"=\", \"==\", \"!=\", \"\u003c\", \"\u003e\", \"\u003c=\", \"\u003e=\",\n+\t\t\"\u0026\u0026\", \"||\", \"!\", \"\u0026\", \"|\", \"^\", \"\u003c\u003c\", \"\u003e\u003e\",\n+\t\t\"++\", \"--\", \"+=\", \"-=\", \"*=\", \"/=\", \"%=\",\n+\t\t\"-\u003e\", \".\", \"::\", \"[]\", \"()\", \"{}\",\n+\t}\n+\n+\tfor _, op := range basicOps {\n+\t\tif name == op {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\n+\treturn false\n+}\n+\n+// isSelfReference checks if a call is a self-reference\n+func (p *Parser) isSelfReference(name string) bool {\n+\tselfRefs := []string{\n+\t\t\"this\", \"self\", \"super\", \"base\", \"me\", \"current\",\n+\t\t\"this.\", \"self.\", \"super.\", \"base.\", \"me.\", \"current.\",\n+\t}\n+\n+\tfor _, ref := range selfRefs {\n+\t\tif strings.Contains(name, ref) {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\n+\treturn false\n }\n \n // walkNodeForDependencies recursively walks the AST to find function calls\n@@ -281,14 +588,15 @@ func (p *Parser) walkNodeForDependencies(node *sitter.Node, content string, depe\n \t// Check if this node represents a function call\n \tif strings.Contains(nodeType, \"call\") {\n \t\tcall := p.extractDependency(node, content)\n-\t\tif call.Name != \"\" {\n+\t\tif call.Name != \"\" \u0026\u0026 p.isSignificantCall(call.Name) {\n \t\t\t*dependencies = append(*dependencies, call)\n \t\t}\n \t}\n \n+\t// Only include declarations/definitions if they're not the root function\n \tif !isRootFunction \u0026\u0026 !isFirstNode \u0026\u0026 (strings.Contains(nodeType, \"declaration\") || strings.Contains(nodeType, \"definition\")) {\n \t\tdeclaration := p.extractDependency(node, content)\n-\t\tif declaration.Name != \"\" {\n+\t\tif declaration.Name != \"\" \u0026\u0026 p.isSignificantDeclaration(declaration.Name) {\n \t\t\t*dependencies = append(*dependencies, declaration)\n \t\t}\n \t}\n@@ -303,6 +611,53 @@ func (p *Parser) walkNodeForDependencies(node *sitter.Node, content string, depe\n \t}\n }\n \n+// isSignificantCall determines if a function call is significant enough to include\n+func (p *Parser) isSignificantCall(name string) bool {\n+\t// Skip very short names (likely operators or basic operations)\n+\tif len(name) \u003c= 2 {\n+\t\treturn false\n+\t}\n+\n+\t// Skip common patterns that are not meaningful dependencies\n+\tskipPatterns := []string{\n+\t\t\"get\", \"set\", \"add\", \"remove\", \"find\", \"create\", \"update\", \"delete\",\n+\t\t\"toString\", \"equals\", \"hashCode\", \"clone\", \"copy\", \"clear\",\n+\t\t\"size\", \"length\", \"count\", \"empty\", \"isEmpty\", \"hasNext\",\n+\t\t\"next\", \"previous\", \"first\", \"last\", \"begin\", \"end\",\n+\t}\n+\n+\tfor _, pattern := range skipPatterns {\n+\t\tif strings.EqualFold(name, pattern) {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\n+\treturn true\n+}\n+\n+// isSignificantDeclaration determines if a declaration is significant enough to include\n+func (p *Parser) isSignificantDeclaration(name string) bool {\n+\t// Skip very short names\n+\tif len(name) \u003c= 2 {\n+\t\treturn false\n+\t}\n+\n+\t// Skip common variable names that are not meaningful\n+\tskipNames := []string{\n+\t\t\"i\", \"j\", \"k\", \"x\", \"y\", \"z\", \"a\", \"b\", \"c\", \"n\", \"m\",\n+\t\t\"temp\", \"tmp\", \"var\", \"val\", \"item\", \"obj\", \"data\",\n+\t\t\"result\", \"res\", \"ret\", \"value\", \"val\", \"item\", \"element\",\n+\t}\n+\n+\tfor _, skipName := range skipNames {\n+\t\tif strings.EqualFold(name, skipName) {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\n+\treturn true\n+}\n+\n // extractFunctionCall extracts a function call from a call expression node\n func (p *Parser) extractDependency(node *sitter.Node, content string) Dependency {\n \tcall := Dependency{\n@@ -311,21 +666,125 @@ func (p *Parser) extractDependency(node *sitter.Node, content string) Dependency\n \t\tType:    getSymbolType(node.Type()),\n \t}\n \n+\t// Try to extract the function name based on the node type\n+\tcall.Name = p.extractFunctionName(node, content)\n+\n+\treturn call\n+}\n+\n+// extractFunctionName extracts the function name from a call expression\n+func (p *Parser) extractFunctionName(node *sitter.Node, content string) string {\n+\tnodeType := node.Type()\n+\n+\t// Handle different types of call expressions\n+\tswitch {\n+\tcase strings.Contains(nodeType, \"call\"):\n+\t\treturn p.extractCallExpressionName(node, content)\n+\tcase strings.Contains(nodeType, \"declaration\"):\n+\t\treturn p.extractDeclarationName(node, content)\n+\tcase strings.Contains(nodeType, \"definition\"):\n+\t\treturn p.extractDefinitionName(node, content)\n+\tdefault:\n+\t\treturn p.findFirstIdentifier(node, content)\n+\t}\n+}\n+\n+// extractCallExpressionName extracts the function name from a call expression\n+func (p *Parser) extractCallExpressionName(node *sitter.Node, content string) string {\n \tchildCount := int(node.ChildCount())\n+\n+\t// Look for the function name in the call expression\n \tfor i := 0; i \u003c childCount; i++ {\n \t\tchild := node.Child(i)\n \t\tif child == nil {\n \t\t\tcontinue\n \t\t}\n \n \t\tchildType := child.Type()\n-\t\tif strings.Contains(childType, \"identifier\") || strings.Contains(childType, \"expression\") {\n-\t\t\tcall.Name = p.getNodeText(child, content)\n-\t\t\tbreak\n+\n+\t\t// Function name is usually in the first child or in a specific pattern\n+\t\tif strings.Contains(childType, \"identifier\") ||\n+\t\t\tstrings.Contains(childType, \"name\") ||\n+\t\t\tstrings.Contains(childType, \"function\") ||\n+\t\t\tstrings.Contains(childType, \"expression\") {\n+\t\t\tname := p.getNodeText(child, content)\n+\t\t\tif name != \"\" {\n+\t\t\t\treturn name\n+\t\t\t}\n+\t\t}\n+\n+\t\t// For method calls, look for the method name\n+\t\tif strings.Contains(childType, \"member\") || strings.Contains(childType, \"field\") {\n+\t\t\tname := p.extractMethodName(child, content)\n+\t\t\tif name != \"\" {\n+\t\t\t\treturn name\n+\t\t\t}\n \t\t}\n \t}\n \n-\treturn call\n+\treturn \"\"\n+}\n+\n+// extractMethodName extracts the method name from a member expression\n+func (p *Parser) extractMethodName(node *sitter.Node, content string) string {\n+\tchildCount := int(node.ChildCount())\n+\n+\tfor i := 0; i \u003c childCount; i++ {\n+\t\tchild := node.Child(i)\n+\t\tif child == nil {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tchildType := child.Type()\n+\t\tif strings.Contains(childType, \"identifier\") || strings.Contains(childType, \"name\") {\n+\t\t\treturn p.getNodeText(child, content)\n+\t\t}\n+\t}\n+\n+\treturn \"\"\n+}\n+\n+// extractDeclarationName extracts the name from a declaration\n+func (p *Parser) extractDeclarationName(node *sitter.Node, content string) string {\n+\tchildCount := int(node.ChildCount())\n+\n+\tfor i := 0; i \u003c childCount; i++ {\n+\t\tchild := node.Child(i)\n+\t\tif child == nil {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tchildType := child.Type()\n+\t\tif strings.Contains(childType, \"identifier\") ||\n+\t\t\tstrings.Contains(childType, \"name\") ||\n+\t\t\tstrings.Contains(childType, \"variable\") {\n+\t\t\treturn p.getNodeText(child, content)\n+\t\t}\n+\t}\n+\n+\treturn \"\"\n+}\n+\n+// extractDefinitionName extracts the name from a definition\n+func (p *Parser) extractDefinitionName(node *sitter.Node, content string) string {\n+\tchildCount := int(node.ChildCount())\n+\n+\tfor i := 0; i \u003c childCount; i++ {\n+\t\tchild := node.Child(i)\n+\t\tif child == nil {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tchildType := child.Type()\n+\t\tif strings.Contains(childType, \"identifier\") ||\n+\t\t\tstrings.Contains(childType, \"name\") ||\n+\t\t\tstrings.Contains(childType, \"function\") ||\n+\t\t\tstrings.Contains(childType, \"class\") {\n+\t\t\treturn p.getNodeText(child, content)\n+\t\t}\n+\t}\n+\n+\treturn \"\"\n }\n \n // getNodeText extracts the text content of a node\n@@ -342,8 +801,8 @@ func (p *Parser) getNodeText(node *sitter.Node, content string) string {\n }\n \n // findAllSymbolsInFile finds all symbols in a file\n-func (p *Parser) findAllSymbolsInFile(filePath, content string) ([]AffectedSymbol, error) {\n-\trootNode, err := p.ParseFileToAST(context.Background(), filePath, content)\n+func (p *Parser) FindAllSymbolsInFile(ctx context.Context, filePath, content string) ([]AffectedSymbol, error) {\n+\trootNode, err := p.GetFileAST(ctx, filePath, content)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -374,37 +833,57 @@ func (p *Parser) walkASTForSymbols(node *sitter.Node, filePath, content string,\n }\n \n func getSymbolType(nodeType string) SymbolType {\n+\t// First, check for exact matches\n+\tswitch nodeType {\n+\tcase \"function_declaration\", \"function_definition\", \"function_expression\", \"arrow_function\":\n+\t\treturn SymbolTypeFunction\n+\tcase \"method_declaration\", \"method_definition\":\n+\t\treturn SymbolTypeMethod\n+\tcase \"class_declaration\", \"class_definition\", \"class_specifier\":\n+\t\treturn SymbolTypeClass\n+\tcase \"interface_declaration\", \"interface_type\":\n+\t\treturn SymbolTypeInterface\n+\tcase \"struct_declaration\", \"struct_specifier\", \"struct_type\":\n+\t\treturn SymbolTypeStruct\n+\tcase \"enum_declaration\", \"enum_specifier\":\n+\t\treturn SymbolTypeEnum\n+\tcase \"variable_declaration\", \"var_declaration\", \"const_declaration\":\n+\t\treturn SymbolTypeVariable\n+\tcase \"import_statement\", \"import_declaration\":\n+\t\treturn SymbolTypeImport\n+\tcase \"package_declaration\":\n+\t\treturn SymbolTypePackage\n+\t}\n+\n+\t// Check for patterns\n \tswitch {\n \tcase strings.Contains(nodeType, \"function\"):\n \t\treturn SymbolTypeFunction\n-\n \tcase strings.Contains(nodeType, \"method\"):\n \t\treturn SymbolTypeMethod\n-\n \tcase strings.Contains(nodeType, \"class\"):\n \t\treturn SymbolTypeClass\n-\n \tcase strings.Contains(nodeType, \"interface\"):\n \t\treturn SymbolTypeInterface\n-\n-\tcase strings.Contains(nodeType, \"type_\"):\n-\t\treturn SymbolTypeType\n-\n \tcase strings.Contains(nodeType, \"struct\"):\n \t\treturn SymbolTypeStruct\n-\n \tcase strings.Contains(nodeType, \"enum\"):\n \t\treturn SymbolTypeEnum\n-\n-\tcase strings.Contains(nodeType, \"var\"):\n+\tcase strings.Contains(nodeType, \"var\") || strings.Contains(nodeType, \"variable\"):\n \t\treturn SymbolTypeVariable\n-\n \tcase strings.Contains(nodeType, \"const\"):\n \t\treturn SymbolTypeConstant\n-\n+\tcase strings.Contains(nodeType, \"type\"):\n+\t\treturn SymbolTypeType\n \tcase strings.Contains(nodeType, \"import\"):\n \t\treturn SymbolTypeImport\n-\n+\tcase strings.Contains(nodeType, \"package\"):\n+\t\treturn SymbolTypePackage\n+\tcase strings.Contains(nodeType, \"call\"):\n+\t\treturn SymbolTypeFunction // Function calls\n+\tcase strings.Contains(nodeType, \"declaration\"):\n+\t\t// Default to variable for generic declarations\n+\t\treturn SymbolTypeVariable\n \tdefault:\n \t\treturn SymbolType(nodeType)\n \t}",
        "IsNew": false,
        "IsDeleted": false,
        "IsRenamed": false,
        "IsBinary": false,
        "ContentType": ""
      },
      {
        "OldPath": "",
        "NewPath": "internal/reviewer/astparser/special_cases_helpers.go",
        "Diff": "@@ -55,7 +55,7 @@ func (sch *SpecialCasesHandler) findAllSymbolsInFile(filePath, content string) (\n \t\treturn []AffectedSymbol{}, nil\n \t}\n \n-\trootNode, err := sch.astParser.ParseFileToAST(context.Background(), filePath, content)\n+\trootNode, err := sch.astParser.GetFileAST(context.Background(), filePath, content)\n \tif err != nil {\n \t\treturn nil, err\n \t}",
        "IsNew": false,
        "IsDeleted": false,
        "IsRenamed": false,
        "IsBinary": false,
        "ContentType": ""
      },
      {
        "OldPath": "",
        "NewPath": "internal/reviewer/astparser/symbol_analyzer.go",
        "Diff": "@@ -100,7 +100,7 @@ func (sa *ExternalRefsAnalyzer) FindSymbolCallers(ctx context.Context, data *mod\n \tfor _, file := range getAffectedFiles(data, symbol) {\n \t\tfileCallers, err := sa.analyzeFileForCallers(ctx, file.Content, file.Path, symbol)\n \t\tif err != nil {\n-\t\t\tsa.log.Warn(\"failed to analyze file for callers\", \"error\", err, \"file\", file.Path)\n+\t\t\t//sa.log.Warn(\"failed to analyze file for callers\", \"error\", err, \"file\", file.Path)\n \t\t\tcontinue\n \t\t}\n \t\tcallers = append(callers, fileCallers...)\n@@ -125,8 +125,7 @@ func (sa *ExternalRefsAnalyzer) analyzeFileForCallers(ctx context.Context, conte\n \t\treturn nil, nil\n \t}\n \n-\t// TODO: cache\n-\trootNode, err := sa.astParser.ParseFileToAST(ctx, filePath, content)\n+\trootNode, err := sa.astParser.GetFileAST(ctx, filePath, content)\n \tif err != nil {\n \t\treturn nil, errm.Wrap(err, \"failed to parse file to AST\")\n \t}\n@@ -168,7 +167,7 @@ func (sa *ExternalRefsAnalyzer) walkASTForCallers(node *sitter.Node, content, fi\n \t\t\t}\n \n \t\t\t// Find the containing function\n-\t\t\tcontainingFunc := sa.findContainingFunctionNode(node, content)\n+\t\t\tcontainingFunc := sa.findContainingFunctionNode(node, content, filePath)\n \t\t\tif containingFunc != \"\" {\n \t\t\t\tcaller.FunctionName = containingFunc\n \t\t\t}\n@@ -197,12 +196,12 @@ func (sa *ExternalRefsAnalyzer) getCallSiteSnippet(node *sitter.Node, content st\n }\n \n // findContainingFunctionNode finds the name of the function containing a node\n-func (sa *ExternalRefsAnalyzer) findContainingFunctionNode(node *sitter.Node, content string) string {\n+func (sa *ExternalRefsAnalyzer) findContainingFunctionNode(node *sitter.Node, content, filePath string) string {\n \tcurrent := node.Parent()\n \n \tfor current != nil {\n \t\tif sa.astParser.IsSymbolNode(current.Type()) {\n-\t\t\treturn sa.astParser.extractSymbolName(current, content)\n+\t\t\treturn sa.astParser.extractSymbolName(current, content, filePath)\n \t\t}\n \t\tcurrent = current.Parent()\n \t}\n@@ -272,7 +271,7 @@ func (sa *ExternalRefsAnalyzer) findSymbolDefinitionInSnapshot(ctx context.Conte\n \n // findDefinitionInFileWithAST finds symbol definition using AST parsing\n func (sa *ExternalRefsAnalyzer) findDefinitionInFileWithAST(ctx context.Context, file *model.RepositoryFile, symbolName string) (SymbolDefinition, bool) {\n-\trootNode, err := sa.astParser.ParseFileToAST(ctx, file.Path, file.Content)\n+\trootNode, err := sa.astParser.GetFileAST(ctx, file.Path, file.Content)\n \tif err != nil {\n \t\treturn SymbolDefinition{}, false\n \t}\n@@ -289,7 +288,7 @@ func (sa *ExternalRefsAnalyzer) walkASTForDefinition(node *sitter.Node, content,\n \n \t// Check for function definitions, variable declarations, etc.\n \tif sa.astParser.IsSymbolNode(nodeType) {\n-\t\textractedName := sa.astParser.extractSymbolName(node, content)\n+\t\textractedName := sa.astParser.extractSymbolName(node, content, filePath)\n \t\tif extractedName == symbolName {\n \t\t\t*definition = SymbolDefinition{\n \t\t\t\tFilePath:      filePath,",
        "IsNew": false,
        "IsDeleted": false,
        "IsRenamed": false,
        "IsBinary": false,
        "ContentType": ""
      },
      {
        "OldPath": "",
        "NewPath": "internal/reviewer/astparser/types.go",
        "Diff": "@@ -0,0 +1,54 @@\n+package astparser\n+\n+import \"github.com/maxbolgarin/codry/internal/model\"\n+\n+// ChangeType represents the type of file change\n+type ChangeType string\n+\n+const (\n+\tChangeTypeModified ChangeType = \"Modified\"\n+\tChangeTypeAdded    ChangeType = \"Added\"\n+\tChangeTypeDeleted  ChangeType = \"Deleted\"\n+\tChangeTypeRenamed  ChangeType = \"Renamed\"\n+)\n+\n+// FileContext represents context for a single changed file\n+type FileContext struct {\n+\tFilePath        string           `json:\"file_path\"`\n+\tChangeType      ChangeType       `json:\"change_type\"`\n+\tDiff            string           `json:\"diff\"`\n+\tAffectedSymbols []AffectedSymbol `json:\"affected_symbols\"`\n+\tRelatedFiles    []RelatedFile    `json:\"related_files\"`\n+\tConfigContext   *ConfigContext   `json:\"config_context,omitempty\"`\n+}\n+\n+// RelatedFile represents a file related to the changed file\n+type RelatedFile struct {\n+\tFilePath         string `json:\"file_path\"`\n+\tRelationship     string `json:\"relationship\"` // \"caller\", \"dependency\", \"test\", \"same_package\"\n+\tCodeSnippet      string `json:\"code_snippet\"`\n+\tLine             int    `json:\"line,omitempty\"`\n+\tRelevantFunction string `json:\"relevant_function,omitempty\"`\n+}\n+\n+// ConfigContext represents context for configuration file changes\n+type ConfigContext struct {\n+\tConfigType       string        `json:\"config_type\"` // \"yaml\", \"json\", \"env\", etc.\n+\tChangedKeys      []string      `json:\"changed_keys\"`\n+\tConsumingCode    []RelatedFile `json:\"consuming_code\"`\n+\tImpactAssessment string        `json:\"impact_assessment\"`\n+}\n+\n+// determineChangeType determines the type of change for a file\n+func (cf *ContextManager) determineChangeType(fileDiff *model.FileDiff) ChangeType {\n+\tif fileDiff.IsNew {\n+\t\treturn ChangeTypeAdded\n+\t}\n+\tif fileDiff.IsDeleted {\n+\t\treturn ChangeTypeDeleted\n+\t}\n+\tif fileDiff.IsRenamed {\n+\t\treturn ChangeTypeRenamed\n+\t}\n+\treturn ChangeTypeModified\n+}",
        "IsNew": true,
        "IsDeleted": false,
        "IsRenamed": false,
        "IsBinary": false,
        "ContentType": ""
      },
      {
        "OldPath": "",
        "NewPath": "internal/reviewer/llmcontext/builder.go",
        "Diff": "@@ -7,7 +7,6 @@ import (\n \t\"strings\"\n \t\"time\"\n \n-\t\"github.com/maxbolgarin/codry/internal/model\"\n \t\"github.com/maxbolgarin/codry/internal/model/interfaces\"\n \t\"github.com/maxbolgarin/codry/internal/reviewer/astparser\"\n \n@@ -23,125 +22,93 @@ type Builder struct {\n \tdiffParser     *astparser.DiffParser\n \tastParser      *astparser.Parser\n \tlog            logze.Logger\n+\tisVerbose      bool\n \n-\tmrContextBuilder *mrContextBuilder\n+\trepoDataProvider *repoDataProvider\n }\n \n // NewBuilder creates a new context bundle builder\n-func NewBuilder(provider interfaces.CodeProvider) *Builder {\n+func NewBuilder(provider interfaces.CodeProvider, isVerbose bool) *Builder {\n \treturn \u0026Builder{\n \t\tprovider:         provider,\n \t\tcontextFinder:    astparser.NewContextFinder(provider),\n \t\tsymbolAnalyzer:   astparser.NewExternalRefsAnalyzer(provider),\n \t\tdiffParser:       astparser.NewDiffParser(),\n \t\tastParser:        astparser.NewParser(),\n \t\tlog:              logze.With(\"component\", \"context_bundle_builder\"),\n-\t\tmrContextBuilder: newMRContextBuilder(provider),\n+\t\tisVerbose:        isVerbose,\n+\t\trepoDataProvider: newRepoDataProvider(provider, isVerbose),\n \t}\n }\n \n // BuildContext builds a comprehensive context bundle for LLM analysis\n func (cbb *Builder) BuildContext(ctx context.Context, projectID string, mrIID int) (*ContextBundle, error) {\n-\tmr, err := cbb.provider.GetMergeRequest(ctx, projectID, mrIID)\n-\tif err != nil {\n-\t\treturn nil, errm.Wrap(err, \"failed to get merge request\")\n-\t}\n-\tdiffs, err := cbb.provider.GetMergeRequestDiffs(ctx, projectID, mrIID)\n-\tif err != nil {\n-\t\treturn nil, errm.Wrap(err, \"failed to get MR diffs\")\n-\t}\n-\tallComments, err := cbb.provider.GetComments(ctx, projectID, mrIID)\n-\tif err != nil {\n-\t\treturn nil, errm.Wrap(err, \"failed to get comments\")\n-\t}\n+\tcbb.log.DebugIf(cbb.isVerbose, \"loading repository data\")\n \n-\trequest := mrContextRequest{\n-\t\tProjectID:    projectID,\n-\t\tMergeRequest: mr,\n-\t\tDiffs:        diffs,\n-\t\tComments:     allComments,\n-\t}\n-\n-\tmrContext, err := cbb.mrContextBuilder.gatherMRContext(ctx, request)\n+\terr := cbb.repoDataProvider.loadData(ctx, projectID, mrIID)\n \tif err != nil {\n-\t\treturn nil, errm.Wrap(err, \"failed to get MR context\")\n+\t\treturn nil, errm.Wrap(err, \"failed to load repository data\")\n \t}\n \n-\trepoInfo, err := cbb.provider.GetRepositoryInfo(ctx, projectID)\n-\tif err != nil {\n-\t\treturn nil, errm.Wrap(err, \"failed to get repository info\")\n-\t}\n+\tcbb.log.DebugIf(cbb.isVerbose, \"loaded all data for context gathering\")\n \n-\trepoDataHead, err := cbb.provider.GetRepositorySnapshot(ctx, projectID, mr.SHA)\n+\tmrContext, err := gatherMRContext(projectID, cbb.repoDataProvider)\n \tif err != nil {\n-\t\treturn nil, errm.Wrap(err, \"failed to get repository data\")\n+\t\treturn nil, errm.Wrap(err, \"failed to get MR context\")\n \t}\n \n-\tvar repoDataBase *model.RepositorySnapshot\n-\tfor _, branch := range repoInfo.Branches {\n-\t\tif branch.Name == mr.TargetBranch {\n-\t\t\trepoDataBase, err = cbb.provider.GetRepositorySnapshot(ctx, projectID, branch.SHA)\n-\t\t\tif err != nil {\n-\t\t\t\treturn nil, errm.Wrap(err, \"failed to get repository data\")\n-\t\t\t}\n-\t\t}\n-\t}\n+\tcbb.log.DebugIf(cbb.isVerbose, \"gathered MR context\")\n \n \tcontextRequest := astparser.ContextRequest{\n \t\tProjectID:    projectID,\n-\t\tMergeRequest: mr,\n-\t\tFileDiffs:    diffs,\n-\t\tRepoDataHead: repoDataHead,\n-\t\tRepoDataBase: repoDataBase,\n+\t\tMergeRequest: cbb.repoDataProvider.mr,\n+\t\tFileDiffs:    cbb.repoDataProvider.diffs,\n+\t\tRepoDataHead: cbb.repoDataProvider.repoDataHead,\n+\t\tRepoDataBase: cbb.repoDataProvider.repoDataBase,\n \t}\n \n \t// Gather basic context using ContextFinder\n-\tbasicContext, err := cbb.contextFinder.GatherContext(ctx, contextRequest)\n+\tfilesContext, err := cbb.contextFinder.GatherFilesContext(ctx, contextRequest)\n \tif err != nil {\n \t\treturn nil, errm.Wrap(err, \"failed to gather basic context\")\n \t}\n \n+\tcbb.log.DebugIf(cbb.isVerbose, \"gathered basic context\")\n+\n \t// Enhance with detailed analysis\n-\tenhancedFiles, err := cbb.enhanceFileContexts(ctx, contextRequest, basicContext.Files)\n+\tenhancedFiles, err := cbb.enhanceFileContexts(ctx, contextRequest, filesContext)\n \tif err != nil {\n \t\tcbb.log.Warn(\"failed to enhance file contexts\", \"error\", err)\n \t\t// Continue with basic context\n-\t\tenhancedFiles = basicContext.Files\n+\t\tenhancedFiles = filesContext\n \t}\n \n-\t// Build overview\n-\toverview := cbb.buildOverview(enhancedFiles)\n-\n-\t// Build summary\n-\tsummary := cbb.buildSummary(enhancedFiles, overview)\n-\n-\t// Build metadata\n-\tmetadata := cbb.buildMetadata()\n+\tcbb.log.DebugIf(cbb.isVerbose, \"enhanced file contexts\")\n \n \tbundle := \u0026ContextBundle{\n-\t\tOverview:  overview,\n \t\tFiles:     enhancedFiles,\n-\t\tSummary:   summary,\n-\t\tMetadata:  metadata,\n \t\tMRContext: mrContext,\n \t}\n \n+\tcbb.log.DebugIf(cbb.isVerbose, \"built context bundle\")\n+\ttime.Sleep(time.Second)\n+\n \treturn bundle, nil\n }\n \n // enhanceFileContexts enhances file contexts with detailed symbol analysis\n-func (cbb *Builder) enhanceFileContexts(ctx context.Context, request astparser.ContextRequest, files []astparser.FileContext) ([]astparser.FileContext, error) {\n-\tvar enhancedFiles []astparser.FileContext\n+func (cbb *Builder) enhanceFileContexts(ctx context.Context, request astparser.ContextRequest, files []*astparser.FileContext) ([]*astparser.FileContext, error) {\n+\tvar enhancedFiles []*astparser.FileContext\n \n \tfor _, fileContext := range files {\n-\t\tenhanced, err := cbb.enhanceFileContext(ctx, request, fileContext)\n+\t\tenhanced, err := cbb.enhanceFileContext(ctx, request, *fileContext)\n \t\tif err != nil {\n \t\t\tcbb.log.Warn(\"failed to enhance file context\", \"error\", err, \"file\", fileContext.FilePath)\n \t\t\t// Continue with original context\n \t\t\tenhancedFiles = append(enhancedFiles, fileContext)\n \t\t\tcontinue\n \t\t}\n-\t\tenhancedFiles = append(enhancedFiles, *enhanced)\n+\t\tenhancedFiles = append(enhancedFiles, enhanced)\n \t}\n \n \treturn enhancedFiles, nil\n@@ -183,7 +150,7 @@ func (cbb *Builder) enhanceFileContext(ctx context.Context, request astparser.Co\n \t\tenhanced.RelatedFiles = append(enhanced.RelatedFiles, cbb.convertUsageToRelatedFiles(usageContext)...)\n \n \t\t// Update symbol with enhanced context information\n-\t\tenhanced.AffectedSymbols[i] = cbb.enhanceSymbolWithContext(symbol, usageContext)\n+\t\tenhanced.AffectedSymbols[i] = cbb.enhanceSymbolWithContext(symbol)\n \t}\n \n \treturn \u0026enhanced, nil\n@@ -287,7 +254,7 @@ func (cbb *Builder) convertUsageToRelatedFiles(usage astparser.SymbolUsageContex\n }\n \n // enhanceSymbolWithContext enhances a symbol with usage context information\n-func (cbb *Builder) enhanceSymbolWithContext(symbol astparser.AffectedSymbol, usage astparser.SymbolUsageContext) astparser.AffectedSymbol {\n+func (cbb *Builder) enhanceSymbolWithContext(symbol astparser.AffectedSymbol) astparser.AffectedSymbol {\n \tenhanced := symbol\n \n \t// Update context information\n@@ -299,479 +266,6 @@ func (cbb *Builder) enhanceSymbolWithContext(symbol astparser.AffectedSymbol, us\n \treturn enhanced\n }\n \n-// buildOverview builds the overview context\n-func (cbb *Builder) buildOverview(files []astparser.FileContext) OverviewContext {\n-\toverview := OverviewContext{\n-\t\tTotalFiles:        len(files),\n-\t\tTotalSymbols:      0,\n-\t\tImpactScore:       0.0,\n-\t\tChangeComplexity:  astparser.ComplexityLow,\n-\t\tHighImpactChanges: make([]string, 0),\n-\t\tConfigChanges:     make([]ConfigChangeInfo, 0),\n-\t\tDeletedSymbols:    make([]DeletedSymbolInfo, 0),\n-\t\tPotentialIssues:   make([]string, 0),\n-\t}\n-\n-\tvar totalImpactScore float64\n-\tvar maxComplexity astparser.ComplexityLevel\n-\n-\tfor _, file := range files {\n-\t\t// Count symbols\n-\t\toverview.TotalSymbols += len(file.AffectedSymbols)\n-\n-\t\t// Analyze impact and complexity\n-\t\tfileComplexity := cbb.assessFileComplexity(file)\n-\t\tfileImpact := cbb.calculateFileImpactScore(file)\n-\n-\t\ttotalImpactScore += fileImpact\n-\n-\t\t// Track maximum complexity\n-\t\tif cbb.compareComplexity(fileComplexity, maxComplexity) \u003e 0 {\n-\t\t\tmaxComplexity = fileComplexity\n-\t\t}\n-\n-\t\t// Identify high-impact changes\n-\t\tif fileImpact \u003e 10.0 { // Threshold for high impact\n-\t\t\tdescription := fmt.Sprintf(\"High-impact changes in %s (%d symbols affected)\", file.FilePath, len(file.AffectedSymbols))\n-\t\t\toverview.HighImpactChanges = append(overview.HighImpactChanges, description)\n-\t\t}\n-\n-\t\t// Collect configuration changes\n-\t\tif file.ConfigContext != nil {\n-\t\t\tconfigChange := ConfigChangeInfo{\n-\t\t\t\tFilePath:      file.FilePath,\n-\t\t\t\tConfigType:    file.ConfigContext.ConfigType,\n-\t\t\t\tChangedKeys:   file.ConfigContext.ChangedKeys,\n-\t\t\t\tImpact:        file.ConfigContext.ImpactAssessment,\n-\t\t\t\tAffectedFiles: cbb.extractFilePathsFromRelated(file.ConfigContext.ConsumingCode),\n-\t\t\t}\n-\t\t\toverview.ConfigChanges = append(overview.ConfigChanges, configChange)\n-\t\t}\n-\n-\t\t// Collect deleted symbols\n-\t\tif file.ChangeType == astparser.ChangeTypeDeleted {\n-\t\t\tfor _, symbol := range file.AffectedSymbols {\n-\t\t\t\tdeletedInfo := DeletedSymbolInfo{\n-\t\t\t\t\tSymbol:           symbol,\n-\t\t\t\t\tBrokenReferences: cbb.findBrokenReferences(file.RelatedFiles),\n-\t\t\t\t\tImpact:           cbb.assessDeletionImpact(symbol, file.RelatedFiles),\n-\t\t\t\t}\n-\t\t\t\toverview.DeletedSymbols = append(overview.DeletedSymbols, deletedInfo)\n-\t\t\t}\n-\t\t}\n-\n-\t\t// Collect potential issues\n-\t\toverview.PotentialIssues = append(overview.PotentialIssues, cbb.identifyFileIssues(file)...)\n-\t}\n-\n-\toverview.ImpactScore = totalImpactScore\n-\toverview.ChangeComplexity = maxComplexity\n-\n-\treturn overview\n-}\n-\n-// buildSummary builds the summary context\n-func (cbb *Builder) buildSummary(files []astparser.FileContext, overview OverviewContext) SummaryContext {\n-\tsummary := SummaryContext{\n-\t\tAffectedAreas:   make([]string, 0),\n-\t\tReviewFocus:     make([]string, 0),\n-\t\tRecommendations: make([]string, 0),\n-\t}\n-\n-\t// Generate changes summary\n-\tsummary.ChangesSummary = cbb.generateChangesSummary(files, overview)\n-\n-\t// Identify affected areas\n-\tsummary.AffectedAreas = cbb.identifyAffectedAreas(files)\n-\n-\t// Determine review focus areas\n-\tsummary.ReviewFocus = cbb.determineReviewFocus(files, overview)\n-\n-\t// Assess risk\n-\tsummary.RiskAssessment = cbb.assessRisk(overview)\n-\n-\t// Generate recommendations\n-\tsummary.Recommendations = cbb.generateRecommendations(files, overview)\n-\n-\treturn summary\n-}\n-\n-// buildMetadata builds the metadata context\n-func (cbb *Builder) buildMetadata() MetadataContext {\n-\treturn MetadataContext{\n-\t\tAnalysisTimestamp:  fmt.Sprintf(\"%d\", time.Now().Unix()),\n-\t\tAnalysisVersion:    \"1.0\",\n-\t\tSupportedLanguages: []string{\"go\", \"javascript\", \"typescript\", \"python\"},\n-\t\tLimitations: []string{\n-\t\t\t\"AST parsing may fail for syntactically incorrect code\",\n-\t\t\t\"Cross-repository dependencies are not analyzed\",\n-\t\t\t\"Dynamic function calls may not be detected\",\n-\t\t\t\"Generated code analysis may be incomplete\",\n-\t\t},\n-\t}\n-}\n-\n-// Helper methods for building overview and summary\n-\n-// assessFileComplexity assesses the complexity of changes in a file\n-func (cbb *Builder) assessFileComplexity(file astparser.FileContext) astparser.ComplexityLevel {\n-\tsymbolCount := len(file.AffectedSymbols)\n-\trelatedCount := len(file.RelatedFiles)\n-\n-\tif symbolCount \u003e 10 || relatedCount \u003e 20 {\n-\t\treturn astparser.ComplexityCritical\n-\t} else if symbolCount \u003e 5 || relatedCount \u003e 10 {\n-\t\treturn astparser.ComplexityHigh\n-\t} else if symbolCount \u003e 2 || relatedCount \u003e 5 {\n-\t\treturn astparser.ComplexityMedium\n-\t} else {\n-\t\treturn astparser.ComplexityLow\n-\t}\n-}\n-\n-// calculateFileImpactScore calculates an impact score for a file\n-func (cbb *Builder) calculateFileImpactScore(file astparser.FileContext) float64 {\n-\tscore := 0.0\n-\n-\t// Base score from symbol count\n-\tscore += float64(len(file.AffectedSymbols)) * 2.0\n-\n-\t// Additional score based on symbol types\n-\tfor _, symbol := range file.AffectedSymbols {\n-\t\tswitch symbol.Type {\n-\t\tcase astparser.SymbolTypeInterface:\n-\t\t\tscore += 5.0\n-\t\tcase astparser.SymbolTypeClass, astparser.SymbolTypeStruct:\n-\t\t\tscore += 3.0\n-\t\tcase astparser.SymbolTypeFunction, astparser.SymbolTypeMethod:\n-\t\t\tscore += 2.0\n-\t\tdefault:\n-\t\t\tscore += 1.0\n-\t\t}\n-\n-\t\t// Score for dependencies\n-\t\tscore += float64(len(symbol.Dependencies)) * 0.5\n-\t}\n-\n-\t// Score for related files (callers/dependencies)\n-\tscore += float64(len(file.RelatedFiles)) * 0.5\n-\n-\t// Higher score for config files\n-\tif file.ConfigContext != nil {\n-\t\tscore += 5.0\n-\t\tscore += float64(len(file.ConfigContext.ChangedKeys)) * 1.0\n-\t}\n-\n-\treturn score\n-}\n-\n-// compareComplexity compares two complexity levels\n-func (cbb *Builder) compareComplexity(a, b astparser.ComplexityLevel) int {\n-\tlevels := map[astparser.ComplexityLevel]int{\n-\t\tastparser.ComplexityLow:      1,\n-\t\tastparser.ComplexityMedium:   2,\n-\t\tastparser.ComplexityHigh:     3,\n-\t\tastparser.ComplexityCritical: 4,\n-\t}\n-\n-\treturn levels[a] - levels[b]\n-}\n-\n-// extractFilePathsFromRelated extracts file paths from related files\n-func (cbb *Builder) extractFilePathsFromRelated(relatedFiles []astparser.RelatedFile) []string {\n-\tvar paths []string\n-\tfor _, rf := range relatedFiles {\n-\t\tpaths = append(paths, rf.FilePath)\n-\t}\n-\treturn paths\n-}\n-\n-// findBrokenReferences finds broken references from related files\n-func (cbb *Builder) findBrokenReferences(relatedFiles []astparser.RelatedFile) []astparser.RelatedFile {\n-\tvar broken []astparser.RelatedFile\n-\tfor _, rf := range relatedFiles {\n-\t\tif rf.Relationship == \"broken_caller\" || rf.Relationship == \"caller\" {\n-\t\t\tbroken = append(broken, rf)\n-\t\t}\n-\t}\n-\treturn broken\n-}\n-\n-// assessDeletionImpact assesses the impact of deleting a symbol\n-func (cbb *Builder) assessDeletionImpact(symbol astparser.AffectedSymbol, relatedFiles []astparser.RelatedFile) string {\n-\tbrokenCount := len(cbb.findBrokenReferences(relatedFiles))\n-\n-\tif brokenCount == 0 {\n-\t\treturn \"Low impact - no broken references found\"\n-\t} else if brokenCount \u003c= 3 {\n-\t\treturn fmt.Sprintf(\"Medium impact - %d references may be broken\", brokenCount)\n-\t} else {\n-\t\treturn fmt.Sprintf(\"High impact - %d references may be broken\", brokenCount)\n-\t}\n-}\n-\n-// identifyFileIssues identifies potential issues in a file\n-func (cbb *Builder) identifyFileIssues(file astparser.FileContext) []string {\n-\tvar issues []string\n-\n-\t// Large number of symbols affected\n-\tif len(file.AffectedSymbols) \u003e 10 {\n-\t\tissues = append(issues, fmt.Sprintf(\"Large change in %s - %d symbols affected\", file.FilePath, len(file.AffectedSymbols)))\n-\t}\n-\n-\t// Interface changes\n-\tfor _, symbol := range file.AffectedSymbols {\n-\t\tif symbol.Type == astparser.SymbolTypeInterface {\n-\t\t\tissues = append(issues, fmt.Sprintf(\"Interface %s.%s modified - potential breaking change\", file.FilePath, symbol.Name))\n-\t\t}\n-\t}\n-\n-\t// High coupling\n-\tif len(file.RelatedFiles) \u003e 15 {\n-\t\tissues = append(issues, fmt.Sprintf(\"High coupling in %s - %d related files\", file.FilePath, len(file.RelatedFiles)))\n-\t}\n-\n-\treturn issues\n-}\n-\n-// generateChangesSummary generates a summary of changes\n-func (cbb *Builder) generateChangesSummary(files []astparser.FileContext, overview OverviewContext) string {\n-\tvar parts []string\n-\n-\tparts = append(parts, fmt.Sprintf(\"%d files modified with %d symbols affected\", overview.TotalFiles, overview.TotalSymbols))\n-\n-\t// Add complexity information\n-\tparts = append(parts, fmt.Sprintf(\"Change complexity: %s\", overview.ChangeComplexity))\n-\n-\t// Add specific change type information\n-\taddedCount, modifiedCount, deletedCount := cbb.countChangeTypes(files)\n-\tif addedCount \u003e 0 {\n-\t\tparts = append(parts, fmt.Sprintf(\"%d files added\", addedCount))\n-\t}\n-\tif modifiedCount \u003e 0 {\n-\t\tparts = append(parts, fmt.Sprintf(\"%d files modified\", modifiedCount))\n-\t}\n-\tif deletedCount \u003e 0 {\n-\t\tparts = append(parts, fmt.Sprintf(\"%d files deleted\", deletedCount))\n-\t}\n-\n-\t// Add configuration changes\n-\tif len(overview.ConfigChanges) \u003e 0 {\n-\t\tparts = append(parts, fmt.Sprintf(\"%d configuration files changed\", len(overview.ConfigChanges)))\n-\t}\n-\n-\treturn strings.Join(parts, \". \")\n-}\n-\n-// identifyAffectedAreas identifies affected areas/modules\n-func (cbb *Builder) identifyAffectedAreas(files []astparser.FileContext) []string {\n-\tareaMap := make(map[string]int)\n-\n-\tfor _, file := range files {\n-\t\t// Extract area from file path (directory structure)\n-\t\tdir := filepath.Dir(file.FilePath)\n-\t\tif dir != \".\" {\n-\t\t\t// Use the top-level directory as the area\n-\t\t\tparts := strings.Split(dir, \"/\")\n-\t\t\tif len(parts) \u003e 0 {\n-\t\t\t\tarea := parts[0]\n-\t\t\t\tareaMap[area]++\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tvar areas []string\n-\tfor area, count := range areaMap {\n-\t\tareas = append(areas, fmt.Sprintf(\"%s (%d files)\", area, count))\n-\t}\n-\n-\treturn areas\n-}\n-\n-// determineReviewFocus determines what the review should focus on\n-func (cbb *Builder) determineReviewFocus(files []astparser.FileContext, overview OverviewContext) []string {\n-\tvar focus []string\n-\n-\t// High-impact changes\n-\tif len(overview.HighImpactChanges) \u003e 0 {\n-\t\tfocus = append(focus, \"High-impact changes requiring careful review\")\n-\t}\n-\n-\t// Interface changes\n-\tinterfaceChanges := 0\n-\tfor _, file := range files {\n-\t\tfor _, symbol := range file.AffectedSymbols {\n-\t\t\tif symbol.Type == astparser.SymbolTypeInterface {\n-\t\t\t\tinterfaceChanges++\n-\t\t\t}\n-\t\t}\n-\t}\n-\tif interfaceChanges \u003e 0 {\n-\t\tfocus = append(focus, fmt.Sprintf(\"Interface changes (%d) - check for breaking changes\", interfaceChanges))\n-\t}\n-\n-\t// Configuration changes\n-\tif len(overview.ConfigChanges) \u003e 0 {\n-\t\tfocus = append(focus, \"Configuration changes - verify impact on dependent systems\")\n-\t}\n-\n-\t// Deleted symbols\n-\tif len(overview.DeletedSymbols) \u003e 0 {\n-\t\tfocus = append(focus, \"Deleted symbols - check for broken references\")\n-\t}\n-\n-\t// Complex changes\n-\tif overview.ChangeComplexity == astparser.ComplexityHigh || overview.ChangeComplexity == astparser.ComplexityCritical {\n-\t\tfocus = append(focus, \"Complex changes requiring thorough testing\")\n-\t}\n-\n-\treturn focus\n-}\n-\n-// assessRisk assesses the overall risk of the changes\n-func (cbb *Builder) assessRisk(overview OverviewContext) RiskAssessment {\n-\tassessment := RiskAssessment{\n-\t\tLevel:       RiskLevelLow,\n-\t\tScore:       overview.ImpactScore,\n-\t\tFactors:     make([]string, 0),\n-\t\tMitigations: make([]string, 0),\n-\t}\n-\n-\t// Assess risk level based on various factors\n-\triskFactors := 0\n-\n-\tif overview.ChangeComplexity == astparser.ComplexityCritical {\n-\t\triskFactors += 3\n-\t\tassessment.Factors = append(assessment.Factors, \"Critical complexity changes\")\n-\t} else if overview.ChangeComplexity == astparser.ComplexityHigh {\n-\t\triskFactors += 2\n-\t\tassessment.Factors = append(assessment.Factors, \"High complexity changes\")\n-\t}\n-\n-\tif len(overview.DeletedSymbols) \u003e 0 {\n-\t\triskFactors += 2\n-\t\tassessment.Factors = append(assessment.Factors, fmt.Sprintf(\"%d symbols deleted\", len(overview.DeletedSymbols)))\n-\t}\n-\n-\tif len(overview.ConfigChanges) \u003e 0 {\n-\t\triskFactors += 1\n-\t\tassessment.Factors = append(assessment.Factors, \"Configuration changes\")\n-\t}\n-\n-\tif overview.ImpactScore \u003e 50 {\n-\t\triskFactors += 2\n-\t\tassessment.Factors = append(assessment.Factors, \"High impact score\")\n-\t}\n-\n-\t// Determine risk level\n-\tif riskFactors \u003e= 5 {\n-\t\tassessment.Level = RiskLevelCritical\n-\t} else if riskFactors \u003e= 3 {\n-\t\tassessment.Level = RiskLevelHigh\n-\t} else if riskFactors \u003e= 1 {\n-\t\tassessment.Level = RiskLevelMedium\n-\t}\n-\n-\t// Generate mitigations\n-\tassessment.Mitigations = cbb.generateMitigations(assessment.Level, assessment.Factors)\n-\n-\treturn assessment\n-}\n-\n-// generateRecommendations generates recommendations for the review\n-func (cbb *Builder) generateRecommendations(files []astparser.FileContext, overview OverviewContext) []string {\n-\tvar recommendations []string\n-\n-\t// Based on complexity\n-\tif overview.ChangeComplexity == astparser.ComplexityCritical {\n-\t\trecommendations = append(recommendations, \"Consider breaking this large change into smaller, more focused changes\")\n-\t}\n-\n-\t// Based on deleted symbols\n-\tif len(overview.DeletedSymbols) \u003e 0 {\n-\t\trecommendations = append(recommendations, \"Verify that all references to deleted symbols have been properly updated\")\n-\t}\n-\n-\t// Based on configuration changes\n-\tif len(overview.ConfigChanges) \u003e 0 {\n-\t\trecommendations = append(recommendations, \"Update documentation to reflect configuration changes\")\n-\t\trecommendations = append(recommendations, \"Consider backwards compatibility for configuration changes\")\n-\t}\n-\n-\t// Based on interface changes\n-\tinterfaceCount := 0\n-\tfor _, file := range files {\n-\t\tfor _, symbol := range file.AffectedSymbols {\n-\t\t\tif symbol.Type == astparser.SymbolTypeInterface {\n-\t\t\t\tinterfaceCount++\n-\t\t\t}\n-\t\t}\n-\t}\n-\tif interfaceCount \u003e 0 {\n-\t\trecommendations = append(recommendations, \"Review interface changes for backwards compatibility\")\n-\t\trecommendations = append(recommendations, \"Update API documentation if public interfaces changed\")\n-\t}\n-\n-\t// General recommendations\n-\tif overview.TotalSymbols \u003e 20 {\n-\t\trecommendations = append(recommendations, \"Ensure comprehensive test coverage for the large number of changes\")\n-\t}\n-\n-\treturn recommendations\n-}\n-\n-// generateMitigations generates risk mitigations\n-func (cbb *Builder) generateMitigations(level RiskLevel, factors []string) []string {\n-\tvar mitigations []string\n-\n-\tswitch level {\n-\tcase RiskLevelCritical:\n-\t\tmitigations = append(mitigations, \"Require multiple reviewers\")\n-\t\tmitigations = append(mitigations, \"Perform comprehensive testing\")\n-\t\tmitigations = append(mitigations, \"Consider staged deployment\")\n-\t\tmitigations = append(mitigations, \"Prepare rollback plan\")\n-\n-\tcase RiskLevelHigh:\n-\t\tmitigations = append(mitigations, \"Require thorough review\")\n-\t\tmitigations = append(mitigations, \"Ensure test coverage\")\n-\t\tmitigations = append(mitigations, \"Test in staging environment\")\n-\n-\tcase RiskLevelMedium:\n-\t\tmitigations = append(mitigations, \"Standard review process\")\n-\t\tmitigations = append(mitigations, \"Verify test coverage\")\n-\n-\tcase RiskLevelLow:\n-\t\tmitigations = append(mitigations, \"Standard review\")\n-\t}\n-\n-\t// Factor-specific mitigations\n-\tfor _, factor := range factors {\n-\t\tif strings.Contains(factor, \"deleted\") {\n-\t\t\tmitigations = append(mitigations, \"Run static analysis to find orphaned references\")\n-\t\t}\n-\t\tif strings.Contains(factor, \"Configuration\") {\n-\t\t\tmitigations = append(mitigations, \"Test configuration changes in isolated environment\")\n-\t\t}\n-\t}\n-\n-\treturn mitigations\n-}\n-\n-// countChangeTypes counts different types of changes\n-func (cbb *Builder) countChangeTypes(files []astparser.FileContext) (added, modified, deleted int) {\n-\tfor _, file := range files {\n-\t\tswitch file.ChangeType {\n-\t\tcase astparser.ChangeTypeAdded:\n-\t\t\tadded++\n-\t\tcase astparser.ChangeTypeModified, astparser.ChangeTypeRenamed:\n-\t\t\tmodified++\n-\t\tcase astparser.ChangeTypeDeleted:\n-\t\t\tdeleted++\n-\t\t}\n-\t}\n-\treturn\n-}\n-\n // extractPackageFromPath extracts package name from file path\n func (cbb *Builder) extractPackageFromPath(filePath string) string {\n \tdir := filepath.Dir(filePath)",
        "IsNew": false,
        "IsDeleted": false,
        "IsRenamed": false,
        "IsBinary": false,
        "ContentType": ""
      },
      {
        "OldPath": "",
        "NewPath": "internal/reviewer/llmcontext/context.go",
        "Diff": "@@ -1,77 +1,261 @@\n package llmcontext\n \n import (\n+\t\"fmt\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\t\"github.com/maxbolgarin/codry/internal/model\"\n \t\"github.com/maxbolgarin/codry/internal/reviewer/astparser\"\n )\n \n // ContextBundle represents the final structured context for LLM\n type ContextBundle struct {\n-\tOverview  OverviewContext         `json:\"overview\"`\n-\tFiles     []astparser.FileContext `json:\"files\"`\n-\tSummary   SummaryContext          `json:\"summary\"`\n-\tMetadata  MetadataContext         `json:\"metadata\"`\n-\tMRContext *MRContext              `json:\"mr_context\"`\n+\tFiles     []*astparser.FileContext `json:\"files\"`\n+\tMRContext *MRContext               `json:\"mr_context\"`\n }\n \n-// OverviewContext provides high-level overview of the changes\n-type OverviewContext struct {\n-\tTotalFiles        int                       `json:\"total_files\"`\n-\tTotalSymbols      int                       `json:\"total_symbols\"`\n-\tImpactScore       float64                   `json:\"impact_score\"`\n-\tChangeComplexity  astparser.ComplexityLevel `json:\"change_complexity\"`\n-\tHighImpactChanges []string                  `json:\"high_impact_changes\"`\n-\tConfigChanges     []ConfigChangeInfo        `json:\"config_changes\"`\n-\tDeletedSymbols    []DeletedSymbolInfo       `json:\"deleted_symbols\"`\n-\tPotentialIssues   []string                  `json:\"potential_issues\"`\n+// MRContext holds comprehensive metadata about a merge request\n+type MRContext struct {\n+\t// Basic MR information\n+\tTitle       string    `json:\"title\"`\n+\tDescription string    `json:\"description\"`\n+\tBranchName  string    `json:\"branch_name\"`\n+\tCreatedAt   time.Time `json:\"created_at\"`\n+\tUpdatedAt   time.Time `json:\"updated_at\"`\n+\n+\t// Author information\n+\tAuthor         model.User       `json:\"author\"`\n+\tAuthorComments []*model.Comment `json:\"author_comments\"`\n+\n+\t// Commit information\n+\tCommits []CommitInfo `json:\"commits\"`\n+\n+\t// Issue/ticket links\n+\tLinkedIssues  []LinkedIssue  `json:\"linked_issues\"`\n+\tLinkedTickets []LinkedTicket `json:\"linked_tickets\"`\n+\n+\t// File changes\n+\tFileDiffs []*model.FileDiff       `json:\"file_diffs\"`\n+\tFilesStat map[string]FileDiffInfo `json:\"files_stat\"`\n+\n+\t// Context metadata\n+\tTotalCommits   int `json:\"total_commits\"`\n+\tTotalFiles     int `json:\"total_files\"`\n+\tTotalAdditions int `json:\"total_additions\"`\n+\tTotalDeletions int `json:\"total_deletions\"`\n }\n \n-// SummaryContext provides summary information for the LLM\n-type SummaryContext struct {\n-\tChangesSummary  string         `json:\"changes_summary\"`\n-\tAffectedAreas   []string       `json:\"affected_areas\"`\n-\tReviewFocus     []string       `json:\"review_focus\"`\n-\tRiskAssessment  RiskAssessment `json:\"risk_assessment\"`\n-\tRecommendations []string       `json:\"recommendations\"`\n+type FileDiffInfo struct {\n+\tTotalAdditions int `json:\"total_additions\"`\n+\tTotalDeletions int `json:\"total_deletions\"`\n }\n \n-// MetadataContext provides metadata about the analysis\n-type MetadataContext struct {\n-\tAnalysisTimestamp  string   `json:\"analysis_timestamp\"`\n-\tAnalysisVersion    string   `json:\"analysis_version\"`\n-\tSupportedLanguages []string `json:\"supported_languages\"`\n-\tLimitations        []string `json:\"limitations\"`\n+// CommitInfo contains detailed commit information\n+type CommitInfo struct {\n+\tSHA         string                      `json:\"sha\"`\n+\tSubject     string                      `json:\"subject\"`\n+\tBody        string                      `json:\"body\"`\n+\tAuthor      string                      `json:\"author\"`\n+\tTimestamp   time.Time                   `json:\"timestamp\"`\n+\tFileChanges map[string]CommitFileChange `json:\"file_changes\"`\n+\tTotalFiles  int                         `json:\"total_files\"`\n }\n \n-// ConfigChangeInfo represents information about configuration changes\n-type ConfigChangeInfo struct {\n-\tFilePath      string   `json:\"file_path\"`\n-\tConfigType    string   `json:\"config_type\"`\n-\tChangedKeys   []string `json:\"changed_keys\"`\n-\tImpact        string   `json:\"impact\"`\n-\tAffectedFiles []string `json:\"affected_files\"`\n+// CommitFileChange represents file changes in a specific commit\n+type CommitFileChange struct {\n+\tStatus    string `json:\"status\"`    // added, modified, deleted, renamed\n+\tAdditions int    `json:\"additions\"` // lines added in this file\n+\tDeletions int    `json:\"deletions\"` // lines deleted in this file\n+\tOldPath   string `json:\"old_path\"`  // for renamed files\n+\tNewPath   string `json:\"new_path\"`  // current file path\n+\tIsBinary  bool   `json:\"is_binary\"` // whether file is binary\n }\n \n-// DeletedSymbolInfo represents information about deleted symbols\n-type DeletedSymbolInfo struct {\n-\tSymbol           astparser.AffectedSymbol `json:\"symbol\"`\n-\tBrokenReferences []astparser.RelatedFile  `json:\"broken_references\"`\n-\tImpact           string                   `json:\"impact\"`\n+// LinkedIssue represents a linked GitHub/GitLab issue\n+type LinkedIssue struct {\n+\tID          string   `json:\"id\"`\n+\tNumber      int      `json:\"number\"`\n+\tTitle       string   `json:\"title\"`\n+\tDescription string   `json:\"description\"`\n+\tState       string   `json:\"state\"`\n+\tURL         string   `json:\"url\"`\n+\tLabels      []string `json:\"labels\"`\n }\n \n-// RiskAssessment provides risk assessment for the changes\n-type RiskAssessment struct {\n-\tLevel       RiskLevel `json:\"level\"`\n-\tScore       float64   `json:\"score\"`\n-\tFactors     []string  `json:\"factors\"`\n-\tMitigations []string  `json:\"mitigations\"`\n+// LinkedTicket represents a linked Jira/external ticket\n+type LinkedTicket struct {\n+\tID          string `json:\"id\"`\n+\tKey         string `json:\"key\"`\n+\tTitle       string `json:\"title\"`\n+\tDescription string `json:\"description\"`\n+\tStatus      string `json:\"status\"`\n+\tURL         string `json:\"url\"`\n+\tType        string `json:\"type\"`\n }\n \n-// RiskLevel represents the risk level of changes\n-type RiskLevel string\n+// BuildContextSummary creates a structured summary of the MR context for use in prompts\n+func (mrContext *MRContext) BuildContextSummary() string {\n+\tvar summary strings.Builder\n+\tsummary.Grow(2000) // Pre-allocate reasonable capacity\n \n-const (\n-\tRiskLevelLow      RiskLevel = \"low\"\n-\tRiskLevelMedium   RiskLevel = \"medium\"\n-\tRiskLevelHigh     RiskLevel = \"high\"\n-\tRiskLevelCritical RiskLevel = \"critical\"\n-)\n+\tsummary.WriteString(\"# MERGE REQUEST CONTEXT\\n\\n\")\n+\n+\t// Basic MR information\n+\tsummary.WriteString(\"## Basic Information\\n\")\n+\tsummary.WriteString(\"- Title: \")\n+\tsummary.WriteString(mrContext.Title)\n+\tsummary.WriteString(\"\\n- Branch: `\")\n+\tsummary.WriteString(mrContext.BranchName)\n+\tsummary.WriteString(\"`\\n- Author: \")\n+\tsummary.WriteString(mrContext.Author.Name)\n+\tsummary.WriteString(\" (@\")\n+\tsummary.WriteString(mrContext.Author.Username)\n+\tsummary.WriteString(\")\\n\")\n+\n+\t// Original description (filtered from AI content)\n+\tif mrContext.Description != \"\" {\n+\t\tsummary.WriteString(\"- Original Description:\\n```\\n\")\n+\t\tsummary.WriteString(mrContext.Description)\n+\t\tsummary.WriteString(\"\\n```\\n\")\n+\t}\n+\n+\t// Statistics\n+\tsummary.WriteString(\"\\n## Change Statistics\\n\")\n+\tsummary.WriteString(\"Total Changes: +\")\n+\tsummary.WriteString(intToString(mrContext.TotalAdditions))\n+\tsummary.WriteString(\" additions, -\")\n+\tsummary.WriteString(intToString(mrContext.TotalDeletions))\n+\tsummary.WriteString(\" deletions across \")\n+\tsummary.WriteString(intToString(mrContext.TotalFiles))\n+\tsummary.WriteString(\" files\\n\")\n+\n+\t// Show top changed files\n+\tmostChanged := mrContext.getMostChangedFiles(5)\n+\tif len(mostChanged) \u003e 0 {\n+\t\tsummary.WriteString(\"Most Changed Files:\\n\")\n+\t\tfor _, file := range mostChanged {\n+\t\t\tsummary.WriteString(\"  - \")\n+\t\t\tsummary.WriteString(file.FilePath)\n+\t\t\tsummary.WriteString(\": +\")\n+\t\t\tsummary.WriteString(intToString(file.Additions))\n+\t\t\tsummary.WriteString(\", -\")\n+\t\t\tsummary.WriteString(intToString(file.Deletions))\n+\t\t\tsummary.WriteString(\" (\")\n+\t\t\tsummary.WriteString(intToString(file.TotalChanges))\n+\t\t\tsummary.WriteString(\" total)\\n\")\n+\t\t}\n+\t}\n+\tsummary.WriteString(\"\\n## Commits: \")\n+\tsummary.WriteString(intToString(mrContext.TotalCommits))\n+\tsummary.WriteString(\" commits\\n\")\n+\tfor i, commit := range mrContext.Commits {\n+\t\t// Commit header with short SHA\n+\t\tsummary.WriteString(fmt.Sprintf(\"%d. \", i+1))\n+\t\tsummary.WriteString(commit.Subject)\n+\t\tsummary.WriteString(\" (@\") // Author\n+\t\tsummary.WriteString(commit.Author)\n+\t\tsummary.WriteString(\")\\nTime: \")\n+\t\tsummary.WriteString(commit.Timestamp.Format(time.RFC3339))\n+\t\tsummary.WriteString(\"\\nFiles: \")\n+\t\tsummary.WriteString(intToString(commit.TotalFiles))\n+\t\tsummary.WriteString(\"\\n\")\n+\n+\t\t// File changes in this commit\n+\t\tif len(commit.FileChanges) \u003e 0 {\n+\t\t\tfor _, change := range sortByTotalChanges(commit.FileChanges) {\n+\t\t\t\tfilePath := change.NewPath\n+\t\t\t\tif filePath == \"\" {\n+\t\t\t\t\tfilePath = change.OldPath\n+\t\t\t\t}\n+\n+\t\t\t\tsummary.WriteString(\"  - \")\n+\t\t\t\tsummary.WriteString(filePath)\n+\t\t\t\tsummary.WriteString(\": [\")\n+\t\t\t\tsummary.WriteString(change.Status)\n+\t\t\t\tsummary.WriteString(\"]: +\")\n+\t\t\t\tsummary.WriteString(intToString(change.Additions))\n+\t\t\t\tsummary.WriteString(\", -\")\n+\t\t\t\tsummary.WriteString(intToString(change.Deletions))\n+\n+\t\t\t\t// Show rename information\n+\t\t\t\tif change.Status == \"renamed\" \u0026\u0026 change.OldPath != \"\" \u0026\u0026 change.OldPath != change.NewPath {\n+\t\t\t\t\tsummary.WriteString(\" (from \")\n+\t\t\t\t\tsummary.WriteString(change.OldPath)\n+\t\t\t\t\tsummary.WriteString(\")\")\n+\t\t\t\t}\n+\n+\t\t\t\t// Binary file indicator\n+\t\t\t\tif change.IsBinary {\n+\t\t\t\t\tsummary.WriteString(\" [binary]\")\n+\t\t\t\t}\n+\n+\t\t\t\tsummary.WriteString(\"\\n\")\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Commit body if available and not too long\n+\t\tif commit.Body != \"\" \u0026\u0026 len(commit.Body) \u003c= 200 {\n+\t\t\tsummary.WriteString(\"  Description: \")\n+\t\t\tsummary.WriteString(commit.Body)\n+\t\t\tsummary.WriteString(\"\\n\")\n+\t\t} else if commit.Body != \"\" {\n+\t\t\tsummary.WriteString(\"  Description: \")\n+\t\t\tsummary.WriteString(commit.Body[:197])\n+\t\t\tsummary.WriteString(\"...\\n\")\n+\t\t}\n+\n+\t\tsummary.WriteString(\"\\n\")\n+\t}\n+\n+\t// Linked issues and tickets\n+\tif len(mrContext.LinkedIssues) \u003e 0 || len(mrContext.LinkedTickets) \u003e 0 {\n+\t\tsummary.WriteString(\"\\n## Linked References\\n\")\n+\n+\t\tif len(mrContext.LinkedIssues) \u003e 0 {\n+\t\t\tsummary.WriteString(\"- Issues: \")\n+\t\t\tfor i, issue := range mrContext.LinkedIssues {\n+\t\t\t\tif i \u003e 0 {\n+\t\t\t\t\tsummary.WriteString(\", \")\n+\t\t\t\t}\n+\t\t\t\tsummary.WriteString(\"#\")\n+\t\t\t\tsummary.WriteString(intToString(issue.Number))\n+\t\t\t}\n+\t\t\tsummary.WriteString(\"\\n\")\n+\t\t}\n+\n+\t\tif len(mrContext.LinkedTickets) \u003e 0 {\n+\t\t\tsummary.WriteString(\"- Tickets: \")\n+\t\t\tfor i, ticket := range mrContext.LinkedTickets {\n+\t\t\t\tif i \u003e 0 {\n+\t\t\t\t\tsummary.WriteString(\", \")\n+\t\t\t\t}\n+\t\t\t\tsummary.WriteString(ticket.Key)\n+\t\t\t}\n+\t\t\tsummary.WriteString(\"\\n\")\n+\t\t}\n+\t}\n+\n+\t// Author comments (provide context about author's intentions)\n+\tif len(mrContext.AuthorComments) \u003e 0 {\n+\t\tsummary.WriteString(\"\\n## Author Comments \u0026 Context\\n\")\n+\t\tfor i, comment := range mrContext.AuthorComments {\n+\t\t\tif i \u003e= 3 {\n+\t\t\t\tsummary.WriteString(\"- ... and \")\n+\t\t\t\tsummary.WriteString(intToString(len(mrContext.AuthorComments) - 3))\n+\t\t\t\tsummary.WriteString(\" more comments\\n\")\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tsummary.WriteString(\"- \")\n+\t\t\t// Truncate long comments\n+\t\t\tcommentBody := comment.Body\n+\t\t\tif len(commentBody) \u003e 150 {\n+\t\t\t\tcommentBody = commentBody[:150] + \"...\"\n+\t\t\t}\n+\t\t\tsummary.WriteString(commentBody)\n+\t\t\tsummary.WriteString(\"\\n\")\n+\t\t}\n+\t}\n+\n+\treturn summary.String()\n+}",
        "IsNew": false,
        "IsDeleted": false,
        "IsRenamed": false,
        "IsBinary": false,
        "ContentType": ""
      },
      {
        "OldPath": "",
        "NewPath": "internal/reviewer/llmcontext/mr_context.go",
        "Diff": "@@ -1,264 +1,15 @@\n package llmcontext\n \n import (\n-\t\"context\"\n \t\"fmt\"\n \t\"regexp\"\n \t\"sort\"\n \t\"strings\"\n-\t\"time\"\n \n \t\"github.com/maxbolgarin/codry/internal/model\"\n-\t\"github.com/maxbolgarin/codry/internal/model/interfaces\"\n-\t\"github.com/maxbolgarin/errm\"\n \t\"github.com/maxbolgarin/logze/v2\"\n )\n \n-// MRContext holds comprehensive metadata about a merge request\n-type MRContext struct {\n-\t// Basic MR information\n-\tTitle       string    `json:\"title\"`\n-\tDescription string    `json:\"description\"`\n-\tBranchName  string    `json:\"branch_name\"`\n-\tCreatedAt   time.Time `json:\"created_at\"`\n-\tUpdatedAt   time.Time `json:\"updated_at\"`\n-\n-\t// Author information\n-\tAuthor         model.User       `json:\"author\"`\n-\tAuthorComments []*model.Comment `json:\"author_comments\"`\n-\n-\t// Commit information\n-\tCommits []CommitInfo `json:\"commits\"`\n-\n-\t// Issue/ticket links\n-\tLinkedIssues  []LinkedIssue  `json:\"linked_issues\"`\n-\tLinkedTickets []LinkedTicket `json:\"linked_tickets\"`\n-\n-\t// File changes\n-\tFileDiffs []*model.FileDiff       `json:\"file_diffs\"`\n-\tFilesStat map[string]FileDiffInfo `json:\"files_stat\"`\n-\n-\t// Context metadata\n-\tTotalCommits   int `json:\"total_commits\"`\n-\tTotalFiles     int `json:\"total_files\"`\n-\tTotalAdditions int `json:\"total_additions\"`\n-\tTotalDeletions int `json:\"total_deletions\"`\n-}\n-\n-type FileDiffInfo struct {\n-\tTotalAdditions int `json:\"total_additions\"`\n-\tTotalDeletions int `json:\"total_deletions\"`\n-}\n-\n-// CommitInfo contains detailed commit information\n-type CommitInfo struct {\n-\tSHA         string                      `json:\"sha\"`\n-\tSubject     string                      `json:\"subject\"`\n-\tBody        string                      `json:\"body\"`\n-\tAuthor      string                      `json:\"author\"`\n-\tTimestamp   time.Time                   `json:\"timestamp\"`\n-\tFileChanges map[string]CommitFileChange `json:\"file_changes\"`\n-\tTotalFiles  int                         `json:\"total_files\"`\n-}\n-\n-// CommitFileChange represents file changes in a specific commit\n-type CommitFileChange struct {\n-\tStatus    string `json:\"status\"`    // added, modified, deleted, renamed\n-\tAdditions int    `json:\"additions\"` // lines added in this file\n-\tDeletions int    `json:\"deletions\"` // lines deleted in this file\n-\tOldPath   string `json:\"old_path\"`  // for renamed files\n-\tNewPath   string `json:\"new_path\"`  // current file path\n-\tIsBinary  bool   `json:\"is_binary\"` // whether file is binary\n-}\n-\n-// LinkedIssue represents a linked GitHub/GitLab issue\n-type LinkedIssue struct {\n-\tID          string   `json:\"id\"`\n-\tNumber      int      `json:\"number\"`\n-\tTitle       string   `json:\"title\"`\n-\tDescription string   `json:\"description\"`\n-\tState       string   `json:\"state\"`\n-\tURL         string   `json:\"url\"`\n-\tLabels      []string `json:\"labels\"`\n-}\n-\n-// LinkedTicket represents a linked Jira/external ticket\n-type LinkedTicket struct {\n-\tID          string `json:\"id\"`\n-\tKey         string `json:\"key\"`\n-\tTitle       string `json:\"title\"`\n-\tDescription string `json:\"description\"`\n-\tStatus      string `json:\"status\"`\n-\tURL         string `json:\"url\"`\n-\tType        string `json:\"type\"`\n-}\n-\n-// BuildContextSummary creates a structured summary of the MR context for use in prompts\n-func (mrContext *MRContext) BuildContextSummary() string {\n-\tvar summary strings.Builder\n-\tsummary.Grow(2000) // Pre-allocate reasonable capacity\n-\n-\tsummary.WriteString(\"# MERGE REQUEST CONTEXT\\n\\n\")\n-\n-\t// Basic MR information\n-\tsummary.WriteString(\"## Basic Information\\n\")\n-\tsummary.WriteString(\"- Title: \")\n-\tsummary.WriteString(mrContext.Title)\n-\tsummary.WriteString(\"\\n- Branch: `\")\n-\tsummary.WriteString(mrContext.BranchName)\n-\tsummary.WriteString(\"`\\n- Author: \")\n-\tsummary.WriteString(mrContext.Author.Name)\n-\tsummary.WriteString(\" (@\")\n-\tsummary.WriteString(mrContext.Author.Username)\n-\tsummary.WriteString(\")\\n\")\n-\n-\t// Original description (filtered from AI content)\n-\tif mrContext.Description != \"\" {\n-\t\tsummary.WriteString(\"- Original Description:\\n```\\n\")\n-\t\tsummary.WriteString(mrContext.Description)\n-\t\tsummary.WriteString(\"\\n```\\n\")\n-\t}\n-\n-\t// Statistics\n-\tsummary.WriteString(\"\\n## Change Statistics\\n\")\n-\tsummary.WriteString(\"Total Changes: +\")\n-\tsummary.WriteString(intToString(mrContext.TotalAdditions))\n-\tsummary.WriteString(\" additions, -\")\n-\tsummary.WriteString(intToString(mrContext.TotalDeletions))\n-\tsummary.WriteString(\" deletions across \")\n-\tsummary.WriteString(intToString(mrContext.TotalFiles))\n-\tsummary.WriteString(\" files\\n\")\n-\n-\t// Show top changed files\n-\tmostChanged := mrContext.getMostChangedFiles(5)\n-\tif len(mostChanged) \u003e 0 {\n-\t\tsummary.WriteString(\"Most Changed Files:\\n\")\n-\t\tfor _, file := range mostChanged {\n-\t\t\tsummary.WriteString(\"  - \")\n-\t\t\tsummary.WriteString(file.FilePath)\n-\t\t\tsummary.WriteString(\": +\")\n-\t\t\tsummary.WriteString(intToString(file.Additions))\n-\t\t\tsummary.WriteString(\", -\")\n-\t\t\tsummary.WriteString(intToString(file.Deletions))\n-\t\t\tsummary.WriteString(\" (\")\n-\t\t\tsummary.WriteString(intToString(file.TotalChanges))\n-\t\t\tsummary.WriteString(\" total)\\n\")\n-\t\t}\n-\t}\n-\tsummary.WriteString(\"\\n## Commits: \")\n-\tsummary.WriteString(intToString(mrContext.TotalCommits))\n-\tsummary.WriteString(\" commits\\n\")\n-\tfor i, commit := range mrContext.Commits {\n-\t\t// Commit header with short SHA\n-\t\tsummary.WriteString(fmt.Sprintf(\"%d. \", i+1))\n-\t\tsummary.WriteString(commit.Subject)\n-\t\tsummary.WriteString(\" (@\") // Author\n-\t\tsummary.WriteString(commit.Author)\n-\t\tsummary.WriteString(\")\\nTime: \")\n-\t\tsummary.WriteString(commit.Timestamp.Format(time.RFC3339))\n-\t\tsummary.WriteString(\"\\nFiles: \")\n-\t\tsummary.WriteString(intToString(commit.TotalFiles))\n-\t\tsummary.WriteString(\"\\n\")\n-\n-\t\t// File changes in this commit\n-\t\tif len(commit.FileChanges) \u003e 0 {\n-\t\t\tfor _, change := range sortByTotalChanges(commit.FileChanges) {\n-\t\t\t\tfilePath := change.NewPath\n-\t\t\t\tif filePath == \"\" {\n-\t\t\t\t\tfilePath = change.OldPath\n-\t\t\t\t}\n-\n-\t\t\t\tsummary.WriteString(\"  - \")\n-\t\t\t\tsummary.WriteString(filePath)\n-\t\t\t\tsummary.WriteString(\": [\")\n-\t\t\t\tsummary.WriteString(change.Status)\n-\t\t\t\tsummary.WriteString(\"]: +\")\n-\t\t\t\tsummary.WriteString(intToString(change.Additions))\n-\t\t\t\tsummary.WriteString(\", -\")\n-\t\t\t\tsummary.WriteString(intToString(change.Deletions))\n-\n-\t\t\t\t// Show rename information\n-\t\t\t\tif change.Status == \"renamed\" \u0026\u0026 change.OldPath != \"\" \u0026\u0026 change.OldPath != change.NewPath {\n-\t\t\t\t\tsummary.WriteString(\" (from \")\n-\t\t\t\t\tsummary.WriteString(change.OldPath)\n-\t\t\t\t\tsummary.WriteString(\")\")\n-\t\t\t\t}\n-\n-\t\t\t\t// Binary file indicator\n-\t\t\t\tif change.IsBinary {\n-\t\t\t\t\tsummary.WriteString(\" [binary]\")\n-\t\t\t\t}\n-\n-\t\t\t\tsummary.WriteString(\"\\n\")\n-\t\t\t}\n-\t\t}\n-\n-\t\t// Commit body if available and not too long\n-\t\tif commit.Body != \"\" \u0026\u0026 len(commit.Body) \u003c= 200 {\n-\t\t\tsummary.WriteString(\"  Description: \")\n-\t\t\tsummary.WriteString(commit.Body)\n-\t\t\tsummary.WriteString(\"\\n\")\n-\t\t} else if commit.Body != \"\" {\n-\t\t\tsummary.WriteString(\"  Description: \")\n-\t\t\tsummary.WriteString(commit.Body[:197])\n-\t\t\tsummary.WriteString(\"...\\n\")\n-\t\t}\n-\n-\t\tsummary.WriteString(\"\\n\")\n-\t}\n-\n-\t// Linked issues and tickets\n-\tif len(mrContext.LinkedIssues) \u003e 0 || len(mrContext.LinkedTickets) \u003e 0 {\n-\t\tsummary.WriteString(\"\\n## Linked References\\n\")\n-\n-\t\tif len(mrContext.LinkedIssues) \u003e 0 {\n-\t\t\tsummary.WriteString(\"- Issues: \")\n-\t\t\tfor i, issue := range mrContext.LinkedIssues {\n-\t\t\t\tif i \u003e 0 {\n-\t\t\t\t\tsummary.WriteString(\", \")\n-\t\t\t\t}\n-\t\t\t\tsummary.WriteString(\"#\")\n-\t\t\t\tsummary.WriteString(intToString(issue.Number))\n-\t\t\t}\n-\t\t\tsummary.WriteString(\"\\n\")\n-\t\t}\n-\n-\t\tif len(mrContext.LinkedTickets) \u003e 0 {\n-\t\t\tsummary.WriteString(\"- Tickets: \")\n-\t\t\tfor i, ticket := range mrContext.LinkedTickets {\n-\t\t\t\tif i \u003e 0 {\n-\t\t\t\t\tsummary.WriteString(\", \")\n-\t\t\t\t}\n-\t\t\t\tsummary.WriteString(ticket.Key)\n-\t\t\t}\n-\t\t\tsummary.WriteString(\"\\n\")\n-\t\t}\n-\t}\n-\n-\t// Author comments (provide context about author's intentions)\n-\tif len(mrContext.AuthorComments) \u003e 0 {\n-\t\tsummary.WriteString(\"\\n## Author Comments \u0026 Context\\n\")\n-\t\tfor i, comment := range mrContext.AuthorComments {\n-\t\t\tif i \u003e= 3 {\n-\t\t\t\tsummary.WriteString(\"- ... and \")\n-\t\t\t\tsummary.WriteString(intToString(len(mrContext.AuthorComments) - 3))\n-\t\t\t\tsummary.WriteString(\" more comments\\n\")\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\tsummary.WriteString(\"- \")\n-\t\t\t// Truncate long comments\n-\t\t\tcommentBody := comment.Body\n-\t\t\tif len(commentBody) \u003e 150 {\n-\t\t\t\tcommentBody = commentBody[:150] + \"...\"\n-\t\t\t}\n-\t\t\tsummary.WriteString(commentBody)\n-\t\t\tsummary.WriteString(\"\\n\")\n-\t\t}\n-\t}\n-\n-\treturn summary.String()\n-}\n-\n const (\n \tstartMarkerDesc = \"\u003c!-- Codry: ai-desc-start --\u003e\"\n \tendMarkerDesc   = \"\u003c!-- Codry: ai-desc-end --\u003e\"\n@@ -283,69 +34,48 @@ var aiMarkers = []struct {\n \t{startMarkerCodeReview, endMarkerCodeReview},\n }\n \n-// mrContextBuilder gathers comprehensive metadata about merge requests\n-type mrContextBuilder struct {\n-\tprovider interfaces.CodeProvider\n-\tlog      logze.Logger\n-}\n-\n-// newMRContextBuilder creates a new context manager\n-func newMRContextBuilder(provider interfaces.CodeProvider) *mrContextBuilder {\n-\treturn \u0026mrContextBuilder{\n-\t\tprovider: provider,\n-\t\tlog:      logze.With(\"component\", \"mr_context_builder\"),\n-\t}\n-}\n-\n-type mrContextRequest struct {\n-\tProjectID    string\n-\tMergeRequest *model.MergeRequest\n-\tDiffs        []*model.FileDiff\n-\tComments     []*model.Comment\n-\tCommits      []*model.Commit\n-}\n-\n // GatherMRContext collects comprehensive metadata about a merge request\n-func (cm *mrContextBuilder) gatherMRContext(ctx context.Context, request mrContextRequest) (*MRContext, error) {\n-\tlog := cm.log.WithFields(\"project_id\", request.ProjectID, \"mr_iid\", request.MergeRequest.IID)\n+func gatherMRContext(projectID string, data *repoDataProvider) (*MRContext, error) {\n+\tlog := logze.With(\"project_id\", projectID, \"mr_iid\", data.mr.IID)\n \n \tmrContext := \u0026MRContext{\n-\t\tTitle:      request.MergeRequest.Title,\n-\t\tBranchName: request.MergeRequest.SourceBranch,\n-\t\tAuthor:     request.MergeRequest.Author,\n-\t\tCreatedAt:  request.MergeRequest.CreatedAt,\n-\t\tUpdatedAt:  request.MergeRequest.UpdatedAt,\n+\t\tTitle:      data.mr.Title,\n+\t\tBranchName: data.mr.SourceBranch,\n+\t\tAuthor:     data.mr.Author,\n+\t\tCreatedAt:  data.mr.CreatedAt,\n+\t\tUpdatedAt:  data.mr.UpdatedAt,\n+\t\tFileDiffs:  data.diffs,\n \t}\n \n \t// Step 1: Process description and filter AI content\n-\tif err := cm.processDescription(request.MergeRequest.Description, mrContext); err != nil {\n+\tif err := processDescription(data.mr.Description, mrContext); err != nil {\n \t\tlog.Warn(\"failed to process description\", \"error\", err)\n-\t\tmrContext.Description = request.MergeRequest.Description\n+\t\tmrContext.Description = data.mr.Description\n \t}\n \n \t// Step 3: Gather author comments\n-\tif err := cm.gatherAuthorComments(ctx, request, mrContext); err != nil {\n+\tif err := gatherAuthorComments(data, mrContext); err != nil {\n \t\tlog.Warn(\"failed to gather author comments\", \"error\", err)\n \t}\n \n \t// Step 4: Gather commit information\n-\tif err := cm.gatherCommitInfo(ctx, request, mrContext, log); err != nil {\n+\tif err := gatherCommitInfo(data, mrContext, log); err != nil {\n \t\tlog.Warn(\"failed to gather commit info\", \"error\", err)\n \t}\n \n \t// Step 5: Extract linked issues and tickets\n-\tif err := cm.extractLinkedReferences(mrContext); err != nil {\n+\tif err := extractLinkedReferences(mrContext); err != nil {\n \t\tlog.Warn(\"failed to extract linked references\", \"error\", err)\n \t}\n \n \t// Step 6: Calculate metadata statistics\n-\tcm.calculateMetadata(mrContext)\n+\tcalculateMetadata(mrContext)\n \n \treturn mrContext, nil\n }\n \n // processDescription filters out AI-generated content using markers\n-func (cm *mrContextBuilder) processDescription(originalDesc string, mrContext *MRContext) error {\n+func processDescription(originalDesc string, mrContext *MRContext) error {\n \tif originalDesc == \"\" {\n \t\tmrContext.Description = \"\"\n \t\treturn nil\n@@ -372,13 +102,13 @@ func (cm *mrContextBuilder) processDescription(originalDesc string, mrContext *M\n }\n \n // gatherAuthorComments collects all comments made by the MR author\n-func (cm *mrContextBuilder) gatherAuthorComments(ctx context.Context, request mrContextRequest, mrContext *MRContext) error {\n+func gatherAuthorComments(data *repoDataProvider, mrContext *MRContext) error {\n \n \tvar authorComments []*model.Comment\n \n commentsCycle:\n-\tfor _, comment := range request.Comments {\n-\t\tif comment.Author.Username == request.MergeRequest.Author.Username {\n+\tfor _, comment := range data.allComments {\n+\t\tif comment.Author.Username == data.mr.Author.Username {\n \t\t\tfor _, marker := range aiMarkers {\n \t\t\t\tif strings.Contains(comment.Body, marker.start) {\n \t\t\t\t\tcontinue commentsCycle\n@@ -393,46 +123,27 @@ commentsCycle:\n }\n \n // gatherCommitInfo collects detailed commit information using provider APIs\n-func (cm *mrContextBuilder) gatherCommitInfo(ctx context.Context, request mrContextRequest, mrContext *MRContext, log logze.Logger) error {\n-\n-\tcommits := request.Commits\n-\n-\tlog.Debug(\"retrieved commits from provider\", \"commit_count\", len(commits))\n+func gatherCommitInfo(data *repoDataProvider, mrContext *MRContext, log logze.Logger) error {\n \n \t// Convert provider commits to our internal format with file changes\n-\tfor _, commit := range commits {\n-\t\tcommitInfo, err := cm.processCommit(ctx, request, commit, mrContext)\n-\t\tif err != nil {\n-\t\t\tlog.Warn(\"failed to process commit, skipping\", \"commit_sha\", commit.SHA, \"error\", err)\n-\t\t\tcontinue\n-\t\t}\n+\tfor _, commit := range data.commits {\n+\t\tcommitInfo := processCommit(commit, data.commitsDiff)\n \t\tmrContext.Commits = append(mrContext.Commits, *commitInfo)\n \t}\n \n-\t// If no commits were successfully processed, fall back to the old method\n-\tif len(mrContext.Commits) == 0 {\n-\t\tlog.Warn(\"no commits were successfully processed, using fallback\")\n-\t\treturn cm.gatherCommitInfoFallback(request.MergeRequest, mrContext)\n-\t}\n-\n \treturn nil\n }\n \n // processCommit converts a provider commit to our internal format with file changes\n-func (cm *mrContextBuilder) processCommit(ctx context.Context, request mrContextRequest, commit *model.Commit, mrContext *MRContext) (*CommitInfo, error) {\n-\t// Get file changes for this specific commit\n-\tfileDiffs, err := cm.provider.GetCommitDiffs(ctx, request.ProjectID, commit.SHA)\n-\tif err != nil {\n-\t\treturn nil, errm.Wrap(err, \"failed to get commit diffs\")\n-\t}\n+func processCommit(commit *model.Commit, commitDiff []*model.FileDiff) *CommitInfo {\n \n-\t// Convert file diffs to our commit file changes format\n+\t// Convert file diffs to our commit file change\ts format\n \tfileChanges := make(map[string]CommitFileChange)\n-\tfor _, fileDiff := range fileDiffs {\n-\t\tstatus := cm.determineFileStatus(fileDiff)\n+\tfor _, fileDiff := range commitDiff {\n+\t\tstatus := determineFileStatus(fileDiff)\n \n \t\t// Parse the diff to count additions/deletions\n-\t\tadditions, deletions := cm.parseDiffStats(fileDiff.Diff)\n+\t\tadditions, deletions := parseDiffStats(fileDiff.Diff)\n \n \t\tfileChange := CommitFileChange{\n \t\t\tStatus:    status,\n@@ -463,58 +174,11 @@ func (cm *mrContextBuilder) processCommit(ctx context.Context, request mrContext\n \t\tTotalFiles:  len(fileChanges),\n \t}\n \n-\treturn commitInfo, nil\n-}\n-\n-// gatherCommitInfoFallback is the fallback method when provider APIs fail\n-func (cm *mrContextBuilder) gatherCommitInfoFallback(mr *model.MergeRequest, mrContext *MRContext) error {\n-\tif mr.SHA != \"\" {\n-\t\t// Create a commit entry representing the current state of the MR\n-\t\tfileChanges := make(map[string]CommitFileChange)\n-\n-\t\t// Map file diffs to commit file changes\n-\t\tfor _, fileDiff := range mrContext.FileDiffs {\n-\t\t\tstatus := cm.determineFileStatus(fileDiff)\n-\n-\t\t\t// Parse the diff to count additions/deletions\n-\t\t\tadditions, deletions := cm.parseDiffStats(fileDiff.Diff)\n-\n-\t\t\tfileChange := CommitFileChange{\n-\t\t\t\tStatus:    status,\n-\t\t\t\tAdditions: additions,\n-\t\t\t\tDeletions: deletions,\n-\t\t\t\tOldPath:   fileDiff.OldPath,\n-\t\t\t\tNewPath:   fileDiff.NewPath,\n-\t\t\t\tIsBinary:  fileDiff.IsBinary,\n-\t\t\t}\n-\n-\t\t\t// Use new path as key, fallback to old path for deleted files\n-\t\t\tkey := fileDiff.NewPath\n-\t\t\tif key == \"\" {\n-\t\t\t\tkey = fileDiff.OldPath\n-\t\t\t}\n-\n-\t\t\tfileChanges[key] = fileChange\n-\t\t}\n-\n-\t\tcommit := CommitInfo{\n-\t\t\tSHA:         mr.SHA,\n-\t\t\tSubject:     cm.generateCommitSubject(mr, fileChanges),\n-\t\t\tBody:        cm.generateCommitBody(mr, len(fileChanges)),\n-\t\t\tAuthor:      mr.Author.Name,\n-\t\t\tTimestamp:   mr.UpdatedAt,\n-\t\t\tFileChanges: fileChanges,\n-\t\t\tTotalFiles:  len(fileChanges),\n-\t\t}\n-\n-\t\tmrContext.Commits = append(mrContext.Commits, commit)\n-\t}\n-\n-\treturn nil\n+\treturn commitInfo\n }\n \n // determineFileStatus determines the status of a file change\n-func (cm *mrContextBuilder) determineFileStatus(fileDiff *model.FileDiff) string {\n+func determineFileStatus(fileDiff *model.FileDiff) string {\n \tif fileDiff.IsNew {\n \t\treturn \"added\"\n \t}\n@@ -528,7 +192,7 @@ func (cm *mrContextBuilder) determineFileStatus(fileDiff *model.FileDiff) string\n }\n \n // parseDiffStats parses a diff string to count additions and deletions\n-func (cm *mrContextBuilder) parseDiffStats(diff string) (additions, deletions int) {\n+func parseDiffStats(diff string) (additions, deletions int) {\n \tif diff == \"\" {\n \t\treturn 0, 0\n \t}\n@@ -546,7 +210,7 @@ func (cm *mrContextBuilder) parseDiffStats(diff string) (additions, deletions in\n }\n \n // generateCommitSubject creates a commit subject based on MR info\n-func (cm *mrContextBuilder) generateCommitSubject(mr *model.MergeRequest, fileChanges map[string]CommitFileChange) string {\n+func generateCommitSubject(mr *model.MergeRequest, fileChanges map[string]CommitFileChange) string {\n \t// Try to extract meaningful subject from MR title or use default\n \tif mr.Title != \"\" {\n \t\t// Truncate title if too long for commit subject\n@@ -569,7 +233,7 @@ func (cm *mrContextBuilder) generateCommitSubject(mr *model.MergeRequest, fileCh\n }\n \n // generateCommitBody creates a commit body with change summary\n-func (cm *mrContextBuilder) generateCommitBody(mr *model.MergeRequest, fileCount int) string {\n+func generateCommitBody(mr *model.MergeRequest, fileCount int) string {\n \tvar body strings.Builder\n \n \tif mr.Description != \"\" \u0026\u0026 len(mr.Description) \u003c 500 {\n@@ -592,7 +256,7 @@ func (cm *mrContextBuilder) generateCommitBody(mr *model.MergeRequest, fileCount\n }\n \n // extractLinkedReferences extracts linked issues and tickets from title, description, and commits\n-func (cm *mrContextBuilder) extractLinkedReferences(mrContext *MRContext) error {\n+func extractLinkedReferences(mrContext *MRContext) error {\n \ttextToAnalyze := strings.Join([]string{\n \t\tmrContext.Title,\n \t\tmrContext.Description,\n@@ -605,16 +269,16 @@ func (cm *mrContextBuilder) extractLinkedReferences(mrContext *MRContext) error\n \t}\n \n \t// Extract GitHub/GitLab issues\n-\tmrContext.LinkedIssues = cm.extractIssueReferences(textToAnalyze)\n+\tmrContext.LinkedIssues = extractIssueReferences(textToAnalyze)\n \n \t// Extract Jira tickets\n-\tmrContext.LinkedTickets = cm.extractTicketReferences(textToAnalyze)\n+\tmrContext.LinkedTickets = extractTicketReferences(textToAnalyze)\n \n \treturn nil\n }\n \n // extractIssueReferences finds GitHub/GitLab issue references\n-func (cm *mrContextBuilder) extractIssueReferences(text string) []LinkedIssue {\n+func extractIssueReferences(text string) []LinkedIssue {\n \tvar issues []LinkedIssue\n \n \t// Common patterns for issue references\n@@ -657,7 +321,7 @@ func (cm *mrContextBuilder) extractIssueReferences(text string) []LinkedIssue {\n }\n \n // extractTicketReferences finds Jira and other ticket references\n-func (cm *mrContextBuilder) extractTicketReferences(text string) []LinkedTicket {\n+func extractTicketReferences(text string) []LinkedTicket {\n \tvar tickets []LinkedTicket\n \n \t// Common patterns for ticket references\n@@ -698,7 +362,7 @@ func (cm *mrContextBuilder) extractTicketReferences(text string) []LinkedTicket\n }\n \n // calculateMetadata computes statistics about the MR\n-func (cm *mrContextBuilder) calculateMetadata(mrContext *MRContext) {\n+func calculateMetadata(mrContext *MRContext) {\n \tmrContext.TotalCommits = len(mrContext.Commits)\n \tmrContext.TotalFiles = len(mrContext.FileDiffs)\n \tmrContext.FilesStat = make(map[string]FileDiffInfo, len(mrContext.FileDiffs))",
        "IsNew": false,
        "IsDeleted": false,
        "IsRenamed": false,
        "IsBinary": false,
        "ContentType": ""
      },
      {
        "OldPath": "",
        "NewPath": "internal/reviewer/llmcontext/repodata.go",
        "Diff": "@@ -0,0 +1,182 @@\n+package llmcontext\n+\n+import (\n+\t\"context\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"github.com/maxbolgarin/abstract\"\n+\t\"github.com/maxbolgarin/codry/internal/model\"\n+\t\"github.com/maxbolgarin/codry/internal/model/interfaces\"\n+\t\"github.com/maxbolgarin/errm\"\n+\t\"github.com/maxbolgarin/logze/v2\"\n+)\n+\n+type repoDataProvider struct {\n+\tprovider interfaces.CodeProvider\n+\n+\tmr           *model.MergeRequest\n+\tdiffs        []*model.FileDiff\n+\tallComments  []*model.Comment\n+\trepoInfo     *model.RepositoryInfo\n+\trepoDataHead *model.RepositorySnapshot\n+\trepoDataBase *model.RepositorySnapshot\n+\n+\tcommits     []*model.Commit\n+\tcommitsDiff []*model.FileDiff\n+\n+\tisVerbose bool\n+\n+\tlog logze.Logger\n+\n+\tmu sync.Mutex\n+}\n+\n+func newRepoDataProvider(provider interfaces.CodeProvider, isVerbose bool) *repoDataProvider {\n+\treturn \u0026repoDataProvider{provider: provider, log: logze.With(\"Module\", \"repo_data_provider\"), isVerbose: isVerbose}\n+}\n+\n+func (r *repoDataProvider) loadData(ctx context.Context, projectID string, mrIID int) error {\n+\twaiterSet := abstract.NewWaiterSet(r.log)\n+\twaiterSet.Add(ctx, func(ctx context.Context) error {\n+\t\treturn r.loadMR(ctx, projectID, mrIID)\n+\t})\n+\twaiterSet.Add(ctx, func(ctx context.Context) error {\n+\t\treturn r.loadRepoInfo(ctx, projectID)\n+\t})\n+\twaiterSet.Add(ctx, func(ctx context.Context) error {\n+\t\treturn r.loadDiffs(ctx, projectID, mrIID)\n+\t})\n+\twaiterSet.Add(ctx, func(ctx context.Context) error {\n+\t\treturn r.loadAllComments(ctx, projectID, mrIID)\n+\t})\n+\twaiterSet.Add(ctx, func(ctx context.Context) error {\n+\t\treturn r.loadRepoDataHead(ctx, projectID)\n+\t})\n+\twaiterSet.Add(ctx, func(ctx context.Context) error {\n+\t\treturn r.loadRepoDataBase(ctx, projectID)\n+\t})\n+\twaiterSet.Add(ctx, func(ctx context.Context) error {\n+\t\treturn r.loadCommitsDiff(ctx, projectID, mrIID)\n+\t})\n+\terr := waiterSet.Await(ctx)\n+\tif err != nil {\n+\t\treturn errm.Wrap(err, \"failed to load repository data\")\n+\t}\n+\n+\treturn nil\n+}\n+\n+func (r *repoDataProvider) loadMR(ctx context.Context, projectID string, mrIID int) error {\n+\ttimer := abstract.StartTimer()\n+\tmr, err := r.provider.GetMergeRequest(ctx, projectID, mrIID)\n+\tif err != nil {\n+\t\treturn errm.Wrap(err, \"failed to get merge request\")\n+\t}\n+\tr.mu.Lock()\n+\tdefer r.mu.Unlock()\n+\tr.mr = mr\n+\tr.log.DebugIf(r.isVerbose, \"loaded merge request\", \"mr\", mrIID, \"elapsed\", timer.ElapsedTime().String())\n+\treturn nil\n+}\n+\n+func (r *repoDataProvider) loadDiffs(ctx context.Context, projectID string, mrIID int) error {\n+\ttimer := abstract.StartTimer()\n+\tdiffs, err := r.provider.GetMergeRequestDiffs(ctx, projectID, mrIID)\n+\tif err != nil {\n+\t\treturn errm.Wrap(err, \"failed to get MR diffs\")\n+\t}\n+\tr.mu.Lock()\n+\tdefer r.mu.Unlock()\n+\tr.diffs = diffs\n+\tr.log.DebugIf(r.isVerbose, \"loaded merge request diffs\", \"mr\", mrIID, \"elapsed\", timer.ElapsedTime().String())\n+\treturn nil\n+}\n+\n+func (r *repoDataProvider) loadCommitsDiff(ctx context.Context, projectID string, mrIID int) error {\n+\ttimer := abstract.StartTimer()\n+\tcommits, err := r.provider.GetMergeRequestCommits(ctx, projectID, mrIID)\n+\tif err != nil {\n+\t\treturn errm.Wrap(err, \"failed to get merge request commits\")\n+\t}\n+\tvar commitsDiff []*model.FileDiff\n+\tfor _, commit := range commits {\n+\t\tfileDiffs, err := r.provider.GetCommitDiffs(ctx, projectID, commit.SHA)\n+\t\tif err != nil {\n+\t\t\treturn errm.Wrap(err, \"failed to get commit diffs\")\n+\t\t}\n+\t\tcommitsDiff = append(commitsDiff, fileDiffs...)\n+\t}\n+\tr.mu.Lock()\n+\tdefer r.mu.Unlock()\n+\tr.commits = commits\n+\tr.commitsDiff = commitsDiff\n+\tr.log.DebugIf(r.isVerbose, \"loaded merge request commits diffs\", \"mr\", mrIID, \"elapsed\", timer.ElapsedTime().String())\n+\treturn nil\n+}\n+\n+func (r *repoDataProvider) loadAllComments(ctx context.Context, projectID string, mrIID int) error {\n+\ttimer := abstract.StartTimer()\n+\tcomments, err := r.provider.GetComments(ctx, projectID, mrIID)\n+\tif err != nil {\n+\t\treturn errm.Wrap(err, \"failed to get comments\")\n+\t}\n+\tr.mu.Lock()\n+\tdefer r.mu.Unlock()\n+\tr.allComments = comments\n+\tr.log.DebugIf(r.isVerbose, \"loaded merge request comments\", \"mr\", mrIID, \"elapsed\", timer.ElapsedTime().String())\n+\treturn nil\n+}\n+\n+func (r *repoDataProvider) loadRepoInfo(ctx context.Context, projectID string) error {\n+\ttimer := abstract.StartTimer()\n+\trepoInfo, err := r.provider.GetRepositoryInfo(ctx, projectID)\n+\tif err != nil {\n+\t\treturn errm.Wrap(err, \"failed to get repository info\")\n+\t}\n+\tr.mu.Lock()\n+\tdefer r.mu.Unlock()\n+\tr.repoInfo = repoInfo\n+\tr.log.DebugIf(r.isVerbose, \"loaded repository info\", \"repo\", repoInfo.Name, \"elapsed\", timer.ElapsedTime().String())\n+\treturn nil\n+}\n+\n+func (r *repoDataProvider) loadRepoDataHead(ctx context.Context, projectID string) error {\n+\ttimer := abstract.StartTimer()\n+\tfor r.mr == nil {\n+\t\ttime.Sleep(100 * time.Millisecond)\n+\t}\n+\trepoDataHead, err := r.provider.GetRepositorySnapshot(ctx, projectID, r.mr.SHA)\n+\tif err != nil {\n+\t\treturn errm.Wrap(err, \"failed to get repository data (head)\")\n+\t}\n+\tr.mu.Lock()\n+\tdefer r.mu.Unlock()\n+\tr.repoDataHead = repoDataHead\n+\tr.log.DebugIf(r.isVerbose, \"loaded repository data (head)\", \"mr\", r.mr.SHA, \"elapsed\", timer.ElapsedTime().String())\n+\treturn nil\n+}\n+\n+func (r *repoDataProvider) loadRepoDataBase(ctx context.Context, projectID string) error {\n+\ttimer := abstract.StartTimer()\n+\tfor r.repoInfo == nil {\n+\t\ttime.Sleep(100 * time.Millisecond)\n+\t}\n+\tfor r.mr == nil {\n+\t\ttime.Sleep(100 * time.Millisecond)\n+\t}\n+\tfor _, branch := range r.repoInfo.Branches {\n+\t\tif branch.Name == r.mr.TargetBranch {\n+\t\t\trepoDataBase, err := r.provider.GetRepositorySnapshot(ctx, projectID, branch.SHA)\n+\t\t\tif err != nil {\n+\t\t\t\treturn errm.Wrap(err, \"failed to get repository data\")\n+\t\t\t}\n+\t\t\tr.mu.Lock()\n+\t\t\tdefer r.mu.Unlock()\n+\t\t\tr.repoDataBase = repoDataBase\n+\t\t\tr.log.DebugIf(r.isVerbose, \"loaded repository data (base)\", \"mr\", r.mr.IID, \"elapsed\", timer.ElapsedTime().String())\n+\t\t\treturn nil\n+\t\t}\n+\t}\n+\treturn errm.New(\"failed to find repository data for base branch\")\n+}",
        "IsNew": true,
        "IsDeleted": false,
        "IsRenamed": false,
        "IsBinary": false,
        "ContentType": ""
      },
      {
        "OldPath": "",
        "NewPath": "internal/reviewer/reviewer.go",
        "Diff": "@@ -62,7 +62,7 @@ func New(cfg Config, provider interfaces.CodeProvider, agent *agent.Agent) (*Rev\n \t\tparser:         astparser.NewDiffParser(),\n \t\tprocessedMRs:   abstract.NewSafeMapOfMaps[string, string, string](),\n \t\treviewedMRs:    abstract.NewSafeMap[string, reviewTrackingInfo](),\n-\t\tcontextBuilder: llmcontext.NewBuilder(provider),\n+\t\tcontextBuilder: llmcontext.NewBuilder(provider, cfg.Verbose),\n \t}\n \n \treturn s, nil",
        "IsNew": false,
        "IsDeleted": false,
        "IsRenamed": false,
        "IsBinary": false,
        "ContentType": ""
      }
    ],
    "files_stat": {
      "context_bundle.json": {
        "total_additions": 0,
        "total_deletions": 0
      },
      "internal/reviewer/astparser/context_manager.go": {
        "total_additions": 77,
        "total_deletions": 235
      },
      "internal/reviewer/astparser/diff_parser.go": {
        "total_additions": 1,
        "total_deletions": 1
      },
      "internal/reviewer/astparser/languages.go": {
        "total_additions": 68,
        "total_deletions": 7
      },
      "internal/reviewer/astparser/parser.go": {
        "total_additions": 512,
        "total_deletions": 33
      },
      "internal/reviewer/astparser/special_cases_helpers.go": {
        "total_additions": 1,
        "total_deletions": 1
      },
      "internal/reviewer/astparser/symbol_analyzer.go": {
        "total_additions": 7,
        "total_deletions": 8
      },
      "internal/reviewer/astparser/types.go": {
        "total_additions": 54,
        "total_deletions": 0
      },
      "internal/reviewer/llmcontext/builder.go": {
        "total_additions": 31,
        "total_deletions": 537
      },
      "internal/reviewer/llmcontext/context.go": {
        "total_additions": 238,
        "total_deletions": 54
      },
      "internal/reviewer/llmcontext/mr_context.go": {
        "total_additions": 37,
        "total_deletions": 373
      },
      "internal/reviewer/llmcontext/repodata.go": {
        "total_additions": 182,
        "total_deletions": 0
      },
      "internal/reviewer/reviewer.go": {
        "total_additions": 1,
        "total_deletions": 1
      }
    },
    "total_commits": 2,
    "total_files": 13,
    "total_additions": 1209,
    "total_deletions": 1250
  }
}